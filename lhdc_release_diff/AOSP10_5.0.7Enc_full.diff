diff --git a/external/liblhdc/Android.bp b/external/liblhdc/Android.bp
new file mode 100755
index 00000000..30d11199
--- /dev/null
+++ b/external/liblhdc/Android.bp
@@ -0,0 +1,50 @@
+
+cc_prebuilt_library_shared {
+    name: "liblhdc",
+
+    export_include_dirs: ["include"],
+    arch: {
+        arm: {
+            srcs: ["libs/armeabi-v7a/liblhdc.so",],
+        },
+        arm64: {
+            srcs: ["libs/arm64-v8a/liblhdc.so",],
+        },
+    },
+
+    strip: {
+        none:true,
+    },
+
+    shared_libs: [
+        "liblog",
+        "libstdc++",
+    ],
+}
+
+cc_library_shared {
+    name: "liblhdcBT_enc",
+   // vendor_available: true,
+   // vndk: {
+   //     enabled: true,
+   // },
+    arch: {
+        arm: {
+            instruction_set: "arm",
+        },
+    },
+    export_include_dirs: ["inc"],
+    local_include_dirs: ["inc", "include", ],
+    srcs: [
+        "src/lhdcBT_enc.c",
+    ],
+    // -D_32BIT_FIXED_POINT should be added to cflags for devices without a FPU
+    // unit such as ARM Cortex-R series or external 32-bit DSPs.
+    cflags: ["-O2", "-Wall", "-Wextra", "-Wmacro-redefined"],
+
+    shared_libs: [
+        "libcutils",
+        "liblog",
+        "liblhdc",
+    ],
+}
diff --git a/external/liblhdc/inc/lhdcBT.h b/external/liblhdc/inc/lhdcBT.h
new file mode 100755
index 00000000..f478e213
--- /dev/null
+++ b/external/liblhdc/inc/lhdcBT.h
@@ -0,0 +1,392 @@
+
+
+#ifndef _LHDCBT_H_
+#define _LHDCBT_H_
+#ifdef __cplusplus
+extern "C" {
+#endif
+#ifndef LHDCBT_API
+#define LHDCBT_API
+#endif /* LHDCBT_API  */
+#include "lhdc_api.h"
+
+typedef enum _lhdcBT_ext_func_field_t{
+  LHDCBT_EXT_FUNC_AR = 0,
+  LHDCBT_EXT_FUNC_LARC,
+  LHDCBT_EXT_FUNC_EXTR,
+  LHDCBT_EXT_FUNC_JAS,
+  //LHDCBT_EXT_FUNC_META,
+  LHDCBT_EXT_FUNC_MAX,
+} lhdcBT_ext_func_field_t;
+
+//
+// Extend API Basic Settings Definition
+//
+#define LHDC_EXTEND_FUNC_CODE_A2DP_TYPE_MASK            (0x0A)
+#define LHDC_EXTEND_FUNC_CODE_LIB_TYPE_MASK             (0x0C)
+#define EXTEND_FUNC_CODE_MIN_BUFFER_LEN                 8
+
+/* **********************************************
+ *  API: Version Control
+ * ***********************************************/
+#define EXTEND_FUNC_GENERIC_VERSION_NUMBER_V1               ((unsigned int) 0x01000000)
+#define EXTEND_FUNC_GENERIC_VERSION_NUMBER_V2               ((unsigned int) 0x02000000)
+
+#define EXTEND_FUNC_MIN_BUFFER_LEN_GET_API_VERSION_V1       8
+#define EXTEND_FUNC_MIN_BUFFER_LEN_GET_API_VERSION_V2       16
+
+/* **********************************************
+ *  LIB API: Config Type
+ * ***********************************************/
+/* * * * * * * * * * * * * * * *
+ *   META                      *
+ * * * * * * * * * * * * * * * */
+//   META :: API Code
+#define EXTEND_FUNC_CODE_SET_CONFIG_META        ((unsigned int) 0x0C000001)
+#define EXTEND_FUNC_CODE_GET_CONFIG_META        ((unsigned int) 0x0C010001)
+//   META :: API Version
+#define EXTEND_FUNC_VER_SET_CONFIG_META_V1      ((unsigned int) 0x01000000)
+#define EXTEND_FUNC_VER_SET_CONFIG_META_V2      ((unsigned int) 0x02000000)
+#define EXTEND_FUNC_VER_GET_CONFIG_META_V1      ((unsigned int) 0x01000000)
+#define EXTEND_FUNC_VER_GET_CONFIG_META_V2      ((unsigned int) 0x02000000)
+//   META :: API Min Required Buffer Size
+#define EXTEND_FUNC_VER_SET_CONFIG_META_REQ_BUFSIZE_V2      16  //TBD
+#define EXTEND_FUNC_VER_GET_CONFIG_META_REQ_BUFSIZE_V2      16  //TBD
+
+/* * * * * * * * * * * * * * * *
+ *   AR                        *
+ * * * * * * * * * * * * * * * */
+//   AR :: API Code
+#define EXTEND_FUNC_CODE_SET_CONFIG_AR          ((unsigned int) 0x0C000002)
+#define EXTEND_FUNC_CODE_GET_CONFIG_AR          ((unsigned int) 0x0C010002)
+//   AR :: API Version
+#define EXTEND_FUNC_VER_SET_CONFIG_AR_V1        ((unsigned int) 0x01000000)
+#define EXTEND_FUNC_VER_SET_CONFIG_AR_V2        ((unsigned int) 0x02000000)
+#define EXTEND_FUNC_VER_SET_CONFIG_AR_V3        ((unsigned int) 0x03000000)
+#define EXTEND_FUNC_VER_GET_CONFIG_AR_V1        ((unsigned int) 0x01000000)
+#define EXTEND_FUNC_VER_GET_CONFIG_AR_V2        ((unsigned int) 0x02000000)
+//   AR :: API Min Required Buffer Size
+#define EXTEND_FUNC_VER_SET_CONFIG_AR_REQ_BUFSIZE_V2      16    //TBD
+#define EXTEND_FUNC_VER_GET_CONFIG_AR_REQ_BUFSIZE_V2      16    //TBD
+
+
+/* **********************************************
+ *  LIB API: Data Type
+ * ***********************************************/
+/* * * * * * * * * * * * * * * *
+ *   GYRO2D                    *
+ * * * * * * * * * * * * * * * */
+//   GYRO2D :: API Code
+#define EXTEND_FUNC_CODE_SET_DATA_GYRO2D        ((unsigned int) 0x0D000001)
+//   GYRO2D :: API Version
+#define EXTEND_FUNC_VER_SET_DATA_GYRO2D_V1      ((unsigned int) 0x01000000)
+#define EXTEND_FUNC_VER_SET_DATA_GYRO2D_V2      ((unsigned int) 0x02000000)
+//   GYRO2D :: API Min Required Buffer Size
+#define EXTEND_FUNC_VER_SET_DATA_GYRO2D_REQ_BUFSIZE_V2      16    //TBD (8 + 2gyro + 6pad)
+
+
+/* **********************************************
+ *  A2DP-Extended API:
+ * ***********************************************/
+/* * * * * * * * * * * * * * * *
+ *   GetA2DPSpecifis           *
+ * * * * * * * * * * * * * * * */
+//   GetA2DPSpecifis :: API Code
+#define EXTEND_FUNC_CODE_GET_SPECIFIC           ((unsigned int) 0x0A010001)
+//   GetA2DPSpecifis :: API Version
+#define EXTEND_FUNC_VER_GET_SPECIFIC_V1         ((unsigned int) 0x01000000)
+#define EXTEND_FUNC_VER_GET_SPECIFIC_V2         ((unsigned int) 0x02000000)
+
+/* ************************************************************************
+ * Version format info of EXTEND_FUNC_CODE_GET_SPECIFIC
+ * EXTEND_FUNC_VER_GET_SPECIFIC_V1:  Total Size: 41 bytes
+   * API Version:                   (4 bytes)
+   * API Code:                      (4 bytes)
+   * A2DP Codec Config Code:        (1 bytes)
+   * A2dp Specific1:                (8 bytes)
+   * A2dp Specific2:                (8 bytes)
+   * A2dp Specific3:                (8 bytes)
+   * A2dp Specific4:                (8 bytes)
+ * EXTEND_FUNC_VER_GET_SPECIFIC_V2:  Total Size: 64 bytes
+   * API Version:                   (4 bytes)
+   * API Code:                      (4 bytes)
+   * A2DP Codec Config Code:        (1 bytes)
+   * Reserved:                      (7 bytes)
+   * A2dp Specific1:                (8 bytes)
+   * A2dp Specific2:                (8 bytes)
+   * A2dp Specific3:                (8 bytes)
+   * A2dp Specific4:                (8 bytes)
+   * Capabilities Metadata sub fields:  (7*2 bytes)
+     * sub[0~1]:    JAS
+     * sub[2~3]:    AR
+     * sub[4~5]:    META
+     * sub[6~7]:    LLAC
+     * sub[8~9]:    MBR
+     * sub[10~11]:  LARC
+     * sub[12~13]:  LHDCV4
+   * Padded:                        (2 bytes)
+ * ************************************************************************/
+#define LHDC_EXTEND_FUNC_CONFIG_API_VERSION_SIZE        4       /* API version */
+#define LHDC_EXTEND_FUNC_CONFIG_API_CODE_SIZE           4       /* API index code */
+#define LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_SIZE       1       /* A2DP codec config code */
+#define LHDC_EXTEND_FUNC_CONFIG_RESERVED_V2             7       /* V2 Reserved bytes */
+#define LHDC_EXTEND_FUNC_CONFIG_SPECIFIC1_SIZE          8       /* Specific 1 */
+#define LHDC_EXTEND_FUNC_CONFIG_SPECIFIC2_SIZE          8       /* Specific 2 */
+#define LHDC_EXTEND_FUNC_CONFIG_SPECIFIC3_SIZE          8       /* Specific 3 */
+#define LHDC_EXTEND_FUNC_CONFIG_SPECIFIC4_SIZE          8       /* Specific 4 */
+/* Capabilities metadata fields(2 bytes for each tuple) */
+#define LHDC_EXTEND_FUNC_CONFIG_CAPMETA_SIZE_V2         (7<<1)  /* V2 Capabilities */
+#define LHDC_EXTEND_FUNC_CONFIG_PADDED_SIZE_V2          2       /* V2 Padded Fields */
+
+/* Total size of buffer */
+#define LHDC_EXTEND_FUNC_CONFIG_TOTAL_FIXED_SIZE_V1    (LHDC_EXTEND_FUNC_CONFIG_API_VERSION_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_API_CODE_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC1_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC2_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC3_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC4_SIZE)
+#define LHDC_EXTEND_FUNC_CONFIG_TOTAL_FIXED_SIZE_V2    (LHDC_EXTEND_FUNC_CONFIG_API_VERSION_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_API_CODE_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_RESERVED_V2 + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC1_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC2_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC3_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC4_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_CAPMETA_SIZE_V2 + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_PADDED_SIZE_V2)
+/* Head of each field */
+#define LHDC_EXTEND_FUNC_CONFIG_API_VERSION_HEAD        (0)
+#define LHDC_EXTEND_FUNC_CONFIG_API_CODE_HEAD           (LHDC_EXTEND_FUNC_CONFIG_API_VERSION_HEAD + 4)  //4
+#define LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD       (LHDC_EXTEND_FUNC_CONFIG_API_CODE_HEAD + 4)     //8
+/* Following part in V1 */
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V1        (LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD + 1) //9~16
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V1        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V1 + 8)  //17~24
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V1        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V1 + 8)  //25~32
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V1        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V1 + 8)  //33~40
+/* Following part in V2 */
+#define LHDC_EXTEND_FUNC_A2DP_RESERVED_HEAD_V2          (LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD + 1) //9~15
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V2        (LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD + 8) //16~23
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V2        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V2 + 8)  //24~31
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V2        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V2 + 8)  //32~39
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V2        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V2 + 8)  //40~47
+#define LHDC_EXTEND_FUNC_A2DP_CAPMETA_HEAD_V2           (LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V2 + 8)  //48~61
+#define LHDC_EXTEND_FUNC_A2DP_PADDED_HEAD_V2            (LHDC_EXTEND_FUNC_A2DP_CAPMETA_HEAD_V2 + LHDC_EXTEND_FUNC_CONFIG_CAPMETA_SIZE_V2)   //62~63
+
+/* code definition mapping to A2DP codec specific in a2dp_codec_api.h
+ * 0x01: codec_config_
+ * 0x02: codec_capability_
+ * 0x03: codec_local_capability_
+ * 0x04: codec_selectable_capability_
+ * 0x05: codec_user_config_
+ * 0x06: codec_audio_config_
+ */
+#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_FINAL_CFG          (0x01)
+#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_FINAL_CAP          (0x02)
+#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_LOCAL_CAP          (0x03)
+#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_SELECTABLE_CAP     (0x04)
+#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_USER_CFG           (0x05)
+#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_AUDIO_CFG          (0x06)
+
+/************************
+ * Capability Meta Format: (denotes where source capabilities bits are stored in specifics)
+   * Capability Code:                   (1 byte)
+   * Saving Position Info:              (1 byte)
+ ************************/
+/* Capabilities's code: */
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE      (0x01)
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE       (0x02)
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE     (0x03)
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE     (0x04)
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE      (0x05)
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE     (0x06)
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE       (0x07)
+
+/* Capabilities's saving position Info:
+ *  1. in which specific                        (represented in leftmost 2-bits)
+ *  2. at which bit position of the specific    (represented in rightmost 6-bits)
+ * */
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFIC1_INDEX    (0x00)     //2-bit:00
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFIC2_INDEX    (0x40)     //2-bit:01
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX    (0x80)     //2-bit:10
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFIC4_INDEX    (0xC0)     //2-bit:11
+/********************************************************************************/
+
+
+
+
+#define EXTEND_FUNC_RET_OK                      ((int) 0)
+#define EXTEND_FUNC_RET_INVALID_HANDLE          ((int) 0xE01)
+#define EXTEND_FUNC_RET_INVALID_PARAMETER       ((int) 0xE02)
+#define EXTEND_FUNC_RET_FUNC_NOT_SUPPORT        ((int) 0xE03)
+#define EXTEND_FUNC_RET_VERSION_NOT_SUPPORT     ((int) 0xE04)
+#define EXTEND_FUNC_RET_BUF_UNDERRUN            ((int) 0xE05)
+#define EXTEND_FUNC_RET_ERROR                   ((int) 0xE06)
+#define EXTEND_FUNC_RET_NOT_READY               ((int) 0xE07)
+#define EXTEND_FUNC_RET_REQ_BUFSIZE_NOT_MATCH   ((int) 0xE08)
+
+
+//
+// META
+//
+#define META_ST_VER_V1                           ((unsigned int) 0x00010000)
+#define META_ST_VER_V2                           ((unsigned int) 0x00020000)
+#pragma pack (push)
+#pragma pack (1)
+typedef struct __ST_LHDC_SET_META {
+
+    unsigned char     header[8];
+    unsigned int      meta_ver;
+    unsigned char     meta_mem_size;
+    unsigned char     meta_enable;
+    unsigned char     meta_set;
+    unsigned char     meta_metadata_length;
+//  unsigned char     meta_metadata[64];
+
+} ST_LHDC_SET_META, *PST_LHDC_SET_META;
+#pragma pack(pop)
+
+#pragma pack (push)
+#pragma pack (1)
+typedef struct __ST_LHDC_GET_META {
+
+    unsigned char     header[8];
+    unsigned int      meta_ver;
+    unsigned char     meta_mem_size;
+    unsigned char     meta_st;     // [0] 1: reserved bit, [1] 1: in meta mode/0: not in meta mode
+    unsigned char     jas_status;
+
+} ST_LHDC_GET_META, *PST_LHDC_GET_META;
+#pragma pack(pop)
+
+//
+// AR
+//
+
+#pragma pack (push)
+#pragma pack (1)
+typedef struct __ST_LHDC_AR
+{
+    unsigned char     header[8];
+    unsigned int      ver;
+    unsigned int      size;
+    unsigned int      app_ar_enabled;
+    int Ch1_Pos;
+    int Ch2_Pos;
+    int Ch3_Pos;
+    int Ch4_Pos;
+    int Ch5_Pos;
+    int Ch6_Pos;
+    float Ch1_L_PreGain;
+    float Ch1_R_PreGain;
+    float Ch2_L_PreGain;
+    float Ch2_R_PreGain;
+    float Ch3_L_PreGain;
+    float Ch3_R_PreGain;
+    float Ch4_L_PreGain;
+    float Ch4_R_PreGain;
+    float Ch5_L_PreGain;
+    float Ch5_R_PreGain;
+    float Ch6_L_PreGain;
+    float Ch6_R_PreGain;
+    float Ch1_PostGain;
+    float Ch2_PostGain;
+    float Ch3_PostGain;
+    float Ch4_PostGain;
+    float Ch5_PostGain;
+    float Ch6_PostGain;
+    float Dry_Val;
+    float Wet_Val;
+    float Dis_1;
+    float Dis_2;
+    float Dis_3;
+    float Dis_4;
+    float Dis_5;
+    float Rev_1;
+    float Rev_2;
+    float Rev_3;
+    float Rev_4;
+    float Rev_5;
+    float Rev_gain;
+    float ThreeD_gain;
+} ST_LHDC_AR, *PST_LHDC_AR;
+#pragma pack(pop)
+
+#pragma pack (push)
+#pragma pack (1)
+typedef struct __ST_LHDC_AR_GYRO
+{
+    unsigned char     header[8];
+    int world_coordinate_x;
+    int world_coordinate_y;
+    int world_coordinate_z;
+
+} ST_LHDC_AR_GYRO, *PST_LHDC_AR_GYRO;
+#pragma pack(pop)
+
+#ifdef NEW_API_SET
+//for NEW API used!!!!
+typedef struct {
+  uint32_t sample_rate;
+  LHDCBT_SMPL_FMT_T bits_per_sample;
+  LHDCBT_QUALITY_T audio_quality;
+  bool channel_split_enabled;
+  uint32_t packet_mtu;
+  uint32_t encode_interval;
+
+  bool output_size_cal;
+} lhdc_init_param_t;
+
+int lhdcBT_init(HANDLE_LHDC_BT handle, lhdc_init_param_t * param);
+#else
+HANDLE_LHDC_BT lhdcBT_get_handle(int version);
+
+
+void lhdcBT_free_handle(HANDLE_LHDC_BT handle);
+
+//static const char* LHDC_ENCODE_NAME = "lhdcBT_encode";
+//Encoder for V2
+int lhdcBT_encode(HANDLE_LHDC_BT hLhdcParam, void* p_pcm, unsigned char* p_stream);
+//Encoder for V3
+int lhdcBT_encodeV3(HANDLE_LHDC_BT hLhdcParam, void* p_pcm, unsigned char* out_put, uint32_t * written, uint32_t * out_fraems);
+
+int lhdcBT_get_bitrate(HANDLE_LHDC_BT hLhdcParam);
+
+int lhdcBT_set_bitrate(HANDLE_LHDC_BT handle, int bitrate_inx);
+
+//int lhdcBT_get_sampling_freq(HANDLE_LHDC_BT handle);
+
+//int lhdcBT_init_handle_encode(HANDLE_LHDC_BT handle,int sampling_freq, int bitPerSample, int bitrate_inx, int dualChannel, int need_padding, int mtu, int interval);
+
+//int lhdcBT_get_error_code(HANDLE_LHDC_BT handle);
+
+int lhdcBT_adjust_bitrate(HANDLE_LHDC_BT handle, size_t queueLength) ;
+
+//void lhdcBT_setLimitBitRate(HANDLE_LHDC_BT handle, int max_rate_index);
+
+//uint8_t lhdcBT_getSupportedVersion(HANDLE_LHDC_BT handle);
+
+int     lhdcBT_get_block_Size(HANDLE_LHDC_BT handle);
+
+int lhdcBT_set_ext_func_state(HANDLE_LHDC_BT handle, lhdcBT_ext_func_field_t field, bool enabled, void * priv, int priv_data_len);
+
+int lhdcBT_get_ext_func_state(HANDLE_LHDC_BT handle, lhdcBT_ext_func_field_t field, bool * enabled);
+
+//
+// Extra API
+//
+// 1. API -- Set User Config (Extend)
+int lhdcBT_set_user_exconfig(HANDLE_LHDC_BT handle, char* userConfig, int clen);
+// 2. API -- Get User Config (Extend)
+int lhdcBT_get_user_exconfig(HANDLE_LHDC_BT handle, char* userConfig, int clen);
+// 3. API -- Set User Data (Extend)
+void lhdcBT_set_user_exdata(HANDLE_LHDC_BT handle, char* userConfig, int clen);
+// 4. API -- Get Version 
+int lhdcBT_get_user_exApiver(HANDLE_LHDC_BT handle, char *version, int clen);
+
+#endif
+#ifdef __cplusplus
+}
+#endif
+#endif /* _LHDCBT_H_ */
diff --git a/external/liblhdc/include/cirbuf.h b/external/liblhdc/include/cirbuf.h
new file mode 100755
index 00000000..9cd263d2
--- /dev/null
+++ b/external/liblhdc/include/cirbuf.h
@@ -0,0 +1,29 @@
+#ifndef	_CIRBUF_H_
+#define	_CIRBUF_H_
+
+struct cirbuf_s
+{
+	unsigned int	idx;
+	unsigned int	odx;
+	unsigned int	s_len;
+	unsigned int	r_len;
+	unsigned int	max_len;
+	unsigned char	*cbuf;
+};
+typedef  struct cirbuf_s savi_circ_buf;
+
+void cirbuf_init( struct cirbuf_s *pcb, unsigned char *buf, int len);
+
+void cirbuf_reset( struct cirbuf_s *pcb);
+
+int cirbuf_len( struct cirbuf_s *pcb);
+int cirbuf_empty_len( struct cirbuf_s *pcb);
+
+int cirbuf_get( struct cirbuf_s *pcb, unsigned char *buf, int len);
+int cirbuf_put( struct cirbuf_s *pcb, unsigned char *buf, int len);
+
+int cirbuf_get_no_copy( struct cirbuf_s *pcb, unsigned char **buf, int len);
+int cirbuf_put_no_copy( struct cirbuf_s *pcb, unsigned char **buf, int len);
+
+#endif	/* _CIRBUF_H_ */
+
diff --git a/external/liblhdc/include/lhdc_api.h b/external/liblhdc/include/lhdc_api.h
new file mode 100755
index 00000000..079719cb
--- /dev/null
+++ b/external/liblhdc/include/lhdc_api.h
@@ -0,0 +1,215 @@
+#ifndef __LHDC_API_H__
+#define __LHDC_API_H__
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+#include "lhdc_process.h"
+#include "cirbuf.h"
+
+#define LHDC_ENC_LIB_COPYRIGHT  "LHDC Encode Library @Copyright SAVITECH 2021"
+#define LHDC_VERSION            LHDCVER
+
+typedef enum {
+    LHDCBT_SMPL_FMT_S16 = 16,
+    LHDCBT_SMPL_FMT_S24 = 24,
+} LHDCBT_SMPL_FMT_T;
+
+typedef enum name {
+    LHDCBT_QUALITY_LOW0 = 0,
+    LHDCBT_QUALITY_LOW1,
+    LHDCBT_QUALITY_LOW2,
+    LHDCBT_QUALITY_LOW3,
+    LHDCBT_QUALITY_LOW4,
+    LHDCBT_QUALITY_LOW,
+    LHDCBT_QUALITY_MID,
+    LHDCBT_QUALITY_HIGH,
+    LHDCBT_QUALITY_AUTO,
+    LHDCBT_QUALITY_RESET_AUTO,
+    LHDCBT_QUALITY_MAX
+} LHDCBT_QUALITY_T;
+
+
+#define LHDCV1_BT_ENC_BLOCK_SIZE  512
+
+#define LHDCV2_BT_ENC_BLOCK_SIZE  512
+
+#define LHDCV3_BT_ENC_BLOCK_SIZE  256
+
+
+#define MAX_CHANNEL		    		2
+#define LHDC_AR_PROCESS_CH			6
+#define LHDC_SEPARATE_OUTPUR_CH     4
+#define LHDC_AR_VERSION             "LHDC AR v1.1a.14 2021-7-7  @Copyright SAVITECH 2021"
+
+typedef enum _lhdc_enc_type_t {
+    ENC_TYPE_UNKNOWN = 0,
+    ENC_TYPE_LHDC,
+    ENC_TYPE_LLAC,
+    ENC_TYPE_MAX,
+    ENC_TYPE_ERR = ENC_TYPE_MAX
+} lhdc_enc_type_t;
+
+typedef enum _lhdc_filter_type_t{
+    LHDC_FILTER_PASSTHROUGH = 0,
+    LHDC_FILTER_AR,
+    LHDC_FILTER_ERR = 0xffU
+} lhdc_filter_type_t;
+
+
+typedef struct _llac_para_t {
+    
+    uint8_t* lh4_enc;
+    int32_t  sample_rate;
+    int32_t  bits_per_sample;
+
+    LHDCBT_QUALITY_T qualityStatus;      //0xff == Auto bitrate
+    LHDCBT_QUALITY_T limitBitRateStatus;
+    int32_t  lastBitrate;     //Record lastbitrate for auto bitrate adjust.
+    int32_t  real_bitrate;
+
+    uint16_t avg_cnt;
+    uint32_t avgValue;
+
+    uint16_t changeBRCnt;
+    uint32_t chageBRAvg;
+
+    uint16_t upBitrateCnt;
+    uint32_t upBitrateSum;
+
+    uint16_t dnBitrateCnt;
+    uint32_t dnBitrateSum;
+
+
+    bool updateFramneInfo;
+    uint32_t samples_per_frame; //equal to block size
+    savi_circ_buf input_cbuf;
+    int32_t  out_nbytes;    //output size per frame;
+    uint32_t host_mtu_size;
+    uint32_t frame_per_packet;
+    uint32_t encode_interval;
+
+    //kaiden:20210311:autobirate:malloc maximum nbyte size
+    bool new_packet_flag;
+
+} llac_para_t;
+
+typedef struct _lhdc_para_t {
+
+    FFT_BLOCK * fft_blk;
+    int32_t  sample_rate;
+    int32_t  bits_per_sample;
+
+    LHDCBT_QUALITY_T qualityStatus;      //0xff == Auto bitrate
+    LHDCBT_QUALITY_T limitBitRateStatus;
+    int32_t lastBitrate;     //Record lastbitrate for auto bitrate adjust.
+    int32_t version;
+
+    uint16_t avg_cnt;
+    uint32_t avgValue;
+
+    uint16_t changeBRCnt;
+    uint32_t chageBRAvg;
+
+    uint16_t upBitrateCnt;
+    uint32_t upBitrateSum;
+
+    uint16_t dnBitrateCnt;
+    uint32_t dnBitrateSum;
+
+    bool updateFramneInfo;
+    uint32_t block_size;
+    uint32_t target_mtu_size;
+    uint32_t host_mtu_size;
+    uint32_t frame_per_packet;
+    uint32_t encode_interval;
+    savi_circ_buf input_cbuf;
+    uint32_t queue_frame_cnt;
+
+    bool hasMinBitrateLimit;
+} lhdc_para_t;
+
+//L_20210408 .start
+typedef struct _lhdc_ar_para_t {
+	int sample_rate;
+	int bits_per_sample;
+	int channels;
+	unsigned int samples_per_frame;
+	unsigned int    app_ar_enabled;
+        unsigned long   ulNumBytes;
+        unsigned char*  pucARParams;
+        unsigned int	uiARParamsBytes;//Ask AR how many mem size
+        unsigned char*  pucLhdcArMem;
+        unsigned int	uiLhdcArMemBytes;//Ask AR how many mem size
+} lhdc_ar_para_t;
+//L_20210408 .end
+
+typedef struct _lhdc_filter_t{
+    uint8_t * priv; //save alloc mem point
+    lhdc_filter_type_t type; //don't del..
+} lhdc_filter_t;
+
+
+typedef union _enc_t {
+        lhdc_para_t *lhdc;
+        llac_para_t *llac;
+} enc_t;
+typedef struct _lhdc_control_block_t {
+
+    lhdc_enc_type_t enc_type;       //LLAC or LHDC
+    int err;
+
+    enc_t enc;
+    lhdc_ar_para_t * ar_filter; //AR Param
+
+} lhdc_cb_t;
+
+
+inline static int32_t TARGET_BITRATE_LIMIT(int32_t X, int32_t Y){
+     //((X < Y) ? (Y) : (X))
+
+     if (X < Y)
+        return Y;
+    else
+        return X;
+
+}
+
+typedef void * HANDLE_LHDC_BT;
+
+extern llac_para_t * llac_encoder_new();
+extern void llac_encoder_free(llac_para_t * llac);
+extern int32_t llac_encoder_get_frame_len(llac_para_t  *  handle);
+extern int32_t llac_encoder_get_target_bitrate(llac_para_t  *  handle);
+extern int32_t llac_encoder_init(llac_para_t  *  handle, uint32_t sample_rate, uint32_t bits_per_sample, uint32_t bitrate_inx, uint32_t mtu_size, uint32_t encode_interval);
+
+extern lhdc_para_t * lhdc_encoder_new(int version);
+extern void lhdc_encoder_free(lhdc_para_t * handle);
+extern int32_t lhdc_encoder_get_frame_len(lhdc_para_t * handle);
+extern int32_t lhdc_encoder_get_target_bitrate(lhdc_para_t * handle);
+extern bool lhdc_get_ext_func_state(lhdc_enc_type_t type, void *h, lhdc_ext_func_t ext_type);
+extern int32_t lhdc_encoder_init(lhdc_para_t * handle,int32_t sampling_freq, uint32_t bitPerSample, uint32_t bitrate_inx, uint32_t dualChannel, uint32_t need_padding, uint32_t mtu, uint32_t interval);
+
+
+extern void ar_process_free(lhdc_ar_para_t * handle);
+extern lhdc_ar_para_t * ar_process_new(void);
+extern int ar_process_init(lhdc_ar_para_t * handle, int sample_rate, int bits_per_sample, int channels, unsigned int samples_per_frame);
+extern int ar_set_gyro_pos(lhdc_ar_para_t * handle, int world_coordinate_x, int world_coordinate_y, int world_coordinate_z);
+extern int ar_set_cfg(lhdc_ar_para_t * handle,int *Pos, float *Gain, unsigned int app_ar_enabled);
+extern int ar_get_cfg(lhdc_ar_para_t * handle,int *Pos, float *Gain);
+
+//Common function
+
+
+extern void lhdc_util_reset_up_bitrate(lhdc_enc_type_t type, void * h);
+extern void lhdc_util_reset_down_bitrate(lhdc_enc_type_t type, void * h);
+extern bool lhdc_util_get_ext_func_state(lhdc_enc_type_t type, void *h, lhdc_ext_func_t ext_type);
+extern int32_t lhdc_util_encv4_process(HANDLE_LHDC_BT handle, void* p_pcm, unsigned char* out_put, uint32_t * written, uint32_t * out_fraems);
+extern uint32_t lhdc_util_get_bitrate(uint32_t index);
+extern uint8_t * lhdc_util_get_buffer(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif //End of __LHDC_API_H__
diff --git a/external/liblhdc/include/lhdc_cfg.h b/external/liblhdc/include/lhdc_cfg.h
new file mode 100755
index 00000000..29ce0200
--- /dev/null
+++ b/external/liblhdc/include/lhdc_cfg.h
@@ -0,0 +1,34 @@
+#ifndef __LHDC_CONFIG_H__
+#define __LHDC_CONFIG_H__
+
+//
+// Config for LHDC Encode
+//
+
+
+//#define ENC_LPF_FIXED_POINT			1
+
+
+// 20190402 .start
+//#define ENC_LPC_V_MAX_ORDER			1
+//#define ENC_LPC_V_USE_32BIT			1
+// 20190402 .end
+
+
+
+//
+// Config for LHDC Decode
+//
+
+//#define DEC_LPF_FIXED_POINT			1
+
+
+
+// 20190402 .start
+//#define DEC_LPC_V_MAX_ORDER			1
+//#define DEC_ADSP_LPC_V_USE_ADSP		1
+//#define DEC_ADSP_LPC_V_MAX_ORDER		1
+// 20190402 .end
+
+
+#endif
diff --git a/external/liblhdc/include/lhdc_enc_config.h b/external/liblhdc/include/lhdc_enc_config.h
new file mode 100755
index 00000000..7e64b88e
--- /dev/null
+++ b/external/liblhdc/include/lhdc_enc_config.h
@@ -0,0 +1,7 @@
+#ifndef	_LHDC_ENC_CONFIG_H_
+#define	_LHDC_ENC_CONFIG_H_
+
+
+#define LHDC_ENC_SINK_BUF_LEN       ( 10 * 1024)
+
+#endif	/* _LHDC_ENC_CONFIG_H_ */
diff --git a/external/liblhdc/include/lhdc_process.h b/external/liblhdc/include/lhdc_process.h
new file mode 100755
index 00000000..4a1bf421
--- /dev/null
+++ b/external/liblhdc/include/lhdc_process.h
@@ -0,0 +1,106 @@
+#ifndef _PROCESS_BLOCK_H_
+#define _PROCESS_BLOCK_H_
+#include <stdbool.h>
+
+
+struct FFT_block_s;
+typedef struct FFT_block_s FFT_BLOCK;
+
+typedef enum {
+	EXT_FUNC_AR,
+	EXT_FUNC_LARC,
+	EXT_FUNC_EXT_FLG,
+	EXT_FUNC_JAS,
+	EXT_FUNC_META
+} lhdc_ext_func_t;
+
+
+typedef enum _lhdc_error {
+    LHDC_ST_OK,
+    LHDC_ST_ERR,
+    LHDC_ST_MAX
+} LHDC_STATE;
+
+
+int LossyEncoderLoadQualitySetting(FFT_BLOCK *fb, char *file_name);
+
+/**
+ * Allocate new LHDC control block.
+ */
+//Adjust by John
+//FFT_BLOCK *LossyEncoderNew(void);
+FFT_BLOCK *LossyEncoderNew(int32_t version);
+
+/**
+ * Destroy LHDC control block.
+ */
+int LossyEncoderDelete(FFT_BLOCK *fb);
+
+/**
+ * Initial LHDC encoder.
+ * Input :
+ *  fb: LHDC control block.
+ *  sample_rate : The sampling rate setting value as you wanted. (Only support 44.1Khz/48Khz/96KHz)
+ *  channels    : Fixed to 2 channel.
+ *  block_size  : Fixed to 512.
+ *  sink_buf_len: Fixed to 10 * 1024.
+ *  target_byte_rate : The target byte rate.(eg. 400k bit per sec = 50k byte per sec, Only support 400kbps, 500kbps, 560kbps, 900kbps)
+ *  fast_mode   : Always fixed to 0.
+ *  split       : Fixed to 0.
+ *  need_padding: Fixed to 0.
+ *  process_size: Fixed to 256.
+ *
+ * Return value :
+ *  LHDC_ST_ERR : Parameters of init have error.
+ *  LHDC_ST_OK : LHDC encoder initial OK.
+ */
+//void LossyEncoderInit(FFT_BLOCK *fb, int sample_rate, int bits_per_sample, int channels, int block_size, int sink_buf_len, int target_byte_rate, int fast_mode, int one_frame_per_channel, int need_min_byte_rate, int process_size, int target_mtu_byte, int no_btr_limit_frame_cnt);
+void LossyEncoderInit(FFT_BLOCK *fb, int sample_rate, int bits_per_sample, int channels, int block_size, int sink_buf_len, int target_byte_rate, int fast_mode, int one_frame_per_channel, int need_min_byte_rate, int process_size, int target_mtu_byte, int no_btr_limit_frame_cnt, int min_bits_reserved, int lhdc_ver);
+
+
+/**
+ * LHDC encode function
+ *  fb: LHDC control block.
+ *  wav : The PCM data. please input non-planer and compact PCM data.
+ *        (eg. The input stream format is 96KHz/24bits stereo and the LHDC request 512 samples for each frame.
+ *         So the PCM data length should be 512 * 2 * (24/8) = 3072 bytes. The data order should be L/R, L/R, L/R....).
+ *  ns  : The number of samples, not PCM data byte length. The LHDC encoder only supports 512.
+ *  final   : Fixed to 0.
+ *  out : Output buffer pointer.
+ *  out_len : The output buffer size to protect overwrite.
+ *
+ *  Return value :
+ *      The return value should be the encoded size, otherwise an error occurs (less than or equal to 0)
+ *
+ */
+int LossyEncoderProcessWav(FFT_BLOCK *fb, unsigned char *wav, int ns, int final, unsigned char *out, int out_len);
+
+/**
+ * LHDC encode function
+ *  fb: LHDC control block.
+ *  pcm0 : The left channel PCM data.
+ *  pcm1 : The right channel PCM data.
+ *  ns  : The number of samples, not PCM data byte length. The LHDC encoder only supports 512.
+ *  final   : Fixed to 0.
+ *  out : Output buffer pointer.
+ *  out_len : The output buffer size to protect overwrite.
+ *
+ *  Return value :
+ *      The return value should be the encoded size, otherwise an error occurs (less than or equal to 0)
+ *
+ */
+int LossyEncoderProcessPCM(FFT_BLOCK *fb, int *pcm0, int *pcm1, int ns, int final, unsigned char *out, int out_len);
+
+/**
+ * To change target byte rate at runtime.
+ * (Only support 400kbps, 500kbps, 560kbps, 900kbps)
+ */
+void LossyEncoderSetTargetByteRate(FFT_BLOCK *fb, int target_byte_rate);
+void LossyEncoderResetAlignmentBuf(FFT_BLOCK *fb);
+void LossyEncoderUpdateFrameSize(FFT_BLOCK *fb, int target_mtu_byte, int target_byte_rate);//For auto bit rate
+
+void LhdcExtFuncArEnable(FFT_BLOCK *fb, int enable_ar);
+void LhdcExtFuncJasEnable(FFT_BLOCK *fb, int enable_Jas);
+void LhdcExtFuncMetaEnable(FFT_BLOCK *fb, int enable_meta, unsigned char *pmeta_data, int meta_data_len, int conti_frame_cnt);
+bool LhdcGetExtFuncState(FFT_BLOCK *fb, lhdc_ext_func_t ext_func);
+#endif // _PROCESS_BLOCK_H_
diff --git a/external/liblhdc/include/lhdcv2_process.h b/external/liblhdc/include/lhdcv2_process.h
new file mode 100755
index 00000000..8d13c3ef
--- /dev/null
+++ b/external/liblhdc/include/lhdcv2_process.h
@@ -0,0 +1,91 @@
+#ifndef _PROCESSV2_BLOCK_H_
+#define _PROCESSV2_BLOCK_H_
+
+
+#ifndef __FFT_BLOCK__
+#define __FFT_BLOCK__
+typedef void *FFT_BLOCK;
+#endif //End of __FFT_BLOCK__
+
+
+#ifndef __LHDC_STATUS__
+#define __LHDC_STATUS__
+typedef enum _lhdc_error {
+    LHDC_ST_OK,
+    LHDC_ST_ERR,
+    LHDC_ST_MAX
+} LHDC_STATE;
+#endif //End of __LHDC_STATUS__
+
+
+//int LossyEncoderLoadQualitySetting(FFT_BLOCK *fb, char *file_name);
+
+/**
+ * Allocate new LHDC control block.
+ */
+FFT_BLOCK LossyEncoderNewV2(void);
+
+/**
+ * Destroy LHDC control block.
+ */
+int LossyEncoderDeleteV2(FFT_BLOCK fb);
+
+/**
+ * Initial LHDC encoder.
+ * Input :
+ *  fb: LHDC control block.
+ *  sample_rate : The sampling rate setting value as you wanted. (Only support 44.1Khz/48Khz/96KHz)
+ *  channels    : Fixed to 2 channel.
+ *  block_size  : Fixed to 512.
+ *  sink_buf_len: Fixed to 10 * 1024.
+ *  target_byte_rate : The target byte rate.(eg. 400k bit per sec = 50k byte per sec, Only support 400kbps, 500kbps, 560kbps, 900kbps)
+ *  fast_mode   : Always fixed to 0.
+ *  split       : Fixed to 0.
+ *  need_padding: Fixed to 0.
+ *  process_size: Fixed to 256.
+ *
+ * Return value :
+ *  LHDC_ST_ERR : Parameters of init have error.
+ *  LHDC_ST_OK : LHDC encoder initial OK.
+ */
+LHDC_STATE LossyEncoderInitV2(FFT_BLOCK fb, int sample_rate, int bits_per_sample, int channels, int block_size, int sink_buf_len, int target_byte_rate, int fast_mode, int one_frame_per_channel, int need_min_byte_rate, int process_size);
+
+/**
+ * LHDC encode function
+ *  fb: LHDC control block.
+ *  wav : The PCM data. please input non-planer and compact PCM data.
+ *        (eg. The input stream format is 96KHz/24bits stereo and the LHDC request 512 samples for each frame.
+ *         So the PCM data length should be 512 * 2 * (24/8) = 3072 bytes. The data order should be L/R, L/R, L/R....).
+ *  ns  : The number of samples, not PCM data byte length. The LHDC encoder only supports 512.
+ *  final   : Fixed to 0.
+ *  out : Output buffer pointer.
+ *  out_len : The output buffer size to protect overwrite.
+ *
+ *  Return value :
+ *      The return value should be the encoded size, otherwise an error occurs (less than or equal to 0)
+ *
+ */
+int LossyEncoderProcessWavV2(FFT_BLOCK fb, unsigned char *wav, int ns, int final, unsigned char *out, int out_len);
+
+/**
+ * LHDC encode function
+ *  fb: LHDC control block.
+ *  pcm0 : The left channel PCM data.
+ *  pcm1 : The right channel PCM data.
+ *  ns  : The number of samples, not PCM data byte length. The LHDC encoder only supports 512.
+ *  final   : Fixed to 0.
+ *  out : Output buffer pointer.
+ *  out_len : The output buffer size to protect overwrite.
+ *
+ *  Return value :
+ *      The return value should be the encoded size, otherwise an error occurs (less than or equal to 0)
+ *
+ */
+int LossyEncoderProcessPCMV2(FFT_BLOCK fb, int *pcm0, int *pcm1, int ns, int final, unsigned char *out, int out_len);
+
+/**
+ * To change target byte rate at runtime.
+ * (Only support 400kbps, 500kbps, 560kbps, 900kbps)
+ */
+void LossyEncoderSetTargetByteRateV2(FFT_BLOCK fb, int target_byte_rate);
+#endif // _PROCESSV2_BLOCK_H_
diff --git a/external/liblhdc/include/lhdcv3_process.h b/external/liblhdc/include/lhdcv3_process.h
new file mode 100755
index 00000000..f1c9d3e7
--- /dev/null
+++ b/external/liblhdc/include/lhdcv3_process.h
@@ -0,0 +1,92 @@
+#ifndef _PROCESSV3_BLOCK_H_
+#define _PROCESSV3_BLOCK_H_
+
+
+#ifndef __FFT_BLOCK__
+#define __FFT_BLOCK__
+typedef void *FFT_BLOCK;
+#endif //End of __FFT_BLOCK__
+
+
+#ifndef __LHDC_STATUS__
+#define __LHDC_STATUS__
+typedef enum _lhdc_error {
+    LHDC_ST_OK,
+    LHDC_ST_ERR,
+    LHDC_ST_MAX
+} LHDC_STATE;
+#endif //End of __LHDC_STATUS__
+
+
+//int LossyEncoderLoadQualitySetting(FFT_BLOCK *fb, char *file_name);
+
+/**
+ * Allocate new LHDC control block.
+ */
+FFT_BLOCK LossyEncoderNewV3(void);
+
+/**
+ * Destroy LHDC control block.
+ */
+int LossyEncoderDeleteV3(FFT_BLOCK fb);
+
+/**
+ * Initial LHDC encoder.
+ * Input :
+ *  fb: LHDC control block.
+ *  sample_rate : The sampling rate setting value as you wanted. (Only support 44.1Khz/48Khz/96KHz)
+ *  channels    : Fixed to 2 channel.
+ *  block_size  : Fixed to 256.
+ *  sink_buf_len: Fixed to 10 * 1024.
+ *  target_byte_rate : The target byte rate.(eg. 400k bit per sec = 50k byte per sec, Only support 400kbps, 500kbps, 560kbps, 900kbps)
+ *  fast_mode   : Always fixed to 0.
+ *  split       : Fixed to 0.
+ *  need_padding: Fixed to 0.
+ *  process_size: Fixed to 256.
+ *
+ * Return value :
+ *  LHDC_ST_ERR : Parameters of init have error.
+ *  LHDC_ST_OK : LHDC encoder initial OK.
+ */
+void LossyEncoderInitV3(FFT_BLOCK fb, int sample_rate, int bits_per_sample, int channels, int block_size, int sink_buf_len, int target_byte_rate, int fast_mode, int one_frame_per_channel, int need_min_byte_rate, int process_size, int target_mtu_byte, int no_btr_limit_frame_cnt);
+
+
+/**
+ * LHDC encode function
+ *  fb: LHDC control block.
+ *  wav : The PCM data. please input non-planer and compact PCM data.
+ *        (eg. The input stream format is 96KHz/24bits stereo and the LHDC request 512 samples for each frame.
+ *         So the PCM data length should be 512 * 2 * (24/8) = 3072 bytes. The data order should be L/R, L/R, L/R....).
+ *  ns  : The number of samples, not PCM data byte length. The LHDC encoder only supports 512.
+ *  final   : Fixed to 0.
+ *  out : Output buffer pointer.
+ *  out_len : The output buffer size to protect overwrite.
+ *
+ *  Return value :
+ *      The return value should be the encoded size, otherwise an error occurs (less than or equal to 0)
+ *
+ */
+int LossyEncoderProcessWavV3(FFT_BLOCK fb, unsigned char *wav, int ns, int final, unsigned char *out, int out_len);
+
+/**
+ * LHDC encode function
+ *  fb: LHDC control block.
+ *  pcm0 : The left channel PCM data.
+ *  pcm1 : The right channel PCM data.
+ *  ns  : The number of samples, not PCM data byte length. The LHDC encoder only supports 512.
+ *  final   : Fixed to 0.
+ *  out : Output buffer pointer.
+ *  out_len : The output buffer size to protect overwrite.
+ *
+ *  Return value :
+ *      The return value should be the encoded size, otherwise an error occurs (less than or equal to 0)
+ *
+ */
+int LossyEncoderProcessPCMV3(FFT_BLOCK fb, int *pcm0, int *pcm1, int ns, int final, unsigned char *out, int out_len);
+
+/**
+ * To change target byte rate at runtime.
+ * (Only support 400kbps, 500kbps, 560kbps, 900kbps)
+ */
+void LossyEncoderSetTargetByteRateV3(FFT_BLOCK fb, int target_byte_rate);
+#endif // _PROCESSV3_BLOCK_H_
diff --git a/external/liblhdc/include/llac_enc_api.h b/external/liblhdc/include/llac_enc_api.h
new file mode 100755
index 00000000..3004bc01
--- /dev/null
+++ b/external/liblhdc/include/llac_enc_api.h
@@ -0,0 +1,128 @@
+/***********************************************************************
+*                               LLAC encoder                           *
+*                                                                      *
+*                                                                      *
+************************************************************************/
+
+#ifndef LLAC_ENC_API_H
+#define LLAC_ENC_API_H
+
+/*
+ * LLAC: 
+ * API Usage
+ *
+ * STEP1.   call llac_enc_mem_alloc() once to allocate the memory
+ * STEP2_0. call llac_enc_set_extra_func() before llac_enc_initial()
+            to enable or disable extra function if needed (for AR, LARC and EXTH ,default is disable)
+ * STEP2.   call llac_enc_initial() once to initialize encoder
+ * STEP3_0. call llac_enc_set_bitrate() before llac_enc_process() 
+ *          to set new bitrate if needed (for autobitrate usage)
+ * STEP3.   call llac_enc_process() in a while loop to encode each frame
+ * STEP4.   call llac_enc_mem_free() once to release the allocated memory 
+ *        when the encode process are done 
+ */
+
+
+
+/*
+ * LLAC: 
+ *      LLAC_MAX_CHANNELS:   Max number of channels
+ *      LLAC_MAX_SAMPLES:    Max number of samples per channel
+ *      LLAC_MAX_BYTES:      Max size of encoded output data in bytess
+ */
+#define LLAC_MAX_CHANNELS 2
+#define LLAC_MAX_SAMPLES 480
+#define LLAC_MAX_BYTES 600
+
+
+/**
+ * LLAC:
+ * llac_enc_mem_alloc - allocate all the memory needed for LLAC encoder
+ * Return: the address of the allocated memory
+ */
+unsigned char* llac_enc_mem_alloc(void);
+
+
+/**
+ * LLAC:
+ * llac_enc_set_extra_func - set extra function enable/disable (for AR, LARC and EXTH)
+ * @func_index: can only be EXTRA_FUNC_AR, EXTRA_FUNC_LARC or EXTRA_FUNC_EXTH
+ * @func_enable: can only be EXTRA_FUNC_DISABLE or EXTRA_FUNC_ENABLE
+ * @llac_enc_mem_addr: the address returned by llac_enc_mem_alloc()
+ */
+#define EXTRA_FUNC_AR 0
+#define EXTRA_FUNC_LARC 1
+#define EXTRA_FUNC_EXTH 2
+
+#define EXTRA_FUNC_DISABLE 0
+#define EXTRA_FUNC_ENABLE 1
+
+void llac_enc_set_extra_func(unsigned char func_index,
+    unsigned char func_enable,
+    unsigned char* llac_enc_mem_addr);
+
+
+bool llac_enc_get_extra_func(unsigned char func_index,
+                             unsigned char* llac_enc_mem_addr);
+
+/**
+ * LLAC:
+ * llac_enc_initial - do encoder initialization
+ * @sampleRate: sample rate of input file
+ * @nChannels: channel number of input file
+ * @bps_in: bit per sample of input file 
+ * @bps_out: bit per sample of output file
+ * @frame_ms: frame duration in millisecond
+ * @target_bitrate: targeted bitrate
+ * @nBytes: size of encoded output data in bytes
+ * @nSamples: number of sample per channel
+ * @real_bitrate: the actual bitrate that the encoder is gonna use
+ * @llac_enc_mem_addr: the address returned by llac_enc_mem_alloc()
+ */
+void llac_enc_initial(unsigned int sampleRate,
+                          short nChannels,
+                          short bps_in,
+                          short bps_out,
+                          float frame_ms,
+                          int target_bitrate,
+                          int* nBytes,
+                          unsigned int* nSamples,
+                          int* real_bitrate,
+                          unsigned char* llac_enc_mem_addr);
+
+
+/**
+ * LLAC:
+ * llac_enc_set_bitrate - set new bitrate (for autobitrate usage)
+ * @target_bitrate: targeted bitrate
+ * @nBytes: size of encoded output data in bytes
+ * @real_bitrate: the actual bitrate that the encoder is gonna use
+ * @llac_enc_mem_addr: the address returned by llac_enc_mem_alloc()
+ */
+void llac_enc_set_bitrate(int target_bitrate,
+    int* nBytes,
+    int* real_bitrate,
+    unsigned char* llac_enc_mem_addr);
+
+
+/**
+ * LLAC:
+ * llac_enc_process - do encode process for one frame
+ * @input: input buffer
+ * @output: output buffer
+ * @llac_enc_mem_addr: the address returned by llac_enc_mem_alloc()
+ * Return:  size of encoded output data in bytes
+ */
+int llac_enc_process(int* input,
+                         unsigned char* output,
+                         unsigned char* llac_enc_mem_addr);
+
+
+/**
+ * LLAC:
+ * llac_enc_mem_free - release all the memory needed for LLAC encoder
+ * @llac_enc_mem_addr: the address returned by llac_enc_mem_alloc()
+ */
+void llac_enc_mem_free(unsigned char* llac_enc_mem_addr);
+
+#endif /* LLAC_ENC_API_H */
\ No newline at end of file
diff --git a/external/liblhdc/libs/arm64-v8a/liblhdc.so b/external/liblhdc/libs/arm64-v8a/liblhdc.so
new file mode 100755
index 00000000..cffad244
Binary files /dev/null and b/external/liblhdc/libs/arm64-v8a/liblhdc.so differ
diff --git a/external/liblhdc/libs/armeabi-v7a/liblhdc.so b/external/liblhdc/libs/armeabi-v7a/liblhdc.so
new file mode 100755
index 00000000..9cc779cf
Binary files /dev/null and b/external/liblhdc/libs/armeabi-v7a/liblhdc.so differ
diff --git a/external/liblhdc/release_note b/external/liblhdc/release_note
new file mode 100755
index 00000000..e8bde81d
--- /dev/null
+++ b/external/liblhdc/release_note
@@ -0,0 +1,53 @@
+Release Note.
+=========================================================
+2022/07/20
+1. Upgrade LHDCV4 encoder version to V4.0.6
+
+2022/04/18
+1. Upgrade LHDCV4 encoder version to V4.0.4
+
+2021/11/15
+1. Add to print LHDC version and build time.
+2. Fix wrong AR effect.
+3. Fix when running LLAC, BT may crash after toggling AR UI on/off.
+
+2021/7/21
+Modify the calculation method to correct the number of frames per packet.
+
+2021/7/16
+Add AR version log on create.
+
+2021/7/6
+Add AR v1.1a.14 function.
+
+2021/7/5
+Add AR v1.1a.13 function.
+Support LHDCV4 AR on/off from app
+
+2021/7/1
+Add AR switch form app.
+
+2021/6/29
+Add AR v1.1a function.
+
+2021/3/12
+Update LHDC algorithm.
+
+2021/2/26
+Remove GPL license module.
+
+2020/7/10
+Fixed issue: The size of the encoded frame exceeded expectations.
+
+2020/5/28
+Updating the core of encoder to improve performance.
+
+2020/4/30
+1. Modify the frame size calculation method and refer to the encoding interval time so that the output size of 48KHz/24bits & LL enabled is lower than the packet size of 2DH3.
+
+2020/4/14
+1. Add new function to evaluate frame size and number of frames in a packet.
+2. Fix frame size evaluate not exactly.
+
+2020/3/9
+LHDC encoder library for android 10 r2 on MTK platform.
diff --git a/external/liblhdc/src/lhdcBT_enc.c b/external/liblhdc/src/lhdcBT_enc.c
new file mode 100755
index 00000000..5c4e15a3
--- /dev/null
+++ b/external/liblhdc/src/lhdcBT_enc.c
@@ -0,0 +1,1552 @@
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include "lhdcBT.h"
+#include "lhdc_process.h"
+#include "lhdc_cfg.h"
+#include "cirbuf.h"
+#include "llac_enc_api.h"
+
+
+
+#define LOG_NDEBUG 0
+#define LOG_TAG "lhdcBT_enc"
+#include <cutils/log.h>
+#define max(a,b) ((a) > (b) ? (a) : (b))
+
+#define UP_RATE_TIME_CNT         3000  //Time about UP_RATE_TIME_CNT * 20ms
+#define DOWN_RATE_TIME_CNT       4  //Time about .... ex. DOWN_RATE_TIME_CNT * 20ms
+#define QUEUE_LENGTH_THRESHOLD   4
+
+#define LHDC_BITRATE_ELEMENTS_SIZE   (sizeof(auto_bitrate_adjust_table_lhdc)/sizeof(int))
+#define LLAC_BITRATE_ELEMENTS_SIZE   (sizeof(auto_bitrate_adjust_table_llac)/sizeof(int))
+#define LHDC_ABR_DEFAULT_BITRATE     (400)
+#define LLAC_ABR_DEFAULT_BITRATE     (400)
+
+#define AR_ALWAYS_ONx  1
+
+
+static const char * rate_to_string(LHDCBT_QUALITY_T q){
+    switch (q) {
+        case LHDCBT_QUALITY_LOW0:
+        return "LHDCBT_QUALITY_LOW0";
+        case LHDCBT_QUALITY_LOW1:
+        return "LHDCBT_QUALITY_LOW1";
+        case LHDCBT_QUALITY_LOW2:
+        return "LHDCBT_QUALITY_LOW2";
+        case LHDCBT_QUALITY_LOW3:
+        return "LHDCBT_QUALITY_LOW3";
+        case LHDCBT_QUALITY_LOW4:
+        return "LHDCBT_QUALITY_LOW4";
+        case LHDCBT_QUALITY_LOW:
+        return "LHDCBT_QUALITY_LOW";
+        case LHDCBT_QUALITY_MID:
+        return "LHDCBT_QUALITY_MID";
+        case LHDCBT_QUALITY_HIGH:
+        return "LHDCBT_QUALITY_HIGH";
+        case LHDCBT_QUALITY_AUTO:
+        return "LHDCBT_QUALITY_AUTO";
+        default:
+            ALOGE("%s: Incorrect quality(%d)",  __func__, q);
+        return "UNKNOW_QUALITY";
+    }
+}
+
+
+static int auto_bitrate_adjust_table_lhdc[] = {320, 350, 380, 440, 580, 600};
+static int auto_bitrate_adjust_table_llac[] = {136, 160, 192, 240, 320, 320};//7, 6, 5, 4, 3, 2
+
+static int bitrateFromIndex(lhdc_enc_type_t type, void * h, int index){
+
+    int limit = 0;
+    int result = 0;
+
+    if (type == ENC_TYPE_LHDC) {
+        lhdc_para_t * lhdc = (lhdc_para_t * )h;
+        limit = lhdc_util_get_bitrate((uint32_t)lhdc->limitBitRateStatus);
+        result = auto_bitrate_adjust_table_lhdc[index];
+    }else if (type == ENC_TYPE_LLAC) {
+        llac_para_t * llac = (llac_para_t * )h;
+        limit = lhdc_util_get_bitrate((uint32_t)llac->limitBitRateStatus);
+        result = auto_bitrate_adjust_table_llac[index];
+    }
+
+    return result >= limit ? limit : result;
+
+}
+
+static int bitrateIndexFrom(lhdc_enc_type_t type, size_t queueLength) {
+
+    uint32_t element_size = (type == ENC_TYPE_LHDC) ? LHDC_BITRATE_ELEMENTS_SIZE : LLAC_BITRATE_ELEMENTS_SIZE;
+
+    int newBitrateInx = 0;
+    if (queueLength < QUEUE_LENGTH_THRESHOLD) {
+        float queuePercenty = (1 - ((float)queueLength / QUEUE_LENGTH_THRESHOLD)) * (element_size - 1);
+        newBitrateInx = (int)queuePercenty;
+    }
+    return newBitrateInx;
+}
+
+//lhdcBT encHandle = NULL;
+static int indexOfBitrate(lhdc_enc_type_t type, void * h, int bitrate){
+    uint32_t element_size = type == ENC_TYPE_LHDC ? LHDC_BITRATE_ELEMENTS_SIZE : LLAC_BITRATE_ELEMENTS_SIZE;
+    for (size_t i = 0; i < element_size; i++) {
+        if (bitrateFromIndex(type, h, i) >= bitrate) {
+            return i;
+        }
+    }
+    return 0;
+}
+/*
+******************************************************************
+ LHDC functions group
+******************************************************************
+*/
+
+static void lhdc_encoder_set_max_bitrate(lhdc_para_t * handle, int max_rate_index) {
+    if (handle == NULL || max_rate_index == LHDCBT_QUALITY_AUTO){
+        ALOGE("%s: Error LHDC instance(%p), max rate(%d)",  __func__, handle, max_rate_index);
+        return;
+    }
+    if (max_rate_index != (int)handle->limitBitRateStatus){
+
+        handle->limitBitRateStatus = (LHDCBT_QUALITY_T)max_rate_index;
+
+        if ((uint32_t)handle->limitBitRateStatus != (uint32_t)handle->qualityStatus ){
+            if (handle->qualityStatus != LHDCBT_QUALITY_AUTO) {
+                handle->qualityStatus = handle->limitBitRateStatus;
+            }
+
+            int newRate = TARGET_BITRATE_LIMIT(lhdc_util_get_bitrate(handle->limitBitRateStatus), handle->hasMinBitrateLimit ? 320 : 128);
+
+            if (handle->lastBitrate >= newRate) {
+                handle->lastBitrate = newRate;
+
+                if (handle->version >= 2) {
+                    handle->updateFramneInfo = true;
+                }
+                LossyEncoderSetTargetByteRate(handle->fft_blk, (handle->lastBitrate * 1000) / 8);
+                ALOGD("%s: Update Max target bitrate(%s)",  __func__, rate_to_string(handle->limitBitRateStatus));
+            }
+        }
+    }
+}
+
+
+static int lhdc_encoder_encode(lhdc_para_t * handle, void* p_pcm, unsigned char* p_stream){
+    if (handle) {
+        if (p_pcm == NULL || p_stream == NULL) {
+            ALOGE("%s: Buffer error! source(%p), output(%p)",  __func__, p_pcm, p_stream);
+            return 0;
+        }
+        int bytesSizePerBlock = 0;
+        int encodedSize = -1;
+        uint32_t block_size = handle->block_size;
+        bytesSizePerBlock = (block_size * (handle->bits_per_sample >> 3)) << 1;
+        encodedSize = LossyEncoderProcessWav(handle->fft_blk, (unsigned char *)p_pcm, block_size, 0, p_stream, bytesSizePerBlock);
+        return encodedSize;
+    }
+    ALOGE("%s: Handle error!(%p)",  __func__, handle);
+    return 0;
+}
+
+
+
+
+static int lhdc_encoder_set_bitrate(lhdc_para_t * handle, int bitrate_inx){
+    if (handle) {
+
+        if (bitrate_inx != (int)handle->qualityStatus) {
+
+            if (bitrate_inx != LHDCBT_QUALITY_AUTO) {
+                handle->lastBitrate = TARGET_BITRATE_LIMIT(lhdc_util_get_bitrate(bitrate_inx), handle->hasMinBitrateLimit ? 320 : 128);
+            }else{
+                handle->lastBitrate = LHDC_ABR_DEFAULT_BITRATE;
+                lhdc_util_reset_down_bitrate(ENC_TYPE_LHDC, handle);
+                lhdc_util_reset_up_bitrate(ENC_TYPE_LHDC, handle);
+            }
+
+            handle->qualityStatus = bitrate_inx;
+
+            if ((uint32_t)handle->qualityStatus > (uint32_t)handle->limitBitRateStatus &&
+                handle->qualityStatus != LHDCBT_QUALITY_AUTO) {
+                handle->lastBitrate = TARGET_BITRATE_LIMIT(lhdc_util_get_bitrate(handle->limitBitRateStatus), handle->hasMinBitrateLimit ? 320 : 128);
+                handle->qualityStatus = handle->limitBitRateStatus;
+            }
+        }
+        if (handle->version >= 2) {
+          handle->updateFramneInfo = true;
+        }
+        LossyEncoderSetTargetByteRate(handle->fft_blk, (handle->lastBitrate * 1000) / 8);
+        ALOGD("%s: Update target bitrate(%s)",  __func__, rate_to_string(handle->qualityStatus));
+        return 0;
+    }
+    ALOGE("%s: Handle error!(%p)",  __func__, handle);
+    return -1;
+}
+
+
+
+static int lhdc_encoder_adjust_bitrate(lhdc_para_t * handle, size_t queueLen) {
+    if (handle != NULL && handle->qualityStatus == LHDCBT_QUALITY_AUTO) {
+        if (handle->dnBitrateCnt >= DOWN_RATE_TIME_CNT) {
+            /* code */
+            size_t queueLength = handle->dnBitrateSum / handle->dnBitrateCnt;
+
+            handle->dnBitrateSum = 0;
+            handle->dnBitrateCnt = 0;
+            int newBitrateInx = bitrateIndexFrom(ENC_TYPE_LHDC, queueLength);
+
+            if (TARGET_BITRATE_LIMIT(bitrateFromIndex(ENC_TYPE_LHDC, handle, newBitrateInx), handle->hasMinBitrateLimit ? 320 : 128) < handle->lastBitrate) {
+                handle->lastBitrate = TARGET_BITRATE_LIMIT(bitrateFromIndex(ENC_TYPE_LHDC, handle, newBitrateInx), handle->hasMinBitrateLimit ? 320 : 128);
+                if (handle->version >= 2) {
+                  handle->updateFramneInfo = true;
+                }
+                LossyEncoderSetTargetByteRate(handle->fft_blk, (handle->lastBitrate * 1000) / 8);
+                ALOGD("%s:[Down BiTrAtE] Update bitrate(%d), queue length(%zu)",  __func__, handle->lastBitrate, queueLength);
+                lhdc_util_reset_up_bitrate(ENC_TYPE_LHDC, handle);
+            }else{
+              ALOGW("%s: Down bitrate condition fails, new rate:%d, current rate:%d",  __func__,
+                                    TARGET_BITRATE_LIMIT(bitrateFromIndex(ENC_TYPE_LHDC, handle, newBitrateInx), handle->hasMinBitrateLimit ? 320 : 128),
+                                    handle->lastBitrate);
+            }
+        }
+
+        if (handle->upBitrateCnt >= UP_RATE_TIME_CNT) {
+            //clear down bitrate parameters...
+            size_t queueLength = handle->upBitrateSum / handle->upBitrateCnt;
+            uint32_t queuSumTmp = handle->upBitrateSum;
+
+            handle->upBitrateSum = 0;
+            handle->upBitrateCnt = 0;
+            //int newBitrateInx = bitrateIndexFrom(ENC_TYPE_LHDC, queueLength);
+            uint32_t newBitrateInx = indexOfBitrate(ENC_TYPE_LHDC, handle, handle->lastBitrate);
+            if (newBitrateInx < (LHDC_BITRATE_ELEMENTS_SIZE - 1)) {
+                newBitrateInx++;
+            }
+
+            if (TARGET_BITRATE_LIMIT(bitrateFromIndex(ENC_TYPE_LHDC, handle, newBitrateInx), handle->hasMinBitrateLimit ? 320 : 128) > handle->lastBitrate && queuSumTmp == 0) {
+                handle->lastBitrate = TARGET_BITRATE_LIMIT(bitrateFromIndex(ENC_TYPE_LHDC, handle, newBitrateInx), handle->hasMinBitrateLimit ? 320 : 128);
+
+                if (handle->version >= 2) {
+                  handle->updateFramneInfo = true;
+                }
+                LossyEncoderSetTargetByteRate(handle->fft_blk, (handle->lastBitrate * 1000) / 8);
+                ALOGD("%s:[Up BiTrAtE] Update bitrate(%d), queue length(%zu)",  __func__, handle->lastBitrate, queueLength);
+                lhdc_util_reset_down_bitrate(ENC_TYPE_LHDC, handle);
+            }else{
+              ALOGW("%s: Up bitrate condition fails, new rate:%d, current rate:%d, sum of queue len:%d",  __func__,
+                                    TARGET_BITRATE_LIMIT(bitrateFromIndex(ENC_TYPE_LHDC, handle, newBitrateInx), handle->hasMinBitrateLimit ? 320 : 128),
+                                    handle->lastBitrate,
+                                    queuSumTmp);
+            }
+        }
+
+
+        handle->upBitrateSum += queueLen;
+        handle->dnBitrateSum += queueLen;
+
+        handle->upBitrateCnt++;
+        handle->dnBitrateCnt++;
+
+        return 0;
+    }
+    ALOGE("%s: Handle error!(%p)",  __func__, handle);
+    return -1;
+}
+
+
+/*
+******************************************************************
+ LLAC functions group
+******************************************************************
+*/
+
+
+
+//kaiden:20210311:autobirate:llac_encoder_adjust_bitrate fucntion
+static int llac_encoder_adjust_bitrate(llac_para_t * handle, size_t queueLen) {
+
+    if (handle != NULL && handle->qualityStatus == LHDCBT_QUALITY_AUTO) {
+        if (handle->dnBitrateCnt >= DOWN_RATE_TIME_CNT) {
+            /* code */
+            size_t queueLength = handle->dnBitrateSum / handle->dnBitrateCnt;
+
+            handle->dnBitrateSum = 0;
+            handle->dnBitrateCnt = 0;
+            //int newBitrateInx = bitrateIndexFrom(ENC_TYPE_LLAC, queueLength);
+            if (queueLength)
+            {
+
+                int newBitrateInx = 0;
+                if (bitrateFromIndex(ENC_TYPE_LLAC, handle, newBitrateInx) < handle->lastBitrate) {
+                    handle->lastBitrate = bitrateFromIndex(ENC_TYPE_LLAC, handle, newBitrateInx);
+    
+                        llac_enc_set_bitrate(handle->lastBitrate * 1000, &handle->out_nbytes, &handle->real_bitrate, handle->lh4_enc);
+                        //handle->frame_per_packet = handle->host_mtu_size / handle->out_nbytes;
+                        handle->updateFramneInfo = true;
+    
+                        ALOGD("%s:[Down BiTrAtE] Update bitrate(%d), queue length(%zu)",  __func__, handle->lastBitrate, queueLength);
+                        lhdc_util_reset_up_bitrate(ENC_TYPE_LLAC, handle);
+                    }else{
+                      ALOGW("%s: Down bitrate condition fails, new rate:%d, current rate:%d",  __func__,
+                                            bitrateFromIndex(ENC_TYPE_LLAC, handle, newBitrateInx),
+                                            handle->lastBitrate);
+                }
+            }
+
+        }
+
+        if (handle->upBitrateCnt >= UP_RATE_TIME_CNT) {
+            //clear down bitrate parameters...
+            size_t queueLength = handle->upBitrateSum / handle->upBitrateCnt;
+            uint32_t queuSumTmp = handle->upBitrateSum;
+
+            handle->upBitrateSum = 0;
+            handle->upBitrateCnt = 0;
+            //int newBitrateInx = bitrateIndexFrom(ENC_TYPE_LHDC, queueLength);
+            uint32_t newBitrateInx = indexOfBitrate(ENC_TYPE_LLAC, handle, handle->lastBitrate);
+            if (newBitrateInx < (LLAC_BITRATE_ELEMENTS_SIZE - 1)) {
+                newBitrateInx++;
+            }
+
+            if (bitrateFromIndex(ENC_TYPE_LLAC, handle, newBitrateInx) > handle->lastBitrate && queuSumTmp == 0) {
+                handle->lastBitrate = bitrateFromIndex(ENC_TYPE_LLAC, handle, newBitrateInx);
+
+                llac_enc_set_bitrate(handle->lastBitrate * 1000, &handle->out_nbytes, &handle->real_bitrate, handle->lh4_enc);
+                //handle->frame_per_packet = handle->host_mtu_size / handle->out_nbytes;
+                handle->updateFramneInfo = true;
+
+                ALOGD("%s:[Up BiTrAtE] Update bitrate(%d), queue length(%zu)",  __func__, handle->lastBitrate, queueLength);
+                lhdc_util_reset_down_bitrate(ENC_TYPE_LLAC, handle);
+            }else{
+              ALOGW("%s: Up bitrate condition fails, new rate:%d, current rate:%d, sum of queue len:%d",  __func__,
+                                    bitrateFromIndex(ENC_TYPE_LLAC, handle, newBitrateInx),
+                                    handle->lastBitrate,
+                                    queuSumTmp);
+            }
+        }
+
+
+        handle->upBitrateSum += queueLen;
+        handle->dnBitrateSum += queueLen;
+
+        handle->upBitrateCnt++;
+        handle->dnBitrateCnt++;
+
+        return 0;
+    }
+    ALOGE("%s: Handle error!(%p)",  __func__, handle);
+    return -1;
+}
+
+/*
+******************************************************************
+ LHDC library public functions group
+******************************************************************
+*/
+
+void lhdcBT_free_handle(HANDLE_LHDC_BT handle) {
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+    if (!lhdcBT)
+    {
+        ALOGE("%s: Handle is NULL!!!", __func__);
+        return;
+    }
+    switch(lhdcBT->enc_type){
+        case ENC_TYPE_LHDC:
+        lhdc_encoder_free(lhdcBT->enc.lhdc);
+        break;
+        case ENC_TYPE_LLAC:
+        llac_encoder_free(lhdcBT->enc.llac);
+        break;
+        default:
+        break;
+    }
+
+    ar_process_free(lhdcBT->ar_filter);
+
+    free(lhdcBT);
+}
+
+
+HANDLE_LHDC_BT lhdcBT_get_handle(int version){
+    ALOGD("%s: Version number %d", __func__, version);
+
+    if(version <= 0)
+    {
+      return NULL;
+    }
+
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)malloc(sizeof(lhdc_cb_t));
+    memset(lhdcBT, 0 , sizeof(lhdc_cb_t));
+
+#ifdef AR_ALWAYS_ON
+    lhdcBT->ar_filter = ar_process_new();
+#else
+    if(version >= 3)
+    {
+        lhdcBT->ar_filter = ar_process_new();
+    }
+#endif
+
+    if (version <= 3)
+    {
+        lhdcBT->enc.lhdc = lhdc_encoder_new(version);
+        lhdcBT->enc_type = ENC_TYPE_LHDC;
+    }else if (version == 4){
+        lhdcBT->enc.llac = llac_encoder_new();
+        lhdcBT->enc_type = ENC_TYPE_LLAC;
+    }else{
+        lhdcBT->enc_type = ENC_TYPE_UNKNOWN;
+        free(lhdcBT);
+        lhdcBT = NULL;
+    }
+
+    return lhdcBT;
+}
+int lhdcBT_init_encoder(HANDLE_LHDC_BT handle,int sampling_freq, int bitPerSample, int bitrate_inx,
+    int dualChannel, int need_padding, int mtu, int interval) {
+
+    int result = 0;
+    unsigned int samples_per_frame = 0;
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+    if (!lhdcBT)
+    {
+        ALOGE("%s: Handle is NULL!!!", __func__);
+        return -1;
+    }
+
+    if (sampling_freq != 44100 && sampling_freq != 48000 && sampling_freq != 96000)
+    {
+      ALOGE("%s: Invalid Sample Rate (%d)!!!", __func__, sampling_freq);
+      return -1;
+    }
+
+    if (bitPerSample != LHDCBT_SMPL_FMT_S16 && bitPerSample != LHDCBT_SMPL_FMT_S24)
+    {
+      ALOGE("%s: Invalid Bit Per Sample (%d)!!!", __func__, bitPerSample);
+      return -1;
+    }
+
+    if (bitrate_inx < LHDCBT_QUALITY_LOW0 || bitrate_inx >= LHDCBT_QUALITY_MAX)
+    {
+      ALOGE("%s: invalid bit rate index (%d)!!!", __func__, bitrate_inx);
+      return -1;
+    }
+
+    if (dualChannel != 0 && dualChannel != 1)
+    {
+      ALOGE("%s: invalid Channel mode (%d)!!!", __func__, dualChannel);
+      return -1;
+    }
+
+    if (need_padding != 0)
+    {
+      ALOGE("%s: invalid need padding (%d)!!!", __func__, need_padding);
+      return -1;
+    }
+
+    if (mtu <= 0 || mtu >= 4096 )
+    {
+      ALOGE("%s: invalid mtu (%d)!!!", __func__, mtu);
+      return -1;
+    }
+
+    if (interval <= 0 || interval > 20) //default: 10ms or 20ms
+    {
+      ALOGE("%s: invalid interval (%d)!!!", __func__, interval);
+      return -1;
+    }
+
+    enc_t * enc = &lhdcBT->enc;
+
+    switch(lhdcBT->enc_type){
+        case ENC_TYPE_LHDC:
+           result = lhdc_encoder_init(enc->lhdc, sampling_freq, bitPerSample, bitrate_inx, dualChannel, need_padding, mtu, interval);
+           samples_per_frame = lhdc_encoder_get_frame_len(enc->lhdc);
+           break;
+        case ENC_TYPE_LLAC:
+            result = llac_encoder_init(enc->llac, sampling_freq, bitPerSample, bitrate_inx, mtu, interval);
+            samples_per_frame = llac_encoder_get_frame_len(enc->llac);  
+           break;
+        default:
+        break;
+    }
+
+    if (result >= 0 && samples_per_frame > 0 && lhdcBT->ar_filter != NULL){
+        // number of channels is fixed to "2"
+        result = ar_process_init(lhdcBT->ar_filter, sampling_freq, bitPerSample, 2, samples_per_frame);
+    }
+
+    return result;
+}
+
+void lhdcBT_set_max_bitrate(HANDLE_LHDC_BT handle, int max_rate_index) {
+
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+    if (!lhdcBT)
+    {
+        ALOGE("%s: Handle is NULL!!!", __func__);
+        return;
+    }
+    if (max_rate_index < LHDCBT_QUALITY_LOW0 || max_rate_index >= LHDCBT_QUALITY_MAX)
+    {
+      ALOGE("%s: invalid bit rate index (%d)!!!", __func__, max_rate_index);
+      return;
+    }
+    enc_t * enc = &lhdcBT->enc;
+
+    switch(lhdcBT->enc_type){
+        case ENC_TYPE_LHDC:
+            return lhdc_encoder_set_max_bitrate(enc->lhdc, max_rate_index);
+        case ENC_TYPE_LLAC: {
+
+            //return llac_encoder_init(enc->llac, sampling_freq, bitPerSample, bitrate_inx, mtu, interval);
+            ALOGD("%s: LLAC not supported", __func__);
+        }
+        default:
+        break;
+    }
+}
+
+
+int lhdcBT_encode(HANDLE_LHDC_BT handle, void* p_pcm, unsigned char* p_stream){
+
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+    if (!lhdcBT)
+    {
+        ALOGE("%s: Handle is NULL!!!", __func__);
+        return -1;
+    }
+    if (!p_pcm)
+    {
+        ALOGE("%s: p_pcm is NULL!!!", __func__);
+        return -1;
+    }
+    if (!p_stream)
+    {
+        ALOGE("%s: p_stream is NULL!!!", __func__);
+        return -1;
+    }
+    enc_t * enc = &lhdcBT->enc;
+
+    switch(lhdcBT->enc_type){
+        case ENC_TYPE_LHDC:
+            return lhdc_encoder_encode(enc->lhdc, p_pcm, p_stream);
+
+        case ENC_TYPE_LLAC: {
+
+            //return llac_encoder_init(enc->llac, sampling_freq, bitPerSample, bitrate_inx, mtu, interval);
+            ALOGD("%s: LLAC not supported", __func__);
+            break;
+        }
+        default:
+        break;
+    }
+    return -1;
+}
+
+
+int lhdcBT_encodeV3(HANDLE_LHDC_BT handle, void* p_pcm, unsigned char* out_put, uint32_t * written, uint32_t * out_frames){
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+    if (!lhdcBT)
+    {
+        ALOGE("%s: Handle is NULL!!!", __func__);
+        return -1;
+    }
+    if (p_pcm == NULL)
+    {
+        ALOGE("%s: input pcm buffer ptr is NULL!!!", __func__);
+        return -1;
+    }
+    if (out_put == NULL)
+    {
+        ALOGE("%s: output pcm buffer ptr is NULL!!!", __func__);
+        return -1;
+    }
+    if (written == NULL)
+    {
+        ALOGE("%s: written address is NULL!!!", __func__);
+        return -1;
+    }
+    if (out_frames == NULL)
+    {
+        ALOGE("%s: out_frames address is NULL!!!", __func__);
+        return -1;
+    }
+
+    return lhdc_util_encv4_process( handle, p_pcm, out_put, written, out_frames);
+}
+
+
+
+int lhdcBT_get_block_Size(HANDLE_LHDC_BT handle){
+
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+    if (!lhdcBT)
+    {
+        ALOGE("%s: Handle is NULL!!!", __func__);
+        return -1;
+    }
+    enc_t * enc = &lhdcBT->enc;
+
+    switch(lhdcBT->enc_type){
+        case ENC_TYPE_LHDC:
+            return lhdc_encoder_get_frame_len(enc->lhdc);
+
+        case ENC_TYPE_LLAC: {
+            return llac_encoder_get_frame_len(enc->llac);   //llac_encoder_encode(enc->llac, p_pcm, out_put, written, out_fraems);
+        }
+        default:
+        break;
+    }
+    return 0;
+}
+
+
+int lhdcBT_get_bitrate(HANDLE_LHDC_BT handle) {
+
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+    if (!lhdcBT)
+    {
+        ALOGE("%s: Handle is NULL!!!", __func__);
+        return -1;
+    }
+    enc_t * enc = &lhdcBT->enc;
+
+    switch(lhdcBT->enc_type){
+        case ENC_TYPE_LHDC:
+            return lhdc_encoder_get_target_bitrate(enc->lhdc);
+
+        case ENC_TYPE_LLAC: {
+            return llac_encoder_get_target_bitrate(enc->llac);  //llac_encoder_encode(enc->llac, p_pcm, out_put, written, out_fraems);
+        }
+        default:
+        break;
+    }
+    return -1;
+}
+
+
+
+int lhdcBT_set_bitrate(HANDLE_LHDC_BT handle, int bitrate_inx){
+
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+    if (!lhdcBT)
+    {
+        ALOGE("%s: Handle is NULL!!!", __func__);
+        return -1;
+    }
+
+    if(bitrate_inx < LHDCBT_QUALITY_LOW0 || bitrate_inx >= LHDCBT_QUALITY_MAX)
+    {
+      ALOGE("%s: invalid bit rate index (%d)!!!", __func__, bitrate_inx);
+      return -1;
+    }
+
+    enc_t * enc = &lhdcBT->enc;
+
+    switch(lhdcBT->enc_type){
+        case ENC_TYPE_LHDC: {
+          lhdc_para_t *lhdc = enc->lhdc;
+          if(lhdc == NULL) {
+            ALOGD("%s: LHDC [Reset BiTrAtE] null ptr!",  __func__);
+            return -1;
+          }
+
+          if(bitrate_inx == LHDCBT_QUALITY_RESET_AUTO) {
+            if(lhdc->qualityStatus != LHDCBT_QUALITY_AUTO) {
+              ALOGD("%s: LHDC [Reset BiTrAtE] only work in ABR! (%d)",  __func__, lhdc->qualityStatus);
+              return -1;
+            }
+            // change bitrate only, do not update qualityStatus
+            lhdc->lastBitrate = LHDC_ABR_DEFAULT_BITRATE;
+            lhdc_util_reset_up_bitrate(ENC_TYPE_LHDC, lhdc);
+            lhdc_util_reset_down_bitrate(ENC_TYPE_LHDC, lhdc);
+            if (lhdc->version >= 2) {
+              lhdc->updateFramneInfo = true;
+            }
+            LossyEncoderSetTargetByteRate(lhdc->fft_blk, (lhdc->lastBitrate * 1000) / 8);
+            ALOGD("%s: LHDC [Reset BiTrAtE] Reset bitrate to (%d)",  __func__, lhdc->lastBitrate);
+            return 0;
+          } else {
+            // normal case, will update qualityStatus
+            ALOGD("%s: LHDC set bitrate_inx %d", __func__, bitrate_inx);
+            return lhdc_encoder_set_bitrate(lhdc, bitrate_inx);
+          }
+        }
+
+        case ENC_TYPE_LLAC: {
+          llac_para_t * llac = enc->llac;
+          if(llac == NULL) {
+            ALOGD("%s: LLAC [Reset BiTrAtE] null ptr!",  __func__);
+            return -1;
+          }
+
+          if(bitrate_inx == LHDCBT_QUALITY_RESET_AUTO) {
+            if(llac->qualityStatus != LHDCBT_QUALITY_AUTO) {
+              ALOGD("%s: LLAC [Reset BiTrAtE] only work in ABR! (%d)",  __func__, llac->qualityStatus);
+              return -1;
+            }
+            // change bitrate only, do not update qualityStatus
+            llac->lastBitrate = LLAC_ABR_DEFAULT_BITRATE;
+            ALOGD("%s: LLAC [Reset BiTrAtE] Reset bitrate to (%d)", __func__, llac->lastBitrate);
+            llac_enc_set_bitrate(llac->lastBitrate * 1000, &llac->out_nbytes, &llac->real_bitrate, llac->lh4_enc);
+            llac->updateFramneInfo = true;
+            lhdc_util_reset_up_bitrate(ENC_TYPE_LLAC, llac);
+            lhdc_util_reset_down_bitrate(ENC_TYPE_LLAC, llac);
+            return 0;
+          } else {
+            //return llac_encoder_init(enc->llac, sampling_freq, bitPerSample, bitrate_inx, mtu, interval);
+            ALOGD("%s: LLAC not supported", __func__);
+            return -1;
+          }
+        }
+        default:
+        break;
+    }
+    return -1;
+}
+
+
+
+int lhdcBT_adjust_bitrate(HANDLE_LHDC_BT handle, size_t queueLen) {
+
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+    if (!lhdcBT)
+    {
+        ALOGE("%s: Handle is NULL!!!", __func__);
+        return -1;
+    }
+
+    if (queueLen < 0)
+    {
+        ALOGE("%s: Invalid queue Len (%zu)!!!", __func__, queueLen);
+        return -1;
+    }
+    enc_t * enc = &lhdcBT->enc;
+
+    switch(lhdcBT->enc_type){
+        case ENC_TYPE_LHDC:
+            return lhdc_encoder_adjust_bitrate(enc->lhdc, queueLen);
+
+        case ENC_TYPE_LLAC: {
+            return llac_encoder_adjust_bitrate(enc->llac, queueLen);
+        }
+        default:
+        break;
+    }
+    return -1;
+}
+
+int lhdcBT_set_ext_func_state(HANDLE_LHDC_BT handle, lhdcBT_ext_func_field_t field, bool enabled,
+    void * priv /*nullable*/, int priv_data_len){
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+    if (!lhdcBT)
+    {
+        ALOGE("%s: Handle is NULL!!!", __func__);
+        return -1;
+    }
+    if (field < LHDCBT_EXT_FUNC_AR || field >= LHDCBT_EXT_FUNC_MAX)
+    {
+        ALOGE("%s: invalid field (%d) !!!", __func__, field);
+        return -1;
+    }
+    enc_t * enc = &lhdcBT->enc;
+
+//void LhdcExtFuncArEnable(FFT_BLOCK *fb, int enable_ar);
+//void LhdcExtFuncJasEnable(FFT_BLOCK *fb, int enable_Jas);
+//void LhdcExtFuncMetaEnable(FFT_BLOCK *fb, int enable_meta, unsigned char *pmeta_data, int meta_data_len, int conti_frame_cnt);
+    switch(lhdcBT->enc_type){
+        case ENC_TYPE_LHDC:
+        {
+            switch((lhdc_ext_func_t)field){
+                case EXT_FUNC_AR:
+                LhdcExtFuncArEnable(enc->lhdc->fft_blk, enabled ? 1 : 0);
+                ALOGD("%s: lhdc AR func = %d", __func__, enabled);
+                return 0;
+                break;
+
+                case EXT_FUNC_JAS:
+                LhdcExtFuncJasEnable(enc->lhdc->fft_blk, enabled ? 1 : 0);
+                ALOGD("%s: lhdc JAS func = %d", __func__, enabled);
+                return 0;
+                break;
+
+                case EXT_FUNC_META:
+                if (!priv || !priv_data_len) {
+                    return -1;
+                }
+                LhdcExtFuncMetaEnable(enc->lhdc->fft_blk, enabled ? 1 : 0, priv, priv_data_len, 8);
+                ALOGD("%s: lhdc Meta func = %d", __func__, enabled);
+                return 0;
+                break;
+
+                default:
+                break;
+            }
+        }
+        break;
+
+        case ENC_TYPE_LLAC:
+        {
+            int8_t f_inx =  -1;
+            uint8_t f_enbaled = enabled ? 1 : 0;
+            switch((lhdc_ext_func_t)field){
+                case EXT_FUNC_AR:
+                f_inx = EXTRA_FUNC_AR;
+                break;
+
+                case EXT_FUNC_LARC:
+                f_inx = EXTRA_FUNC_LARC;
+                break;
+
+                default:
+                break;
+            }
+            if (f_inx >= 0)
+            {
+                ALOGD("%s: f_inx:%d, f_enbaled:%d, enc->llac->lh4_enc(%p)", __func__, f_inx, f_enbaled, enc->llac->lh4_enc);
+                llac_enc_set_extra_func(f_inx,
+                                        f_enbaled,
+                                        enc->llac->lh4_enc);
+                return 0;
+            }
+        }
+        break;
+
+        default:
+        break;
+    }
+
+    return -1;
+}
+
+int lhdcBT_get_ext_func_state(HANDLE_LHDC_BT handle, lhdcBT_ext_func_field_t field, bool * enabled){
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+    if (!lhdcBT)
+    {
+        ALOGE("%s: Handle is NULL!!!", __func__);
+        return -1;
+    }
+    if (!enabled)
+    {
+        ALOGE("%s: enabled is NULL!!!", __func__);
+        return -1;
+    }
+    enc_t * enc = &lhdcBT->enc;
+    *enabled = lhdc_util_get_ext_func_state(lhdcBT->enc_type, enc, (lhdc_ext_func_t)field);
+
+
+    return 0;
+}
+
+int lhdcBT_set_hasMinBitrateLimit(HANDLE_LHDC_BT handle, bool enabled ){
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+    if (!lhdcBT)
+    {
+        ALOGE("%s: Handle is NULL!!!", __func__);
+        return -1;
+    }
+    enc_t * enc = &lhdcBT->enc;
+
+
+    switch(lhdcBT->enc_type){
+        case ENC_TYPE_LHDC:
+            ALOGD("%s:set value (%d)",  __func__, enabled);
+            enc->lhdc->hasMinBitrateLimit = enabled;
+            break;
+
+        case ENC_TYPE_LLAC: {
+            ALOGD("%s: ENC_TYPE_LLAC unsupported!!!", __func__);
+            break;
+        }
+        default:
+        break;
+    }
+
+    return 0;
+}
+
+/*
+******************************************************************
+ Extend API functions group
+******************************************************************
+*/
+
+//
+// META
+//
+static int lhdcBT_set_cfg_meta_v1(HANDLE_LHDC_BT handle, const char* userConfig, const int configLen) 
+{
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+    PST_LHDC_SET_META pset_meta = (PST_LHDC_SET_META)userConfig;
+
+    unsigned char  *pmeta_metadata = NULL;
+
+    if (handle == NULL) {
+        ALOGE("(LHDC-exAPI) %s: Handle error!(%p)",  __func__, handle);
+        return EXTEND_FUNC_RET_INVALID_HANDLE;
+    }
+
+    if (userConfig == NULL)
+    {
+        ALOGE("(LHDC-exAPI) %s: User Config error!(%p)",  __func__, userConfig);
+        return EXTEND_FUNC_RET_INVALID_PARAMETER;		
+    }
+	
+    if (configLen < (int) sizeof (ST_LHDC_SET_META))
+    {
+        // Buffer is to small
+    	ALOGE("(LHDC-exAPI) %s: Buffer too small(req:%d)",  __func__, (int)sizeof(ST_LHDC_SET_META));
+        return EXTEND_FUNC_RET_BUF_UNDERRUN;
+    }
+
+
+
+
+    if (pset_meta->meta_ver != META_ST_VER_V2)
+    {
+    	ALOGE("(LHDC-exAPI) %s: ver not match",  __func__);
+        return EXTEND_FUNC_RET_INVALID_PARAMETER;
+    }
+	
+    if (pset_meta->meta_mem_size != (int) sizeof (ST_LHDC_SET_META))
+    {
+    	ALOGE("(LHDC-exAPI) %s: mata size not match", __func__);
+        return EXTEND_FUNC_RET_INVALID_PARAMETER;
+    }
+
+    if (configLen < ((int) pset_meta->meta_metadata_length) + ((int) sizeof (ST_LHDC_SET_META)))
+    {
+    	ALOGE("(LHDC-exAPI) %s: cfg size too small", __func__);
+        return EXTEND_FUNC_RET_INVALID_PARAMETER;
+    }
+
+    enc_t * enc = &lhdcBT->enc;
+
+    switch(lhdcBT->enc_type)
+    {
+    case ENC_TYPE_LHDC:
+        ALOGD("(LHDC-exAPI) %s: ENC_TYPE_LHDC", __func__);
+        pmeta_metadata = (unsigned char*) (pset_meta + 1);
+
+        LhdcExtFuncMetaEnable(enc->lhdc->fft_blk, 
+                              pset_meta->meta_enable, 
+                              pmeta_metadata, 
+                              pset_meta->meta_metadata_length, 
+                              pset_meta->meta_set);
+        break;
+
+    case ENC_TYPE_LLAC:
+    	ALOGD("(LHDC-exAPI) %s: ENC_TYPE_LLAC", __func__);
+        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+        break;
+
+    default:
+        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+        break;
+    }
+
+
+    return EXTEND_FUNC_RET_OK;
+}
+
+
+static int lhdcBT_get_cfg_meta_v1(HANDLE_LHDC_BT handle, char* userConfig, const int configLen) 
+{
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+    PST_LHDC_GET_META pget_meta = (PST_LHDC_GET_META)userConfig;
+    bool jas_enabled = false;
+
+    if (handle == NULL) {
+        ALOGE("(LHDC-exAPI) %s: Handle error!(%p)",  __func__, handle);
+        return EXTEND_FUNC_RET_INVALID_HANDLE;
+    }
+
+    if (userConfig == NULL)
+    {
+        ALOGE("(LHDC-exAPI) %s: User Config error!(%p)",  __func__, userConfig);
+        return EXTEND_FUNC_RET_INVALID_PARAMETER;		
+    }
+
+    if (configLen < (int) sizeof (ST_LHDC_GET_META))
+    {
+         // Buffer is to small
+    	ALOGE("(LHDC-exAPI) %s: Buffer too small(req:%d)",  __func__, (int)sizeof(ST_LHDC_GET_META));
+        return EXTEND_FUNC_RET_BUF_UNDERRUN;
+    }
+
+
+    enc_t * enc = &lhdcBT->enc;
+
+    switch(lhdcBT->enc_type)
+    {
+    case ENC_TYPE_LHDC:
+        {
+        	ALOGD("(LHDC-exAPI) %s: ENC_TYPE_LHDC",  __func__);
+			pget_meta->meta_ver = META_ST_VER_V2;
+			pget_meta->meta_mem_size = (int) sizeof (ST_LHDC_GET_META);
+			pget_meta->meta_st = (LhdcGetExtFuncState(enc->lhdc->fft_blk, EXT_FUNC_META) << 1) | 0x01;  // Get current frame include metadata or not
+
+			//2021/06/10: Append JAS status her ,let UI can get JAS status from LHDC,
+			jas_enabled = lhdc_util_get_ext_func_state(lhdcBT->enc_type, enc, EXT_FUNC_JAS);
+			if(jas_enabled)
+			{
+				pget_meta->jas_status = 1;
+			}
+			else
+			{
+				pget_meta->jas_status = 0;
+			}
+        }
+        break;
+
+    case ENC_TYPE_LLAC:
+    	ALOGD("(LHDC-exAPI) %s: ENC_TYPE_LLAC",  __func__);
+        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+        break;
+
+    default:
+        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+        break;
+    }
+
+
+    return EXTEND_FUNC_RET_OK;
+}
+
+
+//
+// AR
+//
+static int Ar_set_ext_func_state(HANDLE_LHDC_BT handle, bool enabled){
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+    if (!lhdcBT)
+    {
+        ALOGD("(LHDC-exAPI) %s: Handle is NULL!!!", __func__);
+        return -1;
+    }
+    enc_t * enc = &lhdcBT->enc;
+
+    switch(lhdcBT->enc_type){
+        case ENC_TYPE_LHDC:
+        {
+            LhdcExtFuncArEnable(enc->lhdc->fft_blk, enabled ? 1 : 0);
+            ALOGD("(LHDC-exAPI) %s: lhdc AR func = %d", __func__, enabled);
+        }
+        break;
+        case ENC_TYPE_LLAC:
+        {
+            int8_t f_inx = EXTRA_FUNC_AR;
+            uint8_t f_enbaled = enabled ? 1 : 0;
+            ALOGD("(LHDC-exAPI) %s: f_enbaled:%d, enc->llac->lh4_enc(%p)", __func__, f_enbaled, enc->llac->lh4_enc);
+            llac_enc_set_extra_func(f_inx, f_enbaled, enc->llac->lh4_enc);
+        }
+        break;
+        default:
+        break;
+    }
+    return 0;
+}
+
+static int lhdcBT_set_data_gyro_2d_v1(HANDLE_LHDC_BT handle, const char *userData, const int dataLen) {
+
+    PST_LHDC_AR_GYRO pargyro = (PST_LHDC_AR_GYRO) userData;
+
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+
+    enc_t * enc = &lhdcBT->enc;
+
+    bool ar_enabled = false;
+
+    int res;
+
+    if (handle == NULL) {
+        ALOGE("(LHDC-exAPI) %s: Handle error!(%p)",  __func__, handle);
+        return EXTEND_FUNC_RET_INVALID_HANDLE;
+    }
+
+    if (userData == NULL)
+    {
+        ALOGE("(LHDC-exAPI) %s: User Data error!(%p)",  __func__, userData);
+        return EXTEND_FUNC_RET_INVALID_PARAMETER;		
+    }
+
+    if (dataLen < (int) sizeof (ST_LHDC_AR_GYRO))
+    {
+         // Buffer is to small
+    	ALOGE("(LHDC-exAPI) %s: Buffer too small",  __func__);
+        return EXTEND_FUNC_RET_BUF_UNDERRUN;
+    }
+
+	ALOGD("(LHDC-exAPI) %s: gyro[%d %d %d]",  __func__,
+			pargyro->world_coordinate_x, pargyro->world_coordinate_y, pargyro->world_coordinate_z);
+
+    ar_enabled = lhdc_util_get_ext_func_state(lhdcBT->enc_type, enc, EXT_FUNC_AR);
+
+#ifdef AR_ALWAYS_ON
+    ar_enabled = true;
+#endif
+
+    if (ar_enabled)
+    {
+        res = ar_set_gyro_pos(lhdcBT->ar_filter, pargyro->world_coordinate_x, pargyro->world_coordinate_y, pargyro->world_coordinate_z);
+    }
+    else
+    {
+        ALOGD("(LHDC-exAPI) %s: AR not enabled!",  __func__);
+        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+    }
+
+    if(res != 0)
+    {
+    	ALOGD("(LHDC-exAPI) %s: set_gyro_pos error(%d)",  __func__, res);
+        return EXTEND_FUNC_RET_ERROR;
+    }
+
+    return EXTEND_FUNC_RET_OK;
+}
+
+
+static int lhdcBT_set_cfg_ar_v3(HANDLE_LHDC_BT handle, const char *userConfig, const int configLen) {
+
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+
+    enc_t * enc = &lhdcBT->enc;
+
+    PST_LHDC_AR pset_ar_cfg = (PST_LHDC_AR)userConfig;
+
+    bool ar_enabled = false;
+
+    int res;
+
+    if (handle == NULL) {
+        ALOGE("(LHDC-exAPI) %s: Handle error!(%p)",  __func__, handle);
+        return EXTEND_FUNC_RET_INVALID_HANDLE;
+    }
+
+    if (userConfig == NULL)
+    {
+        ALOGE("(LHDC-exAPI) %s: User Config error!(%p)",  __func__, userConfig);
+        return EXTEND_FUNC_RET_INVALID_PARAMETER;		
+    }
+
+    if (configLen < (int) sizeof (ST_LHDC_AR))
+    {
+         // Buffer is to small
+    	ALOGE("(LHDC-exAPI) %s: Buffer too small",  __func__);
+        return EXTEND_FUNC_RET_BUF_UNDERRUN;
+    }
+    ALOGD("(LHDC-exAPI) %s: config AR %d",  __func__, pset_ar_cfg->app_ar_enabled);
+
+    ar_enabled = pset_ar_cfg->app_ar_enabled ? 1 : 0;
+
+    Ar_set_ext_func_state(handle, ar_enabled);
+    //LhdcExtFuncArEnable(enc->lhdc->fft_blk, pset_ar_cfg->app_ar_enabled ? 1 : 0);
+
+    ar_enabled = lhdc_util_get_ext_func_state(lhdcBT->enc_type, enc, EXT_FUNC_AR);
+
+    ALOGD("(LHDC-exAPI) %s: AR enabled %d",  __func__, ar_enabled);
+
+#ifdef AR_ALWAYS_ON
+    ar_enabled = true;
+#endif
+
+    if (ar_enabled)
+    {
+        res = ar_set_cfg(lhdcBT->ar_filter, &pset_ar_cfg->Ch1_Pos, &pset_ar_cfg->Ch1_L_PreGain, pset_ar_cfg->app_ar_enabled);
+    }
+    else
+    {
+        ALOGD("(LHDC-exAPI) %s: AR not enabled!",  __func__);
+        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+    }
+
+    if(res != 0)
+    {
+        return EXTEND_FUNC_RET_ERROR;
+    }
+
+    return EXTEND_FUNC_RET_OK;
+}
+
+	
+static int lhdcBT_get_cfg_ar_v1(HANDLE_LHDC_BT handle, char *userConfig, const int configLen) {
+
+    //PST_LHDC_AR pset_ar_cfg = (PST_LHDC_AR)userConfig;
+
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+
+    enc_t * enc = &lhdcBT->enc;
+
+    bool ar_enabled = false;
+
+
+    int res = 0;
+
+    if (handle == NULL) {
+        ALOGE("(LHDC-exAPI) %s: Handle error!(%p)",  __func__, handle);
+        return EXTEND_FUNC_RET_INVALID_HANDLE;
+    }
+
+    if (userConfig == NULL)
+    {
+        ALOGE("(LHDC-exAPI) %s: User Config error!(%p)",  __func__, userConfig);
+        return EXTEND_FUNC_RET_INVALID_PARAMETER;		
+    }
+
+    if (configLen <= (int) 0)
+    {
+         // Buffer is to small
+    	ALOGE("(LHDC-exAPI) %s: Buffer too small",  __func__);
+        return EXTEND_FUNC_RET_BUF_UNDERRUN;
+    }
+
+    ar_enabled = lhdc_util_get_ext_func_state(lhdcBT->enc_type, enc, EXT_FUNC_AR);
+
+#ifdef AR_ALWAYS_ON
+    ar_enabled = true;
+#endif
+
+    if (ar_enabled)
+    {
+    	ALOGD("(LHDC-exAPI) %s: AR enabled",  __func__);
+    	//2021/11/09: ar_get_cfg not supported yet
+        //res = ar_get_cfg(lhdcBT->ar_filter, &pset_ar_cfg->Ch1_Pos, &pset_ar_cfg->Ch1_L_PreGain);
+    	return EXTEND_FUNC_RET_ERROR;
+    }
+    else
+    {
+        ALOGD("(LHDC-exAPI) %s: AR not enabled!",  __func__);
+        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+    }
+
+    if(res != 0)
+    {
+        return EXTEND_FUNC_RET_ERROR;
+    }
+
+    ALOGD("(LHDC-exAPI) %s: End OK",  __func__);
+    return EXTEND_FUNC_RET_OK;	
+}
+
+
+
+/*
+******************************************************************
+ Extend API library public functions group
+******************************************************************
+*/
+
+// 1. API -- Set User Config (Extend)
+int lhdcBT_set_user_exconfig(HANDLE_LHDC_BT handle, char* userConfig, int clen) {
+
+    unsigned char *pucConfig = (unsigned char *) userConfig;
+    unsigned int exFuncVer;
+    unsigned int exFuncCode;
+    int result = EXTEND_FUNC_RET_OK;
+
+    //ALOGD("(LHDC-exAPI) %s: enter\n",  __func__);
+
+    if (handle == NULL) {
+        ALOGE("(LHDC-exAPI) %s: Handle error!(%p)",  __func__, handle);
+        return EXTEND_FUNC_RET_INVALID_HANDLE;
+    }
+
+    if (userConfig == NULL)
+    {
+        ALOGE("(LHDC-exAPI) %s: User Config error!(%p)",  __func__, userConfig);
+        return EXTEND_FUNC_RET_INVALID_PARAMETER;		
+    }
+
+    if (clen < (int)EXTEND_FUNC_CODE_MIN_BUFFER_LEN)
+    {
+         // Buffer is to small
+    	ALOGE("(LHDC-exAPI) %s: Buffer too small",  __func__);
+        return EXTEND_FUNC_RET_BUF_UNDERRUN;
+    }
+
+    exFuncVer = (((unsigned int) pucConfig[3]) & ((unsigned int)0xff)) |
+               ((((unsigned int) pucConfig[2]) & ((unsigned int)0xff)) << 8)  |
+               ((((unsigned int) pucConfig[1]) & ((unsigned int)0xff)) << 16) |
+               ((((unsigned int) pucConfig[0]) & ((unsigned int)0xff)) << 24);
+    exFuncCode = (((unsigned int) pucConfig[7]) & ((unsigned int)0xff)) |
+                ((((unsigned int) pucConfig[6]) & ((unsigned int)0xff)) << 8)  |
+                ((((unsigned int) pucConfig[5]) & ((unsigned int)0xff)) << 16) |
+                ((((unsigned int) pucConfig[4]) & ((unsigned int)0xff)) << 24);
+
+    switch (exFuncCode) {
+    case EXTEND_FUNC_CODE_SET_CONFIG_META:
+	
+        switch (exFuncVer) {
+        case EXTEND_FUNC_VER_SET_CONFIG_META_V1:
+        	ALOGD("(LHDC-exAPI) %s: SET_CONFIG_META\n",  __func__);
+            result = lhdcBT_set_cfg_meta_v1 (handle, userConfig, clen);
+            break;
+
+        default:
+            ALOGE("(LHDC-exAPI) %s: Invalid Ex. Function Version!(0x%X)",  __func__, exFuncVer);
+            return EXTEND_FUNC_RET_VERSION_NOT_SUPPORT;
+        }
+        break;
+		
+    case EXTEND_FUNC_CODE_SET_CONFIG_AR:
+        switch (exFuncVer) {
+        case EXTEND_FUNC_VER_SET_CONFIG_AR_V3:
+        	ALOGD("(LHDC-exAPI) %s: SET_CONFIG_AR\n",  __func__);
+            result = lhdcBT_set_cfg_ar_v3 (handle, userConfig, clen);
+            break;
+
+        default:
+            ALOGE("(LHDC-exAPI) %s: Invalid Ex. Function Version!(0x%X)",  __func__, exFuncVer);
+            return EXTEND_FUNC_RET_VERSION_NOT_SUPPORT;
+        }
+        break;
+
+    default:
+        ALOGE("(LHDC-exAPI) %s: Invalid Ex. Function Code!(0x%X)",  __func__, exFuncCode);
+        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+    } // switch (exFuncCode)
+
+    return result;
+}
+
+
+// 2. API -- Get User Config (Extend)
+int lhdcBT_get_user_exconfig(HANDLE_LHDC_BT handle, char* userConfig, int clen) {
+
+
+    unsigned char *pucConfig = (unsigned char *) userConfig;
+    unsigned int exFuncVer;
+    unsigned int exFuncCode;
+    int result = EXTEND_FUNC_RET_OK;
+
+    //ALOGD("%s:(LHDC-exAPI) enter\n",  __func__);
+
+    if (handle == NULL) {
+        ALOGE("(LHDC-exAPI) %s: Handle error!(%p)",  __func__, handle);
+        return EXTEND_FUNC_RET_INVALID_HANDLE;
+    }
+
+    if (userConfig == NULL)
+    {
+        ALOGE("(LHDC-exAPI) %s: User Config error!(%p)",  __func__, userConfig);
+        return EXTEND_FUNC_RET_INVALID_PARAMETER;		
+    }
+
+    if (clen < (int)EXTEND_FUNC_CODE_MIN_BUFFER_LEN)
+    {
+         // Buffer is to small
+    	ALOGE("(LHDC-exAPI) %s: Buffer too small",  __func__);
+        return EXTEND_FUNC_RET_BUF_UNDERRUN;
+    }
+
+    exFuncVer = (((unsigned int) pucConfig[3]) & ((unsigned int)0xff)) |
+               ((((unsigned int) pucConfig[2]) & ((unsigned int)0xff)) << 8)  |
+               ((((unsigned int) pucConfig[1]) & ((unsigned int)0xff)) << 16) |
+               ((((unsigned int) pucConfig[0]) & ((unsigned int)0xff)) << 24);
+    exFuncCode = (((unsigned int) pucConfig[7]) & ((unsigned int)0xff)) |
+                ((((unsigned int) pucConfig[6]) & ((unsigned int)0xff)) << 8)  |
+                ((((unsigned int) pucConfig[5]) & ((unsigned int)0xff)) << 16) |
+                ((((unsigned int) pucConfig[4]) & ((unsigned int)0xff)) << 24);
+
+    switch (exFuncCode) {
+    case EXTEND_FUNC_CODE_GET_CONFIG_META:
+	
+        switch (exFuncVer) {
+        case EXTEND_FUNC_VER_GET_CONFIG_META_V1:
+        	ALOGD("(LHDC-exAPI) %s: GET_CONFIG_META\n",  __func__);
+            result = lhdcBT_get_cfg_meta_v1 (handle, userConfig, clen);
+            break;
+
+        default:
+            ALOGE("(LHDC-exAPI) %s: Invalid Ex. Function Version!(0x%X)",  __func__, exFuncVer);
+            return EXTEND_FUNC_RET_VERSION_NOT_SUPPORT;
+        }
+        break;
+
+    case EXTEND_FUNC_CODE_GET_CONFIG_AR:
+	
+        switch (exFuncVer) {
+        case EXTEND_FUNC_VER_GET_CONFIG_AR_V1:
+        	ALOGD("(LHDC-exAPI) %s: GET_CONFIG_AR\n",  __func__);
+            result = lhdcBT_get_cfg_ar_v1 (handle, userConfig, clen);
+            break;
+
+        default:
+            ALOGE("(LHDC-exAPI) %s: Invalid Ex. Function Version!(0x%X)",  __func__, exFuncVer);
+            return EXTEND_FUNC_RET_VERSION_NOT_SUPPORT;
+        }
+        break;
+
+    default:
+        ALOGE("(LHDC-exAPI) %s: Invalid Ex. Function Code!(0x%X)",  __func__, exFuncCode);
+        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+    } // switch (exFuncCode)
+
+    return result;
+
+}
+
+// 3. API -- Set User Data (Extend)
+void lhdcBT_set_user_exdata(HANDLE_LHDC_BT handle, char* userData, int clen) {
+
+    unsigned char *pucData = (unsigned char *) userData;
+    unsigned int exFuncVer;
+    unsigned int exFuncCode;
+    int result = EXTEND_FUNC_RET_OK;
+
+    //ALOGD("(LHDC-exAPI) %s: enter\n",  __func__);
+
+    if (handle == NULL) {
+        ALOGE("(LHDC-exAPI) %s: Handle error!(%p)",  __func__, handle);
+        return; // EXTEND_FUNC_RET_INVALID_HANDLE;
+    }
+
+    if (userData == NULL)
+    {
+        ALOGE("(LHDC-exAPI) %s: User Data error!(%p)",  __func__, userData);
+        return; // EXTEND_FUNC_RET_INVALID_PARAMETER;		
+    }
+
+    if (clen < (int)EXTEND_FUNC_CODE_MIN_BUFFER_LEN)
+    {
+         // Buffer is to small
+    	ALOGE("(LHDC-exAPI) %s: Buffer too small",  __func__);
+        return;
+    }
+
+    exFuncVer = (((unsigned int) pucData[3]) & ((unsigned int)0xff)) |
+               ((((unsigned int) pucData[2]) & ((unsigned int)0xff)) << 8)  |
+               ((((unsigned int) pucData[1]) & ((unsigned int)0xff)) << 16) |
+               ((((unsigned int) pucData[0]) & ((unsigned int)0xff)) << 24);
+    exFuncCode = (((unsigned int) pucData[7]) & ((unsigned int)0xff)) |
+                ((((unsigned int) pucData[6]) & ((unsigned int)0xff)) << 8)  |
+                ((((unsigned int) pucData[5]) & ((unsigned int)0xff)) << 16) |
+                ((((unsigned int) pucData[4]) & ((unsigned int)0xff)) << 24);
+
+    switch (exFuncCode) {
+    case EXTEND_FUNC_CODE_SET_DATA_GYRO2D:
+	
+        switch (exFuncVer) {
+        case EXTEND_FUNC_VER_SET_DATA_GYRO2D_V1:
+        	ALOGD("(LHDC-exAPI) %s: SET_DATA_GYRO\n",  __func__);
+            result = lhdcBT_set_data_gyro_2d_v1 (handle, userData, clen);
+            break;
+
+        default:
+            ALOGE("(LHDC-exAPI) %s: Invalid Ex. Function Version!(0x%X)",  __func__, exFuncVer);
+            return; // EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+        }
+        break;
+		
+    default:
+        ALOGE("(LHDC-exAPI) %s: Invalid Ex. Function Code!(0x%X)",  __func__, exFuncCode);
+        return; // EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+    } // switch (exFuncCode)
+
+    //return result;
+}
+
+
+// 4. API -- Get Version
+int lhdcBT_get_user_exApiver(HANDLE_LHDC_BT handle, char *version, int clen) {
+
+    unsigned char *pucApiVer = (unsigned char *) version;
+    unsigned int exFuncVer = 0;
+    unsigned int exFuncCode = 0;
+    unsigned int exFuncMinBufSize = 0;
+    int result = EXTEND_FUNC_RET_OK;
+
+    //ALOGD("(LHDC-exAPI) %s: enter\n",  __func__);
+
+    if (version == NULL)
+    {
+        ALOGE("(LHDC-exAPI) %s: API verion buffer error!(%p)",  __func__, version);
+        return EXTEND_FUNC_RET_INVALID_PARAMETER;
+    }
+
+    if (handle == NULL) {
+        ALOGE("(LHDC-exAPI) %s: Handle error!(%p)",  __func__, handle);
+        return EXTEND_FUNC_RET_INVALID_HANDLE;
+    }
+
+    if (clen < (int)EXTEND_FUNC_MIN_BUFFER_LEN_GET_API_VERSION_V1)
+    {
+         // Buffer is to small
+    	ALOGE("(LHDC-exAPI) %s: Buffer too small",  __func__);
+        return EXTEND_FUNC_RET_BUF_UNDERRUN;
+    }
+
+    /*
+    ALOGD("%s: clen=%d, APICode[4:7] = [0x%02X, 0x%02X, 0x%02X, 0x%02X]",  __func__,
+        clen, pucApiVer[4], pucApiVer[5], pucApiVer[6], pucApiVer[7]);
+        */
+
+    exFuncCode = (((unsigned int) pucApiVer[7]) & ((unsigned int)0xff)) |
+                ((((unsigned int) pucApiVer[6]) & ((unsigned int)0xff)) << 8)  |
+                ((((unsigned int) pucApiVer[5]) & ((unsigned int)0xff)) << 16) |
+                ((((unsigned int) pucApiVer[4]) & ((unsigned int)0xff)) << 24);
+
+    switch (exFuncCode) {
+    // Config API
+    case EXTEND_FUNC_CODE_SET_CONFIG_META:
+        exFuncVer = EXTEND_FUNC_VER_SET_CONFIG_META_V1;
+        break;
+
+    case EXTEND_FUNC_CODE_SET_CONFIG_AR:
+        exFuncVer = EXTEND_FUNC_VER_SET_CONFIG_AR_V3;
+        break;
+
+    case EXTEND_FUNC_CODE_GET_CONFIG_META:
+        exFuncVer = EXTEND_FUNC_VER_GET_CONFIG_META_V1;
+        break;
+
+    case EXTEND_FUNC_CODE_GET_CONFIG_AR:
+        exFuncVer = EXTEND_FUNC_VER_GET_CONFIG_AR_V1;
+        break;
+
+    // Data API
+    case EXTEND_FUNC_CODE_SET_DATA_GYRO2D:
+        exFuncVer = EXTEND_FUNC_VER_SET_DATA_GYRO2D_V1;
+        break;
+
+    // A2DP codec Specific API
+    case EXTEND_FUNC_CODE_GET_SPECIFIC:
+        exFuncVer = EXTEND_FUNC_VER_GET_SPECIFIC_V2;
+        exFuncMinBufSize = LHDC_EXTEND_FUNC_CONFIG_TOTAL_FIXED_SIZE_V2;
+        break;
+
+    default:
+        ALOGE("(LHDC-exAPI) %s: Invalid Ex. Function Code!(0x%X)",  __func__, exFuncCode);
+        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+    } // switch (exFuncCode)
+
+    /* fill in current version of target API */
+    pucApiVer[3] = (unsigned char) (exFuncVer & ((unsigned int)0xff));
+    pucApiVer[2] = (unsigned char) ((exFuncVer >> 8) & ((unsigned int)0xff));
+    pucApiVer[1] = (unsigned char) ((exFuncVer >> 16) & ((unsigned int)0xff));
+    pucApiVer[0] = (unsigned char) ((exFuncVer >> 24) & ((unsigned int)0xff));
+
+    /**** Version Control Field: *****/
+    if(exFuncVer >= EXTEND_FUNC_GENERIC_VERSION_NUMBER_V2 &&
+        clen >= EXTEND_FUNC_MIN_BUFFER_LEN_GET_API_VERSION_V2)
+    {
+      /* After API V2.0.0.0, append "minimum required buffer size" into API response */
+      pucApiVer[11] = (unsigned char) (exFuncMinBufSize & ((unsigned int)0xff));
+      pucApiVer[10] = (unsigned char) ((exFuncMinBufSize >> 8) & ((unsigned int)0xff));
+      pucApiVer[9] = (unsigned char) ((exFuncMinBufSize >> 16) & ((unsigned int)0xff));
+      pucApiVer[8] = (unsigned char) ((exFuncMinBufSize >> 24) & ((unsigned int)0xff));
+    }
+
+    ALOGD("(LHDC-exAPI) %s: return Ver=0x[%02X %02X %02X %02X]",  __func__,
+        pucApiVer[4], pucApiVer[5], pucApiVer[6], pucApiVer[7]);
+
+    return result;
+}
+
diff --git a/external/liblhdcdec/.autotools b/external/liblhdcdec/.autotools
new file mode 100755
index 00000000..45ba69e7
--- /dev/null
+++ b/external/liblhdcdec/.autotools
@@ -0,0 +1,83 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<configurations>
+<configuration id="org.eclipse.linuxtools.cdt.autotools.core.configuration.build.1127608133">
+<option id="configure" value="configure"/>
+<option id="configdir" value=""/>
+<option id="cache-file" value=""/>
+<option id="help" value="false"/>
+<option id="no-create" value="false"/>
+<option id="quiet" value="false"/>
+<option id="version" value="false"/>
+<option id="host" value=""/>
+<option id="build" value=""/>
+<option id="target" value=""/>
+<option id="prefix" value=""/>
+<option id="exec-prefix" value=""/>
+<option id="libdir" value=""/>
+<option id="bindir" value=""/>
+<option id="sbindir" value=""/>
+<option id="includedir" value=""/>
+<option id="datadir" value=""/>
+<option id="sysconfdir" value=""/>
+<option id="infodir" value=""/>
+<option id="mandir" value=""/>
+<option id="srcdir" value=""/>
+<option id="localstatedir" value=""/>
+<option id="sharedstatedir" value=""/>
+<option id="libexecdir" value=""/>
+<option id="oldincludedir" value=""/>
+<option id="program-prefix" value=""/>
+<option id="program-suffix" value=""/>
+<option id="program-transform-name" value=""/>
+<option id="env_vars" value=""/>
+<option id="enable-maintainer-mode" value="false"/>
+<flag id="CFLAGS" value="CFLAGS|CXXFLAGS">
+<flagvalue id="cflags-debug" value="false"/>
+<flagvalue id="cflags-gprof" value="false"/>
+<flagvalue id="cflags-gcov" value="false"/>
+</flag>
+<option id="user" value=""/>
+<option id="autogen" value="autogen.sh"/>
+<option id="autogenOpts" value=""/>
+</configuration>
+<configuration id="org.eclipse.linuxtools.cdt.autotools.core.configuration.build.debug.1976948808">
+<option id="configure" value="configure"/>
+<option id="configdir" value=""/>
+<option id="cache-file" value=""/>
+<option id="help" value="false"/>
+<option id="no-create" value="false"/>
+<option id="quiet" value="false"/>
+<option id="version" value="false"/>
+<option id="host" value=""/>
+<option id="build" value=""/>
+<option id="target" value=""/>
+<option id="prefix" value=""/>
+<option id="exec-prefix" value=""/>
+<option id="libdir" value=""/>
+<option id="bindir" value=""/>
+<option id="sbindir" value=""/>
+<option id="includedir" value=""/>
+<option id="datadir" value=""/>
+<option id="sysconfdir" value=""/>
+<option id="infodir" value=""/>
+<option id="mandir" value=""/>
+<option id="srcdir" value=""/>
+<option id="localstatedir" value=""/>
+<option id="sharedstatedir" value=""/>
+<option id="libexecdir" value=""/>
+<option id="oldincludedir" value=""/>
+<option id="program-prefix" value=""/>
+<option id="program-suffix" value=""/>
+<option id="program-transform-name" value=""/>
+<option id="env_vars" value=""/>
+<option id="enable-maintainer-mode" value="false"/>
+<flag id="CFLAGS" value="CFLAGS|CXXFLAGS">
+<flagvalue id="cflags-debug" value="false"/>
+<flagvalue id="cflags-gprof" value="false"/>
+<flagvalue id="cflags-gcov" value="false"/>
+</flag>
+<option id="user" value="CFLAGS=&apos;-g -O0&apos; CXXFLAGS=&apos;-g -O0&apos;"/>
+<option id="autogen" value="autogen.sh"/>
+<option id="autogenOpts" value=""/>
+</configuration>
+</configurations>
diff --git a/external/liblhdcdec/.cproject b/external/liblhdcdec/.cproject
new file mode 100755
index 00000000..4de551cd
--- /dev/null
+++ b/external/liblhdcdec/.cproject
@@ -0,0 +1,77 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<?fileVersion 4.0.0?><cproject storage_type_id="org.eclipse.cdt.core.XmlProjectDescriptionStorage">
+	<storageModule moduleId="org.eclipse.cdt.core.settings">
+		<cconfiguration id="org.eclipse.linuxtools.cdt.autotools.core.configuration.build.1127608133">
+			<storageModule buildSystemId="org.eclipse.cdt.managedbuilder.core.configurationDataProvider" id="org.eclipse.linuxtools.cdt.autotools.core.configuration.build.1127608133" moduleId="org.eclipse.cdt.core.settings" name="Build (GNU)">
+				<externalSettings/>
+				<extensions>
+					<extension id="org.eclipse.cdt.core.MachO64" point="org.eclipse.cdt.core.BinaryParser"/>
+					<extension id="org.eclipse.cdt.core.Cygwin_PE" point="org.eclipse.cdt.core.BinaryParser"/>
+					<extension id="org.eclipse.cdt.core.PE" point="org.eclipse.cdt.core.BinaryParser"/>
+					<extension id="org.eclipse.cdt.core.GNU_ELF" point="org.eclipse.cdt.core.BinaryParser"/>
+					<extension id="org.eclipse.cdt.core.ELF" point="org.eclipse.cdt.core.BinaryParser"/>
+					<extension id="org.eclipse.cdt.core.GmakeErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GASErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GLDErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.CWDLocator" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GCCErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+				</extensions>
+			</storageModule>
+			<storageModule moduleId="cdtBuildSystem" version="4.0.0">
+				<configuration artifactName="${ProjName}" buildArtefactType="org.eclipse.linuxtools.cdt.autotools.core.buildArtefactType.autotools" buildProperties="org.eclipse.cdt.build.core.buildArtefactType=org.eclipse.linuxtools.cdt.autotools.core.buildArtefactType.autotools,org.eclipse.cdt.build.core.buildType=org.eclipse.linuxtools.cdt.autotools.core.buildType.default" cleanCommand="rm -rf" description="" errorParsers="org.eclipse.cdt.core.CWDLocator;org.eclipse.cdt.core.GmakeErrorParser;org.eclipse.cdt.core.GCCErrorParser;org.eclipse.cdt.core.GLDErrorParser;org.eclipse.cdt.core.GASErrorParser" id="org.eclipse.linuxtools.cdt.autotools.core.configuration.build.1127608133" name="Build (GNU)" parent="org.eclipse.linuxtools.cdt.autotools.core.configuration.build">
+					<folderInfo id="org.eclipse.linuxtools.cdt.autotools.core.configuration.build.1127608133." name="/" resourcePath="">
+						<toolChain id="org.eclipse.linuxtools.cdt.autotools.core.toolChain.587545869" name="GNU Autotools Toolchain" superClass="org.eclipse.linuxtools.cdt.autotools.core.toolChain">
+							<targetPlatform id="org.eclipse.linuxtools.cdt.autotools.core.toolchain.targetPlatform.2030619516" isAbstract="false" name="GNU Autotools Target Platform" superClass="org.eclipse.linuxtools.cdt.autotools.core.toolchain.targetPlatform"/>
+							<builder id="org.eclipse.linuxtools.cdt.autotools.core.toolchain.builder.1546938105" managedBuildOn="true" name="Autotools Makefile Generator.Build (GNU)" superClass="org.eclipse.linuxtools.cdt.autotools.core.toolchain.builder"/>
+							<tool id="org.eclipse.linuxtools.cdt.autotools.core.gnu.toolchain.tool.configure.1429514451" name="configure" superClass="org.eclipse.linuxtools.cdt.autotools.core.gnu.toolchain.tool.configure"/>
+							<tool id="org.eclipse.linuxtools.cdt.autotools.core.toolchain.tool.autogen.1057848975" name="autogen.sh" superClass="org.eclipse.linuxtools.cdt.autotools.core.toolchain.tool.autogen"/>
+							<tool id="org.eclipse.linuxtools.cdt.autotools.core.toolchain.tool.gcc.36994181" name="GCC C Compiler" superClass="org.eclipse.linuxtools.cdt.autotools.core.toolchain.tool.gcc"/>
+							<tool id="org.eclipse.linuxtools.cdt.autotools.core.toolchain.tool.gpp.858002793" name="GCC C++ Compiler" superClass="org.eclipse.linuxtools.cdt.autotools.core.toolchain.tool.gpp"/>
+						</toolChain>
+					</folderInfo>
+				</configuration>
+			</storageModule>
+			<storageModule moduleId="org.eclipse.cdt.core.externalSettings"/>
+		</cconfiguration>
+		<cconfiguration id="org.eclipse.linuxtools.cdt.autotools.core.configuration.build.debug.1976948808">
+			<storageModule buildSystemId="org.eclipse.cdt.managedbuilder.core.configurationDataProvider" id="org.eclipse.linuxtools.cdt.autotools.core.configuration.build.debug.1976948808" moduleId="org.eclipse.cdt.core.settings" name="Debug (GNU)">
+				<externalSettings/>
+				<extensions>
+					<extension id="org.eclipse.cdt.core.MachO64" point="org.eclipse.cdt.core.BinaryParser"/>
+					<extension id="org.eclipse.cdt.core.Cygwin_PE" point="org.eclipse.cdt.core.BinaryParser"/>
+					<extension id="org.eclipse.cdt.core.PE" point="org.eclipse.cdt.core.BinaryParser"/>
+					<extension id="org.eclipse.cdt.core.GNU_ELF" point="org.eclipse.cdt.core.BinaryParser"/>
+					<extension id="org.eclipse.cdt.core.ELF" point="org.eclipse.cdt.core.BinaryParser"/>
+					<extension id="org.eclipse.cdt.core.GmakeErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GASErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GLDErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.CWDLocator" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="org.eclipse.cdt.core.GCCErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+				</extensions>
+			</storageModule>
+			<storageModule moduleId="cdtBuildSystem" version="4.0.0">
+				<configuration artifactName="${ProjName}" buildArtefactType="org.eclipse.linuxtools.cdt.autotools.core.buildArtefactType.autotools" buildProperties="org.eclipse.cdt.build.core.buildArtefactType=org.eclipse.linuxtools.cdt.autotools.core.buildArtefactType.autotools,org.eclipse.cdt.build.core.buildType=org.eclipse.linuxtools.cdt.autotools.core.buildType.debug" cleanCommand="rm -rf" description="" errorParsers="org.eclipse.cdt.core.CWDLocator;org.eclipse.cdt.core.GmakeErrorParser;org.eclipse.cdt.core.GCCErrorParser;org.eclipse.cdt.core.GLDErrorParser;org.eclipse.cdt.core.GASErrorParser" id="org.eclipse.linuxtools.cdt.autotools.core.configuration.build.debug.1976948808" name="Debug (GNU)" parent="org.eclipse.linuxtools.cdt.autotools.core.configuration.build.debug">
+					<folderInfo id="org.eclipse.linuxtools.cdt.autotools.core.configuration.build.debug.1976948808." name="/" resourcePath="">
+						<toolChain id="org.eclipse.linuxtools.cdt.autotools.core.toolChain.debug.1137846638" name="GNU Autotools Toolchain" superClass="org.eclipse.linuxtools.cdt.autotools.core.toolChain.debug">
+							<targetPlatform id="org.eclipse.linuxtools.cdt.autotools.core.toolchain.targetPlatform.debug.869561828" isAbstract="false" name="GNU Autotools Target Platform" superClass="org.eclipse.linuxtools.cdt.autotools.core.toolchain.targetPlatform.debug"/>
+							<builder id="org.eclipse.linuxtools.cdt.autotools.core.toolchain.builder.debug.371711222" managedBuildOn="true" name="Autotools Makefile Generator.Debug (GNU)" superClass="org.eclipse.linuxtools.cdt.autotools.core.toolchain.builder.debug"/>
+							<tool id="org.eclipse.linuxtools.cdt.autotools.core.gnu.toolchain.tool.configure.debug.985107447" name="configure" superClass="org.eclipse.linuxtools.cdt.autotools.core.gnu.toolchain.tool.configure.debug">
+								<option defaultValue="CFLAGS=-g -O0" id="org.eclipse.linuxtools.cdt.autotools.core.option.configure.user.811729797" superClass="org.eclipse.linuxtools.cdt.autotools.core.option.configure.user" valueType="string"/>
+							</tool>
+							<tool id="org.eclipse.linuxtools.cdt.autotools.core.toolchain.tool.autogen.debug.1464517143" name="autogen.sh" superClass="org.eclipse.linuxtools.cdt.autotools.core.toolchain.tool.autogen.debug"/>
+							<tool id="org.eclipse.linuxtools.cdt.autotools.core.toolchain.tool.gcc.debug.971302063" name="GCC C Compiler" superClass="org.eclipse.linuxtools.cdt.autotools.core.toolchain.tool.gcc.debug"/>
+							<tool id="org.eclipse.linuxtools.cdt.autotools.core.toolchain.tool.gpp.debug.890002657" name="GCC C++ Compiler" superClass="org.eclipse.linuxtools.cdt.autotools.core.toolchain.tool.gpp.debug"/>
+						</toolChain>
+					</folderInfo>
+				</configuration>
+			</storageModule>
+		</cconfiguration>
+	</storageModule>
+	<storageModule moduleId="cdtBuildSystem" version="4.0.0">
+		<project id="liblhdcDec.org.eclipse.linuxtools.cdt.autotools.core.projectType.1856320369" name="GNU Autotools" projectType="org.eclipse.linuxtools.cdt.autotools.core.projectType"/>
+	</storageModule>
+	<storageModule moduleId="scannerConfiguration">
+		<autodiscovery enabled="true" problemReportingEnabled="true" selectedProfileId=""/>
+	</storageModule>
+	<storageModule moduleId="org.eclipse.cdt.core.LanguageSettingsProviders"/>
+</cproject>
\ No newline at end of file
diff --git a/external/liblhdcdec/.project b/external/liblhdcdec/.project
new file mode 100755
index 00000000..d01fb977
--- /dev/null
+++ b/external/liblhdcdec/.project
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>liblhdcDec</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.cdt.autotools.core.genmakebuilderV2</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.genmakebuilder</name>
+			<triggers>clean,full,incremental,</triggers>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.cdt.managedbuilder.core.ScannerConfigBuilder</name>
+			<triggers>full,incremental,</triggers>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.cdt.core.cnature</nature>
+		<nature>org.eclipse.cdt.core.ccnature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.managedBuildNature</nature>
+		<nature>org.eclipse.cdt.managedbuilder.core.ScannerConfigNature</nature>
+		<nature>org.eclipse.cdt.autotools.core.autotoolsNatureV2</nature>
+	</natures>
+</projectDescription>
diff --git a/external/liblhdcdec/.settings/language.settings.xml b/external/liblhdcdec/.settings/language.settings.xml
new file mode 100755
index 00000000..c90c2e34
--- /dev/null
+++ b/external/liblhdcdec/.settings/language.settings.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<project>
+	<configuration id="org.eclipse.linuxtools.cdt.autotools.core.configuration.build.1127608133" name="Build (GNU)">
+		<extension point="org.eclipse.cdt.core.LanguageSettingsProvider">
+			<provider copy-of="extension" id="org.eclipse.cdt.ui.UserLanguageSettingsProvider"/>
+			<provider-reference id="org.eclipse.cdt.core.ReferencedProjectsLanguageSettingsProvider" ref="shared-provider"/>
+			<provider-reference id="org.eclipse.cdt.managedbuilder.core.MBSLanguageSettingsProvider" ref="shared-provider"/>
+			<provider copy-of="extension" id="org.eclipse.cdt.autotools.core.LibtoolGCCBuildCommandParser"/>
+			<provider class="org.eclipse.cdt.managedbuilder.language.settings.providers.GCCBuiltinSpecsDetector" console="false" env-hash="88064866766" id="org.eclipse.cdt.managedbuilder.core.GCCBuiltinSpecsDetector" keep-relative-paths="false" name="CDT GCC Built-in Compiler Settings" parameter="${COMMAND} ${FLAGS} -E -P -v -dD &quot;${INPUTS}&quot;" prefer-non-shared="true">
+				<language-scope id="org.eclipse.cdt.core.gcc"/>
+				<language-scope id="org.eclipse.cdt.core.g++"/>
+			</provider>
+		</extension>
+	</configuration>
+	<configuration id="org.eclipse.linuxtools.cdt.autotools.core.configuration.build.debug.1976948808" name="Debug (GNU)">
+		<extension point="org.eclipse.cdt.core.LanguageSettingsProvider">
+			<provider copy-of="extension" id="org.eclipse.cdt.ui.UserLanguageSettingsProvider"/>
+			<provider-reference id="org.eclipse.cdt.core.ReferencedProjectsLanguageSettingsProvider" ref="shared-provider"/>
+			<provider-reference id="org.eclipse.cdt.managedbuilder.core.MBSLanguageSettingsProvider" ref="shared-provider"/>
+			<provider copy-of="extension" id="org.eclipse.cdt.autotools.core.LibtoolGCCBuildCommandParser"/>
+			<provider class="org.eclipse.cdt.managedbuilder.language.settings.providers.GCCBuiltinSpecsDetector" console="false" env-hash="88064866766" id="org.eclipse.cdt.managedbuilder.core.GCCBuiltinSpecsDetector" keep-relative-paths="false" name="CDT GCC Built-in Compiler Settings" parameter="${COMMAND} ${FLAGS} -E -P -v -dD &quot;${INPUTS}&quot;" prefer-non-shared="true">
+				<language-scope id="org.eclipse.cdt.core.gcc"/>
+				<language-scope id="org.eclipse.cdt.core.g++"/>
+			</provider>
+		</extension>
+	</configuration>
+</project>
\ No newline at end of file
diff --git a/external/liblhdcdec/Android.bp b/external/liblhdcdec/Android.bp
new file mode 100755
index 00000000..eb12d27c
--- /dev/null
+++ b/external/liblhdcdec/Android.bp
@@ -0,0 +1,50 @@
+
+cc_prebuilt_library_shared {
+    name: "liblhdcdec",
+
+    export_include_dirs: ["include"],
+    arch: {
+        arm: {
+            srcs: ["libs/armeabi-v7a/liblhdcdec.so",],
+        },
+        arm64: {
+            srcs: ["libs/arm64-v8a/liblhdcdec.so",],
+        },
+    },
+
+    strip: {
+        none:true,
+    },
+
+    shared_libs: [
+        "liblog",
+        "libstdc++",
+    ],
+}
+
+cc_library_shared {
+    name: "liblhdcBT_dec",
+   // vendor_available: true,
+   // vndk: {
+   //     enabled: true,
+   // },
+    arch: {
+        arm: {
+            instruction_set: "arm",
+        },
+    },
+    export_include_dirs: ["inc"],
+    local_include_dirs: ["inc", "include", ],
+    srcs: [
+        "src/lhdcBT_dec.c",
+    ],
+    // -D_32BIT_FIXED_POINT should be added to cflags for devices without a FPU
+    // unit such as ARM Cortex-R series or external 32-bit DSPs.
+    cflags: ["-O2", "-Wall", "-Wextra", "-Wmacro-redefined"],
+
+    shared_libs: [
+        "libcutils",
+        "liblog",
+        "liblhdcdec",
+    ],
+}
diff --git a/external/liblhdcdec/inc/lhdcBT_dec.h b/external/liblhdcdec/inc/lhdcBT_dec.h
new file mode 100755
index 00000000..97beb5ed
--- /dev/null
+++ b/external/liblhdcdec/inc/lhdcBT_dec.h
@@ -0,0 +1,41 @@
+
+
+#ifndef _LHDCBT_DEC_H_
+#define _LHDCBT_DEC_H_
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "lhdcUtil.h"
+
+
+
+typedef struct  
+{
+  lhdc_ver_t version;
+  uint32_t   sample_rate;
+  uint8_t    bits_depth;
+} tLHDCV3_DEC_CONFIG;
+
+
+
+int lhdcBT_dec_init_decoder(tLHDCV3_DEC_CONFIG *config);
+int lhdcBT_dec_check_frame_data_enough(const uint8_t *frameData, uint32_t frameBytes, uint32_t *packetBytes);
+int lhdcBT_dec_decode(const uint8_t *frameData, uint32_t frameBytes, uint8_t* pcmData, uint32_t* pcmBytes, uint32_t bits_depth);
+int lhdcBT_dec_deinit_decoder(void);
+
+
+#define LHDCBT_DEC_NOT_UPD_SEQ_NO			0
+#define LHDCBT_DEC_UPD_SEQ_NO				1
+
+
+#define LHDCBT_DEC_FUNC_SUCCEED             0
+#define LHDCBT_DEC_FUNC_FAIL                -1
+#define LHDCBT_DEC_FUNC_INPUT_NOT_ENOUGH    -2
+#define LHDCBT_DEC_FUNC_OUTPUT_NOT_ENOUGH   -3
+#define LHDCBT_DEC_FUNC_INVALID_SEQ_NO		-4
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _LHDCBT_DEC_H_ */
diff --git a/external/liblhdcdec/include/lhdcUtil.h b/external/liblhdcdec/include/lhdcUtil.h
new file mode 100755
index 00000000..6a08e540
--- /dev/null
+++ b/external/liblhdcdec/include/lhdcUtil.h
@@ -0,0 +1,101 @@
+/*
+ * lhdcUtil.h
+ *
+ *  Created on: 2001/1/3
+ *      Author: eric.lee
+ */
+
+#ifndef LHDC_UTIL_H
+#define LHDC_UTIL_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+
+
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+// Copy definition from external
+#define BTIF_BD_ADDR_SIZE    6
+
+
+// Define for LHDC stream type.
+typedef enum {
+    LHDC_STRM_TYPE_COMBINE,
+    LHDC_STRM_TYPE_SPLIT
+}LHDC_STRM_TYPE;
+
+typedef enum {
+  VERSION_2 = 200,
+  VERSION_3 = 300,
+  VERSION_4 = 400,
+  VERSION_LLAC = 500
+}lhdc_ver_t;
+
+typedef enum {
+  LHDCV2_BLOCK_SIZE = 512,
+  LHDCV3_BLOCK_SIZE = 256,
+}lhdc_block_size_t;
+
+typedef struct savi_bt_local_info_t{
+    uint8_t bt_addr[BTIF_BD_ADDR_SIZE];
+    const char *bt_name;
+    uint8_t bt_len;
+    uint8_t ble_addr[BTIF_BD_ADDR_SIZE];
+    const char *ble_name;
+    uint8_t ble_len;
+}savi_bt_local_info;
+
+typedef struct _lhdc_frame_Info
+{
+    uint32_t frame_len; //  frame  frame 
+    uint32_t isSplit;   // 
+    uint32_t isLeft;    //  == true  == false
+
+} lhdc_frame_Info_t;
+
+
+typedef enum {
+    LHDC_OUTPUT_STEREO = 0,
+    LHDC_OUTPUT_LEFT_CAHNNEL,
+    LHDC_OUTPUT_RIGHT_CAHNNEL,
+} lhdc_channel_t;
+
+typedef int LHDCSample;
+
+typedef void (*print_log_fp)(char*  msg);
+typedef int (*LHDC_GET_BT_INFO)(savi_bt_local_info * bt_info);
+
+
+
+#define A2DP_LHDC_HDR_LATENCY_LOW   0x00
+#define A2DP_LHDC_HDR_LATENCY_MID   0x01
+#define A2DP_LHDC_HDR_LATENCY_HIGH  0x02
+#define A2DP_LHDC_HDR_LATENCY_MASK  (A2DP_LHDC_HDR_LATENCY_MID | A2DP_LHDC_HDR_LATENCY_HIGH)
+
+#define A2DP_LHDC_HDR_FRAME_NO_MASK 0xfc
+
+
+void lhdcInit(uint32_t bitPerSample, uint32_t sampleRate, uint32_t scaleTo16Bits, lhdc_ver_t version);
+
+uint32_t lhdcDecodeProcess(uint8_t * pOutBuf, uint8_t * pInput, uint32_t len);
+bool lhdcSetLicenseKeyTable(uint8_t * licTable, LHDC_GET_BT_INFO pFunc);
+void lhdcSetLicenseKeyChkPeriod (uint8_t period);
+char * getVersionCode();
+
+void lhdcDestroy();
+
+void lhdc_register_log_cb(print_log_fp cb);
+
+uint32_t lhdcGetSampleSize( void);
+bool lhdcFetchFrameInfo(uint8_t * frameData, lhdc_frame_Info_t * frameInfo);
+
+uint32_t lhdcChannelSelsect(lhdc_channel_t channel_type);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* End of LHDC_UTIL_H */
diff --git a/external/liblhdcdec/libs/arm64-v8a/liblhdcdec.so b/external/liblhdcdec/libs/arm64-v8a/liblhdcdec.so
new file mode 100755
index 00000000..7452fbff
Binary files /dev/null and b/external/liblhdcdec/libs/arm64-v8a/liblhdcdec.so differ
diff --git a/external/liblhdcdec/libs/armeabi-v7a/liblhdcdec.so b/external/liblhdcdec/libs/armeabi-v7a/liblhdcdec.so
new file mode 100755
index 00000000..54410f50
Binary files /dev/null and b/external/liblhdcdec/libs/armeabi-v7a/liblhdcdec.so differ
diff --git a/external/liblhdcdec/release_note b/external/liblhdcdec/release_note
new file mode 100755
index 00000000..5a42cb9e
--- /dev/null
+++ b/external/liblhdcdec/release_note
@@ -0,0 +1,8 @@
+Release Note.
+=========================================================
+2022/05/11
+1. Upgrade LHDCV4 decoder version to V4.0.2
+
+2021/11/22
+Add LHDC v3/v4 Decoder
+
diff --git a/external/liblhdcdec/src/lhdcBT_dec.c b/external/liblhdcdec/src/lhdcBT_dec.c
new file mode 100755
index 00000000..fa20c66b
--- /dev/null
+++ b/external/liblhdcdec/src/lhdcBT_dec.c
@@ -0,0 +1,405 @@
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include "lhdcBT_dec.h"
+
+
+#define LOG_NDEBUG 0
+#define LOG_TAG "lhdcBT_dec"
+#include <cutils/log.h>
+
+static uint8_t serial_no = 0xff;
+
+static int assemble_lhdc_packet(uint8_t *input, uint32_t input_len, uint8_t **pLout, uint32_t *pLlen, int upd_seq_no);
+
+// description
+//   a function to log information in LHDC decoder library
+// Parameter
+//   config: configuration data for LHDC v4 decoder
+// return:
+//   == 0: succeed
+//   < 0: error
+static void print_log_cb(char*  msg)
+{
+	if (msg == NULL)
+	{
+		return;
+	}
+
+    ALOGD("[WL50-ex] %s: %s", __func__, msg);
+}
+
+// description
+//   init. LHDC v4 decoder 
+// Parameter
+//   config: configuration data for LHDC v4 decoder
+// return:
+//   == 0: succeed
+//   < 0: error
+int lhdcBT_dec_init_decoder(tLHDCV3_DEC_CONFIG *config)
+{
+	//ALOGD("[WL50] %s: enter", __func__);
+    if (config == NULL)
+	{
+		return LHDCBT_DEC_FUNC_FAIL;
+	}
+
+    //ALOGD("[WL50] %s: bits_depth:%d sample_rate=%d version=%d", __func__,	config->bits_depth, config->sample_rate, config->version);
+
+    if ((config->bits_depth != 16) && (config->bits_depth != 24))
+	{
+		return LHDCBT_DEC_FUNC_FAIL;
+	}
+
+    if ((config->sample_rate != 44100) && (config->sample_rate != 48000) &&
+	    (config->sample_rate != 96000))
+	{
+		return LHDCBT_DEC_FUNC_FAIL;
+	}
+
+    if ((config->version != VERSION_3) && (config->version != VERSION_4) &&
+	    (config->version != VERSION_LLAC))
+	{
+		return LHDCBT_DEC_FUNC_FAIL;
+	}
+
+	lhdc_register_log_cb(&print_log_cb);
+
+    //ALOGD("[WL50] %s: start lhdcInit..", __func__);
+    lhdcInit(config->bits_depth, config->sample_rate, 400000, config->version);
+
+    lhdcChannelSelsect(LHDC_OUTPUT_STEREO);
+
+    serial_no = 0xff;
+    //ALOGD("[WL50] %s: end", __func__);
+	return LHDCBT_DEC_FUNC_SUCCEED;
+}
+
+
+
+// description
+//   check whether all frames of one packet are in buffer?
+// Parameter
+//   frameData: pointer to input buffer
+//   frameBytes: length (bytes) of input buffer pointed by frameData
+// return:
+//   == 0: succeed
+//   < 0: error
+int lhdcBT_dec_check_frame_data_enough(const uint8_t *frameData, uint32_t frameBytes, uint32_t *packetBytes)
+{
+	uint8_t *frameDataStart = (uint8_t *)frameData;
+    uint8_t *in_buf = NULL;
+    uint32_t in_len = 0;
+	uint32_t frame_num = 0;
+	lhdc_frame_Info_t lhdc_frame_Info;
+	uint32_t ptr_offset = 0;
+	bool fn_ret;
+
+
+    ALOGD("[WL50] %s: enter, frameBytes (%d)", __func__, (int)frameBytes);
+
+	if ((frameData == NULL) || (packetBytes == NULL))
+	{
+		return LHDCBT_DEC_FUNC_FAIL;
+	}
+	
+	*packetBytes = 0;
+
+    frame_num = assemble_lhdc_packet(frameDataStart, frameBytes, &in_buf, &in_len, LHDCBT_DEC_NOT_UPD_SEQ_NO);
+    if (frame_num == 0)
+	{
+        ALOGD("%s: assemble_lhdc_packet (%d)", __func__, (int)frame_num);
+		return LHDCBT_DEC_FUNC_SUCCEED;
+	}
+	//else if (frame_num < 0)
+	//{
+	//	// Fail to check packet header (including invalid packet number)!
+	//	return frame_num;
+	//}
+	
+	ALOGD("[WL50] %s: in_buf (%p), frameData (%p), in_len (%d), frame_num (%d)", __func__, in_buf, frameData, (int)in_len, (int) frame_num);
+	
+	ptr_offset = 0;
+
+	while ((frame_num > 0) && (ptr_offset < in_len))
+	{
+		fn_ret = lhdcFetchFrameInfo (in_buf + ptr_offset, &lhdc_frame_Info);
+		if (fn_ret == false)
+		{
+			ALOGD("[WL50] %s: lhdcFetchFrameInfo(%d) fail..", __func__, (int)frame_num);
+			return LHDCBT_DEC_FUNC_FAIL;
+		}
+		
+		ALOGD("[WL50] %s: lhdcFetchFrameInfo  frame_num (%d), ptr_offset (%d), lhdc_frame_Info.frame_len (%d), in_len (%d)", __func__, (int)frame_num, (int)ptr_offset, (int)lhdc_frame_Info.frame_len, (int)in_len);
+		
+		if ((ptr_offset + lhdc_frame_Info.frame_len) > in_len)
+		{
+			ALOGD("[WL50] %s: Not Enough... frame_num(%d), ptr_offset(%d), frame_len(%d), in_len (%d)", __func__, (int)frame_num, (int)ptr_offset, (int)lhdc_frame_Info.frame_len, (int)in_len);
+			return LHDCBT_DEC_FUNC_INPUT_NOT_ENOUGH;
+		}
+
+        ptr_offset += lhdc_frame_Info.frame_len;
+
+        frame_num--;
+	}
+
+
+	*packetBytes = ptr_offset;
+
+    ALOGD("[WL50] %s: end ", __func__);
+    return LHDCBT_DEC_FUNC_SUCCEED;
+
+}
+
+
+/*
+	uint8_t llac_test_ptn[0x100] = {
+		0x90, 0x01, 0x04, 0xF7, 0x7C, 0x65, 0xEA, 0x83, 
+		0xBB, 0x66, 0x4B, 0xA0, 0xF6, 0x51, 0xB8, 0x48, 
+		0x0C, 0xE7, 0x9D, 0xB9, 0x3B, 0x28, 0x0E, 0x82, 
+		0x73, 0xC6, 0xD7, 0xF9, 0xFC, 0x60, 0x34, 0xA9, 
+		0xEA, 0x46, 0x03, 0xD4, 0xA9, 0x63, 0x41, 0x30, 
+		0x37, 0x54, 0xBF, 0x47, 0x61, 0xAD, 0x7A, 0xB7, 
+		0xF0, 0x6E, 0x49, 0x00, 0xC7, 0xF9, 0xC6, 0x23, 
+		0x99, 0x01, 0xA1, 0x08, 0x79, 0xF4, 0x53, 0xC2, 
+		0xDF, 0xD8, 0x6F, 0x81, 0xB9, 0x8D, 0x65, 0x71, 
+		0xA2, 0x77, 0xF7, 0x0C, 0x65, 0x2D, 0x78, 0x80, 
+		0xA8, 0xBA, 0xC0, 0xA0, 0xD4, 0x98, 0xB4, 0xF5, 
+		0xB3, 0x6C, 0x61, 0x14, 0xD4, 0x93, 0xA5, 0x2D, 
+		0x07, 0x4D, 0x49, 0x1B, 0x78, 0x9F, 0x4E, 0xC7, 
+		0x28, 0x15, 0x35, 0x2E, 0x00, 0x44, 0xD5, 0x62, 
+		0xA3, 0x95, 0x86, 0xE4, 0xDC, 0x9E, 0xD7, 0xAC, 
+		0xC0, 0x90, 0x6D, 0x62, 0xED, 0xBA, 0x4A, 0x89, 
+		0xAE, 0x7F, 0x50, 0xC6, 0xAD, 0x57, 0xBA, 0x47, 
+		0xBA, 0x45, 0xEC, 0x0F, 0x99, 0xA6, 0xA0, 0x3F, 
+		0xBD, 0x14, 0xAA, 0xBD, 0x74, 0x5B, 0x49, 0x7E, 
+		0xF9, 0xD1, 0xB7, 0x6A, 0x4F, 0xF3, 0x31, 0xD9, 
+		0x3D, 0x79, 0xBF, 0x79, 0x1C, 0x99, 0x74, 0xD7, 
+		0x1B, 0x3B, 0x04, 0xF9, 0x61, 0xB4, 0xC3, 0x7B, 
+		0x86, 0x6B, 0x5A, 0x6F, 0xAD, 0x95, 0xB2, 0xD7, 
+		0x6D, 0xCC, 0xC8, 0x33, 0x0D, 0x87, 0xC6, 0x06, 
+		0xFC, 0xD1, 0x17, 0x8C, 0xD0, 0x33, 0x37, 0x55, 
+		0xA1, 0x07, 0x6F, 0x70, 0xD1, 0x97, 0x2A, 0x97, 
+		0x44, 0xE8, 0x8A, 0xBA, 0xC1, 0x28, 0xA9, 0x23, 
+		0x54, 0xD8, 0x89, 0x63, 0x56, 0x8B, 0x32, 0xA6, 
+		0x38, 0xA1, 0xFA, 0x83, 0x87, 0x2A, 0x2B, 0x6F, 
+		0xD7, 0x8E, 0x18, 0x79, 0xEC, 0x53, 0xAE, 0x10, 
+		0xC8, 0xF6, 0x49, 0xD7, 0xA2, 0xC5, 0x00, 0xED, 
+		0x62, 0xFD, 0xBA, 0x48, 0x00, 0x00, 0x00, 0x00};
+	uint8_t llac_ptn[0x100];
+*/
+
+// description
+//   decode all frames in one packet
+// Parameter
+//   frameData: pointer to input buffer
+//   frameBytes: length (bytes) of input buffer pointed by frameData
+//   pcmData: pointer to output buffer
+//   pcmBytes: length (bytes) of pcm samples in output buffer
+// return:
+//   == 0: succeed
+//   < 0: error
+int lhdcBT_dec_decode(const uint8_t *frameData, uint32_t frameBytes, uint8_t* pcmData, uint32_t* pcmBytes, uint32_t bits_depth)
+{
+	uint8_t *frameDataStart = (uint8_t *)frameData;
+    uint32_t dec_sum = 0;
+	uint32_t lhdc_out_len = 0;
+    uint8_t *in_buf = NULL;
+    uint32_t in_len = 0;
+	uint32_t frame_num = 0;
+	lhdc_frame_Info_t lhdc_frame_Info;
+	uint32_t ptr_offset = 0;
+	bool fn_ret;
+    uint32_t frame_samples;
+	uint32_t frame_bytes;
+	uint32_t pcmSpaceBytes;
+
+    //ALOGD("[WL50] %s: enter, assemble_lhdc_packet(frameBytes %d)", __func__, (int)frameBytes);
+
+    if ((frameData == NULL) || 
+	    (pcmData == NULL) ||
+		(pcmBytes == NULL))
+	{
+		return LHDCBT_DEC_FUNC_FAIL;
+	}
+
+    pcmSpaceBytes = *pcmBytes;
+	*pcmBytes = 0;
+
+/*
+    if(frameBytes >= 16)
+    {
+		for(int i=0; i<16; i++)
+		{
+			ALOGD("[WL50] %s: dumpFrame[%d]= 0x%02X", __func__, i, (int)*(frameDataStart+i));
+		}
+    }
+    else
+    {
+		for(int i=0; i<(int)frameBytes; i++)
+		{
+			ALOGD("[WL50] %s: dumpFrame[%d]= 0x%02X", __func__, i, (int)*(frameDataStart+i));
+		}
+    }
+*/
+
+    frame_num = assemble_lhdc_packet(frameDataStart, frameBytes, &in_buf, &in_len, LHDCBT_DEC_UPD_SEQ_NO);
+    if (frame_num == 0)
+	{
+		return LHDCBT_DEC_FUNC_SUCCEED;
+	}
+	//ALOGD("[WL50] %s: frameData=0x%p, in_buf=0x%p, in_len=%d", __func__, frameData, in_buf, in_len);
+    //ALOGD("[WL50] %s: get frame_num=%d", __func__, (int)frame_num);
+
+    frame_samples = lhdcGetSampleSize ();
+	if (bits_depth == 16)
+	{
+		frame_bytes = frame_samples * 2 * 2;
+	}
+	else
+	{
+		frame_bytes = frame_samples * 4 * 2;
+	}
+    ALOGD("[WL50] %s: frame_samples=%d", __func__, (int)frame_samples);
+
+    ptr_offset = 0;
+    dec_sum = 0;
+
+	while ((frame_num > 0) && (ptr_offset < in_len))
+	{
+		fn_ret = lhdcFetchFrameInfo (in_buf + ptr_offset, &lhdc_frame_Info);
+		if (fn_ret == false)
+		{
+			//ALOGD("[WL50] %s: lhdcFetchFrameInfo(%d) fail..", __func__, (int)frame_num);
+			return LHDCBT_DEC_FUNC_FAIL;
+		}
+
+		if ((ptr_offset + lhdc_frame_Info.frame_len) > in_len)
+		{
+			return LHDCBT_DEC_FUNC_INPUT_NOT_ENOUGH;
+		}
+
+		if ((dec_sum + frame_bytes) > pcmSpaceBytes)
+		{
+			return LHDCBT_DEC_FUNC_OUTPUT_NOT_ENOUGH;
+		}
+
+ 		//ALOGD("[WL50] %s: get ptr_offset=%d, dec_sum=%d", __func__, ptr_offset, dec_sum);
+        lhdc_out_len = lhdcDecodeProcess(((uint8_t *)pcmData) + dec_sum, in_buf + ptr_offset, lhdc_frame_Info.frame_len);
+        //ALOGD("[WL50] %s: lhdcDecodeProcess(frm=%d, frame_len=%d out_len=%d)..", __func__, (int)frame_num, (int)lhdc_frame_Info.frame_len, (int)lhdc_out_len);
+
+        //if (lhdc_out_len % frame_samples)
+        //{
+        //    TRACE_A2DP_DECODER_I("[CP][LHDC]error!!! dec_sum: %d decode_temp: %d", dec_sum, lhdc_decode_temp);
+        //    return LHDCBT_DEC_FUNC_FAIL;
+        //}
+
+        ptr_offset += lhdc_frame_Info.frame_len;
+        dec_sum += lhdc_out_len;
+
+        frame_num--;
+	}
+
+    *pcmBytes = (uint32_t) dec_sum;
+
+    //ALOGD("[WL50] %s: end (dec_sum=%d pcmBytes=%d)", __func__, (int)dec_sum, (int)*pcmBytes);
+    return LHDCBT_DEC_FUNC_SUCCEED;
+}
+
+
+// description
+//   de-initialize (free) all resources allocated by LHDC v4 decoder
+// Parameter
+//   none
+// return:
+//   == 0: succceed
+int lhdcBT_dec_deinit_decoder(void)
+{
+	ALOGD("[WL50] %s: enter", __func__);
+    lhdcDestroy();
+
+    return LHDCBT_DEC_FUNC_SUCCEED;
+}
+
+// description
+//   check number of frames in one packet and return pointer to first byte of 1st frame in current packet
+// Parameter
+//   input: pointer to input buffer
+//   input_len: length (bytes) of input buffer pointed by input
+//   pLout: pointer to pointer to output buffer
+//   pLlen: length (bytes) of encoded stream in output buffer
+// return:
+//   > 0: number of frames in current packet
+//   == 0: No frames in current packet
+//   < 0: error
+static int assemble_lhdc_packet(uint8_t *input, uint32_t input_len, uint8_t **pLout, uint32_t *pLlen, int upd_seq_no)
+{
+    uint8_t hdr = 0, seqno = 0xff;
+    int ret = LHDCBT_DEC_FUNC_FAIL;
+    uint32_t status = 0;
+	uint32_t lhdc_total_frame_nb = 0;
+
+
+    if ((input == NULL) || 
+		(pLout == NULL) || 
+		(pLlen == NULL)) 
+	{
+
+		return LHDCBT_DEC_FUNC_FAIL;
+	}
+	
+	if (input_len < 2)
+	{
+		return LHDCBT_DEC_FUNC_FAIL;
+	}
+
+    hdr = (*input);
+    input++;
+    seqno = (*input);
+    input++;
+    input_len -= 2;
+
+    //Check latency and update value when changed.
+    status = hdr & A2DP_LHDC_HDR_LATENCY_MASK;
+
+    //Get number of frame in packet.
+    status = (hdr & A2DP_LHDC_HDR_FRAME_NO_MASK) >> 2;
+
+    ALOGD("[WL50] %s: enter", __func__);
+
+    if (status <= 0)
+    {
+        ALOGD("%s: No any frame in packet.", __func__);
+        return 0;
+    }
+
+
+    lhdc_total_frame_nb = status;
+
+    if (seqno != serial_no)
+    {
+        ALOGD("%s: Packet lost! now(%d), expect(%d)", __func__, seqno, serial_no);
+        //serial_no = seqno;
+		//return LHDCBT_DEC_FUNC_INVALID_SEQ_NO;
+    }
+	
+	if (upd_seq_no == LHDCBT_DEC_UPD_SEQ_NO)
+	{
+        serial_no = seqno + 1;
+	}
+
+    // log average bit rate
+    //sav_lhdc_log_bytes_len(input_len);
+
+    *pLlen = input_len;
+    *pLout = input;
+
+    ret = (int) lhdc_total_frame_nb;
+
+    ALOGD("[WL50] %s: end frame number (%d)", __func__, ret);
+    return ret;
+}
+
diff --git a/external/liblhdcv5/Android.bp b/external/liblhdcv5/Android.bp
new file mode 100755
index 00000000..b8fe3fa6
--- /dev/null
+++ b/external/liblhdcv5/Android.bp
@@ -0,0 +1,50 @@
+
+cc_prebuilt_library_shared {
+    name: "liblhdcv5",
+
+    export_include_dirs: ["include"],
+    arch: {
+        arm: {
+            srcs: ["libs/armeabi-v7a/liblhdcv5.so",],
+        },
+        arm64: {
+            srcs: ["libs/arm64-v8a/liblhdcv5.so",],
+        },
+    },
+
+    strip: {
+        none:true,
+    },
+
+    shared_libs: [
+        "liblog",
+        "libstdc++",
+    ],
+}
+
+cc_library_shared {
+    name: "liblhdcv5BT_enc",
+   // vendor_available: true,
+   // vndk: {
+   //     enabled: true,
+   // },
+    arch: {
+        arm: {
+            instruction_set: "arm",
+        },
+    },
+    export_include_dirs: ["inc"],
+    local_include_dirs: ["inc", "include", ],
+    srcs: [
+        "src/lhdcv5BT_enc.c",
+    ],
+    // -D_32BIT_FIXED_POINT should be added to cflags for devices without a FPU
+    // unit such as ARM Cortex-R series or external 32-bit DSPs.
+    cflags: ["-O2", "-Wall", "-Wextra", "-Wmacro-redefined"],
+
+    shared_libs: [
+        "libcutils",
+        "liblog",
+        "liblhdcv5",
+    ],
+}
diff --git a/external/liblhdcv5/CHANGES b/external/liblhdcv5/CHANGES
new file mode 100755
index 00000000..10de496d
--- /dev/null
+++ b/external/liblhdcv5/CHANGES
@@ -0,0 +1,7 @@
+Release Note.
+=========================================================
+Jul 20, 2022, by jimmy.chen@savitech.co
+  Summary for 5.0.5 liblhdcv5 release  
+  
+Feb 21, 2022, by jimmy.chen@savitech.co
+  Summary for 5.0.1 liblhdcv5 release
\ No newline at end of file
diff --git a/external/liblhdcv5/LICENSE b/external/liblhdcv5/LICENSE
new file mode 100755
index 00000000..261eeb9e
--- /dev/null
+++ b/external/liblhdcv5/LICENSE
@@ -0,0 +1,201 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/external/liblhdcv5/MODULE_LICENSE_APACHE2 b/external/liblhdcv5/MODULE_LICENSE_APACHE2
new file mode 100755
index 00000000..e69de29b
diff --git a/external/liblhdcv5/NOTICE b/external/liblhdcv5/NOTICE
new file mode 100755
index 00000000..ea044d3b
--- /dev/null
+++ b/external/liblhdcv5/NOTICE
@@ -0,0 +1,27 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *****************************************************************************
+ * Originally developed and contributed by Ittiam Systems Pvt. Ltd, Bangalore
+ */
+
+---------------
+ Certification
+---------------
+   Taking the certification process is required to use LHDC in your products.
+   For the detail of certification process, see the following URL:
+      https://www.savitech.co/
+
diff --git a/external/liblhdcv5/inc/lhdcv5BT.h b/external/liblhdcv5/inc/lhdcv5BT.h
new file mode 100755
index 00000000..c955b3bc
--- /dev/null
+++ b/external/liblhdcv5/inc/lhdcv5BT.h
@@ -0,0 +1,127 @@
+#ifndef _LHDCV5BT_H_
+#define _LHDCV5BT_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "lhdcv5_api.h"
+
+int32_t lhdcv5BT_free_handle 
+(
+    HANDLE_LHDCV5_BT	handle
+);
+
+int32_t lhdcv5BT_get_handle 
+(
+    uint32_t			version,
+    HANDLE_LHDCV5_BT	*handle
+);
+
+int32_t lhdcv5BT_get_bitrate
+(
+    HANDLE_LHDCV5_BT	handle,
+    uint32_t			* bitrate
+);
+
+int32_t lhdcv5BT_set_bitrate
+(
+    HANDLE_LHDCV5_BT 	handle,
+    uint32_t			bitrate_inx
+);
+
+int32_t lhdcv5BT_set_max_bitrate
+(
+    HANDLE_LHDCV5_BT	handle,
+    uint32_t			max_bitrate_inx
+);
+
+int32_t lhdcv5BT_set_min_bitrate
+(
+    HANDLE_LHDCV5_BT 	handle,
+    uint32_t			min_bitrate_inx
+);
+
+int32_t lhdcv5BT_adjust_bitrate
+(
+    HANDLE_LHDCV5_BT 	handle,
+    uint32_t			queueLen
+);
+
+int32_t lhdcv5BT_set_ext_func_state
+(
+    HANDLE_LHDCV5_BT 	handle,
+    LHDCV5_EXT_FUNC_T	field,
+    bool 				enabled,
+    void 				* priv,
+    uint32_t 			priv_data_len
+);
+
+int32_t lhdcv5BT_init_encoder
+(
+    HANDLE_LHDCV5_BT 	handle,
+    uint32_t 			sampling_freq,
+    uint32_t 			bits_per_sample,
+    uint32_t 			bitrate_inx,
+    uint32_t 			mtu,
+    uint32_t 			interval
+) ;
+
+int32_t lhdcv5BT_get_block_Size
+(
+    HANDLE_LHDCV5_BT	handle,
+    uint32_t			* samples_per_frame
+);
+
+int32_t lhdcv5BT_encode
+(
+    HANDLE_LHDCV5_BT 	handle,
+    void				* p_in_pcm,
+    uint32_t			pcm_bytes,
+    uint8_t				* p_out_buf,
+    uint32_t			out_buf_bytes,
+    uint32_t 			* p_out_bytes,
+    uint32_t 			* p_out_frames
+);
+
+//
+// LHDCV5 Extended APIs
+//
+// Extended API -- Get Version
+int lhdcv5BT_get_user_exApiver
+(
+    HANDLE_LHDCV5_BT handle,
+    char *userConfig,
+    int clen
+);
+
+// Extended API -- Get User Config
+int lhdcv5BT_get_user_exconfig
+(
+    HANDLE_LHDCV5_BT handle,
+    char* userConfig,
+    int clen
+);
+
+// Extended API -- Set User Config
+int lhdcv5BT_set_user_exconfig
+(
+    HANDLE_LHDCV5_BT handle,
+    const char* userConfig,
+    const int clen
+);
+
+// Extended API -- Set User Data
+void lhdcv5BT_set_user_exdata
+(
+    HANDLE_LHDCV5_BT handle,
+    const char* userConfig,
+    const int clen
+);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _LHDCV5BT_H_ */
diff --git a/external/liblhdcv5/include/lhdcv5BT_ext_func.h b/external/liblhdcv5/include/lhdcv5BT_ext_func.h
new file mode 100755
index 00000000..f8612162
--- /dev/null
+++ b/external/liblhdcv5/include/lhdcv5BT_ext_func.h
@@ -0,0 +1,188 @@
+
+
+#ifndef _LHDCBT_EXT_FUNC_H_
+#define _LHDCBT_EXT_FUNC_H_
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#define EXTEND_FUNC_RET_OK                      ((int) 0)
+#define EXTEND_FUNC_RET_INVALID_HANDLE          ((int) 0xE01)
+#define EXTEND_FUNC_RET_INVALID_PARAMETER       ((int) 0xE02)
+#define EXTEND_FUNC_RET_FUNC_NOT_SUPPORT        ((int) 0xE03)
+#define EXTEND_FUNC_RET_VERSION_NOT_SUPPORT     ((int) 0xE04)
+#define EXTEND_FUNC_RET_BUF_UNDERRUN            ((int) 0xE05)
+#define EXTEND_FUNC_RET_ERROR                   ((int) 0xE06)
+#define EXTEND_FUNC_RET_NOT_READY               ((int) 0xE07)
+#define EXTEND_FUNC_RET_REQ_BUFSIZE_NOT_MATCH   ((int) 0xE08)
+
+
+/* **********************************************
+ *  API: Version Control
+ * ***********************************************/
+#define EXTEND_FUNC_GENERIC_VERSION_NUMBER_V1               ((unsigned int) 0x01000000)
+#define EXTEND_FUNC_GENERIC_VERSION_NUMBER_V2               ((unsigned int) 0x02000000)
+#define EXTEND_FUNC_MIN_BUFFER_LEN                          (8)
+
+/* **********************************************
+ *  LIB API: Config Type
+ * ***********************************************/
+/* * * * * * * * * * * * * * * *
+ *   META                      *
+ * * * * * * * * * * * * * * * */
+//   META :: API Code
+#define EXTEND_FUNC_CODE_SET_CONFIG_META        ((unsigned int) 0x0C000001)
+#define EXTEND_FUNC_CODE_GET_CONFIG_META        ((unsigned int) 0x0C010001)
+//   META :: API Version
+#define EXTEND_FUNC_VER_SET_CONFIG_META_V1      ((unsigned int) 0x01000000)
+#define EXTEND_FUNC_VER_SET_CONFIG_META_V2      ((unsigned int) 0x02000000)
+#define EXTEND_FUNC_VER_GET_CONFIG_META_V1      ((unsigned int) 0x01000000)
+#define EXTEND_FUNC_VER_GET_CONFIG_META_V2      ((unsigned int) 0x02000000)
+//   META :: API Min Required Buffer Size
+#define EXTEND_FUNC_VER_SET_CONFIG_META_REQ_BUFSIZE_V2      16  //TBD
+#define EXTEND_FUNC_VER_GET_CONFIG_META_REQ_BUFSIZE_V2      16  //TBD
+
+/* * * * * * * * * * * * * * * *
+ *   AR                        *
+ * * * * * * * * * * * * * * * */
+//   AR :: API Code
+#define EXTEND_FUNC_CODE_SET_CONFIG_AR          ((unsigned int) 0x0C000002)
+#define EXTEND_FUNC_CODE_GET_CONFIG_AR          ((unsigned int) 0x0C010002)
+//   AR :: API Version
+#define EXTEND_FUNC_VER_SET_CONFIG_AR_V1        ((unsigned int) 0x01000000)
+#define EXTEND_FUNC_VER_SET_CONFIG_AR_V2        ((unsigned int) 0x02000000)
+#define EXTEND_FUNC_VER_SET_CONFIG_AR_V3        ((unsigned int) 0x03000000)
+#define EXTEND_FUNC_VER_GET_CONFIG_AR_V1        ((unsigned int) 0x01000000)
+#define EXTEND_FUNC_VER_GET_CONFIG_AR_V2        ((unsigned int) 0x02000000)
+//   AR :: API Min Required Buffer Size
+#define EXTEND_FUNC_VER_SET_CONFIG_AR_REQ_BUFSIZE_V2      16    //TBD
+#define EXTEND_FUNC_VER_GET_CONFIG_AR_REQ_BUFSIZE_V2      16    //TBD
+
+
+/* **********************************************
+ *  LIB API: Data Type
+ * ***********************************************/
+/* * * * * * * * * * * * * * * *
+ *   GYRO2D                    *
+ * * * * * * * * * * * * * * * */
+//   GYRO2D :: API Code
+#define EXTEND_FUNC_CODE_SET_DATA_GYRO2D        ((unsigned int) 0x0D000001)
+//   GYRO2D :: API Version
+#define EXTEND_FUNC_VER_SET_DATA_GYRO2D_V1      ((unsigned int) 0x01000000)
+#define EXTEND_FUNC_VER_SET_DATA_GYRO2D_V2      ((unsigned int) 0x02000000)
+//   GYRO2D :: API Min Required Buffer Size
+#define EXTEND_FUNC_VER_SET_DATA_GYRO2D_REQ_BUFSIZE_V2      16    //TBD (8 + 2gyro + 6pad)
+
+
+/* * * * * * * * * * * * * * * *
+ *   GetA2DPSpecifis           *
+ * * * * * * * * * * * * * * * */
+//   GetA2DPSpecifis :: API Code
+#define EXTEND_FUNC_CODE_GET_SPECIFIC           ((unsigned int) 0x0A010001)
+//   GetA2DPSpecifis :: API Version
+#define EXTEND_FUNC_VER_GET_SPECIFIC_V2         ((unsigned int) 0x02000000)
+
+//
+// META
+//
+#define META_ST_VER_V1                           ((unsigned int) 0x00010000)
+#define META_ST_VER_V2                           ((unsigned int) 0x00020000)
+#pragma pack (push)
+#pragma pack (1)
+typedef struct __ST_LHDC_SET_META {
+
+  unsigned char     header[8];
+  unsigned int      meta_ver;
+  unsigned char     meta_mem_size;
+  unsigned char     meta_enable;
+  unsigned char     meta_set;
+  unsigned char     meta_metadata_length;
+  //  unsigned char     meta_metadata[64];
+
+} ST_LHDC_SET_META, *PST_LHDC_SET_META;
+#pragma pack(pop)
+
+#pragma pack (push)
+#pragma pack (1)
+typedef struct __ST_LHDC_GET_META {
+
+  unsigned char     header[8];
+  unsigned int      meta_ver;
+  unsigned char     meta_mem_size;
+  unsigned char     meta_st;     // [0] 1: reserved bit, [1] 1: in meta mode/0: not in meta mode
+  unsigned char     jas_status;
+
+} ST_LHDC_GET_META, *PST_LHDC_GET_META;
+#pragma pack(pop)
+
+//
+// AR
+//
+
+#pragma pack (push)
+#pragma pack (1)
+typedef struct __ST_LHDC_AR
+{
+  unsigned char     header[8];
+  unsigned int      ver;
+  unsigned int      size;
+  unsigned int      app_ar_enabled;
+  int Ch1_Pos;
+  int Ch2_Pos;
+  int Ch3_Pos;
+  int Ch4_Pos;
+  int Ch5_Pos;
+  int Ch6_Pos;
+  float Ch1_L_PreGain;
+  float Ch1_R_PreGain;
+  float Ch2_L_PreGain;
+  float Ch2_R_PreGain;
+  float Ch3_L_PreGain;
+  float Ch3_R_PreGain;
+  float Ch4_L_PreGain;
+  float Ch4_R_PreGain;
+  float Ch5_L_PreGain;
+  float Ch5_R_PreGain;
+  float Ch6_L_PreGain;
+  float Ch6_R_PreGain;
+  float Ch1_PostGain;
+  float Ch2_PostGain;
+  float Ch3_PostGain;
+  float Ch4_PostGain;
+  float Ch5_PostGain;
+  float Ch6_PostGain;
+  float Dry_Val;
+  float Wet_Val;
+  float Dis_1;
+  float Dis_2;
+  float Dis_3;
+  float Dis_4;
+  float Dis_5;
+  float Rev_1;
+  float Rev_2;
+  float Rev_3;
+  float Rev_4;
+  float Rev_5;
+  float Rev_gain;
+  float ThreeD_gain;
+} ST_LHDC_AR, *PST_LHDC_AR;
+#pragma pack(pop)
+
+#pragma pack (push)
+#pragma pack (1)
+typedef struct __ST_LHDC_AR_GYRO
+{
+  unsigned char     header[8];
+  int world_coordinate_x;
+  int world_coordinate_y;
+  int world_coordinate_z;
+
+} ST_LHDC_AR_GYRO, *PST_LHDC_AR_GYRO;
+#pragma pack(pop)
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _LHDCBT_EXT_FUNC_H_ */
diff --git a/external/liblhdcv5/include/lhdcv5_api.h b/external/liblhdcv5/include/lhdcv5_api.h
new file mode 100755
index 00000000..860e4e04
--- /dev/null
+++ b/external/liblhdcv5/include/lhdcv5_api.h
@@ -0,0 +1,322 @@
+#ifndef __LHDCV5_API_H__
+#define __LHDCV5_API_H__
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+typedef enum __LHDCV5_SAMPLE_FREQ__
+{
+  LHDCV5_SR_44100HZ  =  44100,
+  LHDCV5_SR_48000HZ  =  48000,
+  LHDCV5_SR_96000HZ  =  96000,
+  LHDCV5_SR_192000HZ = 192000,
+} LHDCV5BT_SAMPLE_FREQ_T;
+
+
+typedef enum __LHDCV5BT_SMPL_FMT__
+{
+  LHDCV5BT_SMPL_FMT_S16 = 16,
+  LHDCV5BT_SMPL_FMT_S24 = 24,
+  LHDCV5BT_SMPL_FMT_S32 = 32,
+} LHDCV5BT_SMPL_FMT_T;
+
+
+typedef enum __LHDCV5_SAMPLE_FRAME__
+{
+  LHDCV5_SAMPLE_FRAME_5MS_44100KHZ  = 240,
+  LHDCV5_SAMPLE_FRAME_5MS_48000KHZ  = 240,
+  LHDCV5_SAMPLE_FRAME_5MS_96000KHZ  = 480,
+  LHDCV5_SAMPLE_FRAME_5MS_192000KHZ = 960,
+  LHDCV5_MAX_SAMPLE_FRAME = 960,
+} LHDCV5_SAMPLE_FRAME_T;
+
+
+typedef enum __LHDCV5_FRAME_DURATION__
+{
+  LHDCV5_FRAME_5MS   = 50,
+  LHDCV5_FRAME_7P5MS = 75,
+  LHDCV5_FRAME_10MS  = 100,
+  LHDCV5_FRAME_1S    = 10000,
+} LHDCV5_FRAME_DURATION_T;
+
+
+typedef enum __LHDCV5_ENC_INTERVAL__
+{
+  LHDCV5_ENC_INTERVAL_10MS = 10,
+  LHDCV5_ENC_INTERVAL_20MS = 20,
+} LHDCV5_ENC_INTERVAL_T;
+
+
+typedef enum __LHDCV5_QUALITY__
+{
+  LHDCV5_QUALITY_LOW0 = 0,
+  LHDCV5_QUALITY_LOW1,
+  LHDCV5_QUALITY_LOW2,
+  LHDCV5_QUALITY_LOW3,
+  LHDCV5_QUALITY_LOW4,
+  LHDCV5_QUALITY_LOW,
+  LHDCV5_QUALITY_MID,
+  LHDCV5_QUALITY_HIGH,
+  LHDCV5_QUALITY_HIGH1,
+  LHDCV5_QUALITY_AUTO,
+  LHDCV5_QUALITY_RESET_AUTO,
+  LHDCV5_QUALITY_INVALID
+} LHDCV5_QUALITY_T;
+
+
+typedef enum __LHDCV5_MTU_SIZE__
+{
+  LHDCV5_MTU_MIN   = 300,
+  LHDCV5_MTU_2MBPS = 660,
+  LHDCV5_MTU_MAX   = 1023,
+} LHDCV5_MTU_SIZE_T;
+
+
+typedef enum __LHDCV5_VERSION__
+{
+  LHDCV5_VERSION_1 = 1,
+  LHDCV5_VERSION_INVALID
+} LHDCV5_VERSION_T;
+
+
+typedef enum __LHDCV5_ENC_TYPE__ 
+{
+  LHDCV5_ENC_TYPE_UNKNOWN = 0,
+  LHDCV5_ENC_TYPE_LHDCV5,
+  LHDCV5_ENC_TYPE_INVALID
+} LHDCV5_ENC_TYPE_T;
+
+
+typedef enum __LHDCV5_EXT_FUNC__
+{
+  LHDCV5_EXT_FUNC_AR = 0,
+  LHDCV5_EXT_FUNC_LARC,
+  LHDCV5_EXT_FUNC_JAS,
+  LHDCV5_EXT_FUNC_META,
+  LHDCV5_EXT_FUNC_INVALID
+} LHDCV5_EXT_FUNC_T;
+
+
+typedef enum __LHDCV5_META_PARAM__
+{
+  LHDCV5_META_LOOP_CNT_MAX = 100,
+  LHDCV5_META_LOOP_CNT_STD = 20,
+  LHDCV5_META_LEN_FIXED = 8,
+  LHDCV5_META_LEN_MAX = 128
+} LHDCV5_META_PARAM_T;
+
+
+typedef enum __LHDCV5_ABR_TYPE__ 
+{
+  LHDCV5_ABR_44K_RES = 0,
+  LHDCV5_ABR_48K_RES,
+  LHDCV5_ABR_96K_RES,
+  LHDCV5_ABR_192K_RES,
+  LHDCV5_ABR_INVALID
+} LHDCV5_ABR_TYPE_T;
+
+
+typedef struct _lhdcv5_abr_para_t 
+{
+  uint32_t	version;			// version of LHDC 5.0 CODEC
+  uint32_t	sample_rate;		// sample rate (Hz)
+  uint32_t 	bits_per_sample;	// bits per sample (bit)
+  uint32_t 	bits_per_sample_ui;	// bits per sample (bit) (from UI)
+
+  uint32_t 	upBitrateCnt;		// (ABR) up bitrate check parameter
+  uint32_t 	upBitrateSum;		// (ABR) up bitrate check parameter
+
+  uint32_t 	dnBitrateCnt;		// (ABR) down bitrate check parameter
+  uint32_t 	dnBitrateSum;		// (ABR) down bitrate check parameter
+
+  uint32_t 	lastBitrate;     	// Last bit rate (kbps) set for LHDC 5.0 encoder
+  uint32_t 	qualityStatus;      // current bit rate (index) (LOW0 ~ AUTO) is same as UI setting
+
+  //----------------------------------// Above is shared ABR parameters
+
+} lhdcv5_abr_para_t;
+
+
+
+typedef void * HANDLE_LHDCV5_BT;
+
+
+
+/*
+ ******************************************************************
+ LHDC v5 common utilities functions group
+ ******************************************************************
+ */
+
+extern int32_t lhdcv5_util_free_handle 
+(
+    HANDLE_LHDCV5_BT	handle
+);
+
+extern int32_t lhdcv5_util_get_mem_req 
+(
+    uint32_t			version,
+    uint32_t			* mem_req_bytes
+);
+
+extern int32_t lhdcv5_util_get_handle 
+(
+    uint32_t			version,
+    HANDLE_LHDCV5_BT	handle,
+    uint32_t            mem_size
+);
+
+extern int32_t lhdcv5_util_get_target_bitrate
+(
+    HANDLE_LHDCV5_BT	handle,
+    uint32_t			* bitrate
+);
+
+extern int32_t lhdcv5_util_set_target_bitrate_inx
+(
+    HANDLE_LHDCV5_BT 	handle,
+    uint32_t 			bitrate_inx,
+    uint32_t			* bitrate_inx_set,
+    bool				upd_qual_status
+);
+
+extern int32_t lhdcv5_util_set_max_bitrate_inx
+(
+    HANDLE_LHDCV5_BT	handle,
+    uint32_t			max_bitrate_inx,
+    uint32_t			* max_bitrate_inx_set
+);
+
+extern int32_t lhdcv5_util_set_min_bitrate_inx
+(
+    HANDLE_LHDCV5_BT	handle,
+    uint32_t			min_bitrate_inx,
+    uint32_t			* min_bitrate_inx_set
+);
+
+extern int32_t lhdcv5_util_adjust_bitrate
+(
+    HANDLE_LHDCV5_BT 	handle,
+    LHDCV5_ENC_TYPE_T	* enc_type_ptr,
+    lhdcv5_abr_para_t	** abr_para_ptr
+);
+
+extern int32_t lhdcv5_util_reset_up_bitrate
+(
+    lhdcv5_abr_para_t	* handle
+);
+
+extern int32_t lhdcv5_util_reset_down_bitrate
+(
+    lhdcv5_abr_para_t 	* handle
+);
+
+extern int32_t lhdcv5_util_get_ext_func_state
+(
+    HANDLE_LHDCV5_BT 	handle,
+    LHDCV5_EXT_FUNC_T 	ext_type,
+    bool				* enable_ptr
+);
+
+extern int32_t lhdcv5_util_set_ext_func_state
+(
+    HANDLE_LHDCV5_BT 	handle,
+    LHDCV5_EXT_FUNC_T 	ext_type,
+    bool 				func_enable,
+    uint8_t				* data_ptr,
+    uint32_t			data_len,
+    uint32_t			loop_cnt
+);
+
+extern int32_t lhdcv5_util_init_encoder
+(
+    HANDLE_LHDCV5_BT 	handle,
+    uint32_t 			sampling_freq,
+    uint32_t 			bits_per_sample,
+    uint32_t 			bitrate_inx,
+    uint32_t 			frame_duration,
+    uint32_t 			mtu,
+    uint32_t 			interval
+);
+
+extern int32_t lhdcv5_util_get_block_Size
+(
+    HANDLE_LHDCV5_BT 	handle,
+    uint32_t			* block_size
+);
+
+extern int32_t lhdcv5_util_enc_process
+(
+    HANDLE_LHDCV5_BT 	handle,
+    void				* p_pcm,
+    uint32_t			pcm_bytes,
+    uint8_t				* out_put,
+    uint32_t			out_buf_bytes,
+    uint32_t 			* written,
+    uint32_t 			* out_frames
+);
+
+extern int32_t lhdcv5_util_get_bitrate
+(
+    uint32_t	bitrate_inx,
+    uint32_t	* bitrate
+);
+
+extern int32_t lhdcv5_util_get_bitrate_inx
+(
+    uint32_t	bitrate,
+    uint32_t	* bitrate_inx
+);
+
+extern int32_t lhdcv5_util_ar_set_gyro_pos 
+(
+    HANDLE_LHDCV5_BT 	handle,
+    int32_t 			world_coordinate_x,
+    int32_t 			world_coordinate_y,
+    int32_t				world_coordinate_z
+);
+
+extern int32_t lhdcv5_util_ar_set_cfg
+(
+    HANDLE_LHDCV5_BT 	handle,
+    int32_t 			* pos_ptr,
+    uint32_t			pos_item_num,
+    float 				* gain_ptr,
+    uint32_t			gain_item_num,
+    uint32_t	 		app_ar_enabled
+);
+
+extern int32_t lhdcv5_util_ar_get_cfg 
+(
+    HANDLE_LHDCV5_BT 	handle,
+    int32_t 			* pos_ptr,
+    uint32_t			pos_item_num,
+    float 				* gain_ptr,
+    uint32_t			gain_item_num
+);
+
+
+typedef enum __LHDCV5_FUNC_RET__
+{
+  LHDCV5_FRET_SUCCESS 				=	  0,
+  LHDCV5_FRET_INVALID_INPUT_PARAM		=	 -1,
+  LHDCV5_FRET_INVALID_HANDLE_CB		=	 -2,
+  LHDCV5_FRET_INVALID_HANDLE_PARA		=	 -3,
+  LHDCV5_FRET_INVALID_HANDLE_ENC		=	 -4,
+  LHDCV5_FRET_INVALID_HANDLE_CBUF		=	 -5,
+  LHDCV5_FRET_INVALID_HANDLE_AR		=	 -6,
+  LHDCV5_FRET_INVALID_CODEC			=	 -7,
+  LHDCV5_FRET_CODEC_NOT_READY			=	 -8,
+  LHDCV5_FRET_AR_NOT_READY			=	 -9,
+  LHDCV5_FRET_ERROR					=	-10,
+  LHDCV5_FRET_BUF_NOT_ENOUGH			=	-11,
+} LHDCV5_FUNC_RET_T;
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif //End of __LHDCV5_API_H__
diff --git a/external/liblhdcv5/libs/arm64-v8a/liblhdcv5.so b/external/liblhdcv5/libs/arm64-v8a/liblhdcv5.so
new file mode 100755
index 00000000..74c3ae3a
Binary files /dev/null and b/external/liblhdcv5/libs/arm64-v8a/liblhdcv5.so differ
diff --git a/external/liblhdcv5/libs/armeabi-v7a/liblhdcv5.so b/external/liblhdcv5/libs/armeabi-v7a/liblhdcv5.so
new file mode 100755
index 00000000..ba68aab1
Binary files /dev/null and b/external/liblhdcv5/libs/armeabi-v7a/liblhdcv5.so differ
diff --git a/external/liblhdcv5/src/lhdcv5BT_enc.c b/external/liblhdcv5/src/lhdcv5BT_enc.c
new file mode 100755
index 00000000..7719fbe7
--- /dev/null
+++ b/external/liblhdcv5/src/lhdcv5BT_enc.c
@@ -0,0 +1,1779 @@
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include "lhdcv5BT.h"
+#include "lhdcv5BT_ext_func.h"
+
+#define LOG_TAG "lhdcv5BT_enc"
+#include <cutils/log.h>
+
+#define UP_RATE_TIME_CNT         			3000    // ABR bitrate upgrade checking time interval(ms): (UP_RATE_TIME_CNT * 20ms)
+#define DOWN_RATE_TIME_CNT       			4  		  // ABR bitrate downgrade checking time interval(ms): (DOWN_RATE_TIME_CNT * 20ms)
+#define ABR_UP_QUEUE_LENGTH_THRESHOLD     1   // A threshold of ABR bitrate upgrade check
+#define ABR_DOWN_QUEUE_LENGTH_THRESHOLD   0   // A threshold of ABR bitrate downgrade check
+
+// ABR: bit rate adjustment tables
+//static uint32_t auto_bitrate_adjust_table_lhdcv5_std[] = {128, 192, 256, 320, 400, 600};
+//static uint32_t auto_bitrate_adjust_table_lhdcv5_hi[] = {256, 320, 400, 600, 600, 600};
+//static uint32_t auto_bitrate_adjust_table_lhdcv5_std[] = {128, 192, 256, 320, 400, 400};
+//static uint32_t auto_bitrate_adjust_table_lhdcv5_hi[] = {256, 320, 400, 400, 400, 400};
+static uint32_t auto_bitrate_adjust_table_lhdcv5_44k[] = {128, 192, 240, 320, 400, 400};
+static uint32_t auto_bitrate_adjust_table_lhdcv5_48k[] = {128, 192, 256, 320, 400, 400};
+static uint32_t auto_bitrate_adjust_table_lhdcv5_96k[] = {256, 320, 400, 400, 400, 400};
+static uint32_t auto_bitrate_adjust_table_lhdcv5_192k[] = {256, 320, 400, 400, 400, 400};
+
+//#define LHDCV5_STD_BITRATE_ELEMENTS_SIZE	(sizeof(auto_bitrate_adjust_table_lhdcv5_std) / sizeof(uint32_t))
+//#define LHDCV5_HI_BITRATE_ELEMENTS_SIZE		(sizeof(auto_bitrate_adjust_table_lhdcv5_hi) / sizeof(uint32_t))
+#define LHDCV5_44K_BITRATE_ELEMENTS_SIZE  (sizeof(auto_bitrate_adjust_table_lhdcv5_44k) / sizeof(uint32_t))
+#define LHDCV5_48K_BITRATE_ELEMENTS_SIZE  (sizeof(auto_bitrate_adjust_table_lhdcv5_48k) / sizeof(uint32_t))
+#define LHDCV5_96K_BITRATE_ELEMENTS_SIZE  (sizeof(auto_bitrate_adjust_table_lhdcv5_96k) / sizeof(uint32_t))
+#define LHDCV5_192K_BITRATE_ELEMENTS_SIZE  (sizeof(auto_bitrate_adjust_table_lhdcv5_192k) / sizeof(uint32_t))
+
+#define LHDCV5_ABR_DEFAULT_BITRATE     (LHDCV5_QUALITY_LOW)
+
+
+static const char * rate_to_string
+(
+    LHDCV5_QUALITY_T	q
+)
+{
+  switch (q)
+  {
+  case LHDCV5_QUALITY_LOW0:
+    return "LHDCV5_QUALITY_LOW0";
+  case LHDCV5_QUALITY_LOW1:
+    return "LHDCV5_QUALITY_LOW1";
+  case LHDCV5_QUALITY_LOW2:
+    return "LHDCV5_QUALITY_LOW2";
+  case LHDCV5_QUALITY_LOW3:
+    return "LHDCV5_QUALITY_LOW3";
+  case LHDCV5_QUALITY_LOW4:
+    return "LHDCV5_QUALITY_LOW4";
+  case LHDCV5_QUALITY_LOW:
+    return "LHDCV5_QUALITY_LOW";
+  case LHDCV5_QUALITY_MID:
+    return "LHDCV5_QUALITY_MID";
+  case LHDCV5_QUALITY_HIGH:
+    return "LHDCV5_QUALITY_HIGH";
+  case LHDCV5_QUALITY_HIGH1:
+    return "LHDCV5_QUALITY_HIGH1";
+  case LHDCV5_QUALITY_AUTO:
+    return "LHDCV5_QUALITY_AUTO";
+  default:
+    ALOGW ("%s: Incorrect quality(%d)",  __func__, q);
+    return "UNKNOW_QUALITY";
+  }
+}
+
+
+//----------------------------------------------------------------
+// lhdcv5_encoder_inx_of_abr_bitrate ()
+//
+// return the bit rate (index) respond to input bit rate (kbps)
+//	Parameter
+//		abr_type: ABR type
+//		bitrate: bit rate (kbps)
+//		bitrate_inx: ABR bit rate (index) returned
+//	Return
+//		LHDCV5_FRET_SUCCESS: succeed to return the bit rate (index)
+//		otherwise: fail to return the bit rate (index)
+//----------------------------------------------------------------
+static int lhdcv5_encoder_inx_of_abr_bitrate
+(
+    LHDCV5_ABR_TYPE_T abr_type,
+    uint32_t  bitrate,
+    uint32_t  *bitrate_inx
+)
+{
+  uint32_t element_size = LHDCV5_48K_BITRATE_ELEMENTS_SIZE;
+  uint32_t *abr_table = NULL;
+
+  if (bitrate_inx == NULL)
+  {
+    ALOGW ("%s: Input parameter is NULL!!!", __func__);
+    return LHDCV5_FRET_INVALID_INPUT_PARAM;
+  }
+
+  if (abr_type == LHDCV5_ABR_44K_RES)
+  {
+    element_size = LHDCV5_44K_BITRATE_ELEMENTS_SIZE;
+
+    abr_table = &(auto_bitrate_adjust_table_lhdcv5_44k[0]);
+  }
+  else if (abr_type == LHDCV5_ABR_48K_RES)
+  {
+    element_size = LHDCV5_48K_BITRATE_ELEMENTS_SIZE;
+
+    abr_table = &(auto_bitrate_adjust_table_lhdcv5_48k[0]);
+  }
+  else if (abr_type == LHDCV5_ABR_96K_RES)
+  {
+    element_size = LHDCV5_96K_BITRATE_ELEMENTS_SIZE;
+
+    abr_table = &(auto_bitrate_adjust_table_lhdcv5_96k[0]);
+  }
+  else if (abr_type == LHDCV5_ABR_192K_RES)
+  {
+    element_size = LHDCV5_192K_BITRATE_ELEMENTS_SIZE;
+
+    abr_table = &(auto_bitrate_adjust_table_lhdcv5_192k[0]);
+  }
+  else
+  {
+    ALOGW ("%s: Invalid ABR type (%d)!", __func__, abr_type);
+    return LHDCV5_FRET_INVALID_INPUT_PARAM;
+  }
+
+  if ((bitrate <= 0) || (bitrate > abr_table[element_size - 1]))
+  {
+    ALOGW ("%s: bit rate is out of range (%d)!!!", __func__, bitrate);
+    return LHDCV5_FRET_INVALID_INPUT_PARAM;
+  }
+
+
+  for (uint32_t i = 0; i < element_size; i++)
+  {
+    if (abr_table[i] >= bitrate)
+    {
+      *bitrate_inx = i;
+      return LHDCV5_FRET_SUCCESS;
+    }
+  }
+
+  ALOGW ("%s: Fail to find bit rate (index) (%d)!", __func__, bitrate);
+  return LHDCV5_FRET_ERROR;
+}
+
+
+//----------------------------------------------------------------
+// lhdcv5_encoder_adjust_bitrate ()
+//
+// Adjust bit rate automatically according to number of packets in queue for LHDC 5.0 encoding
+//	Parameter
+//		lhdcBT: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		handle: a pointer to ABR parameters
+//		queueLen: number of packets in queue
+//	Return
+//		LHDCV5_FRET_SUCCESS: succeed to adjust bit rate automatically 
+//		otherwise: fail to adjust bit rate automatically 
+//----------------------------------------------------------------
+static int lhdcv5_encoder_adjust_bitrate
+(
+    HANDLE_LHDCV5_BT  lhdcBT,
+    lhdcv5_abr_para_t *handle,
+    uint32_t  queueLen
+) 
+{
+  uint32_t element_size = LHDCV5_48K_BITRATE_ELEMENTS_SIZE;
+  uint32_t new_abr_bitrate_inx = 0;
+  uint32_t new_bitrate_inx = 0;
+  uint32_t new_bitrate_inx_set = 0;
+  uint32_t last_bitrate_inx = 0;
+  uint32_t *abr_table = &(auto_bitrate_adjust_table_lhdcv5_48k[0]);
+  LHDCV5_ABR_TYPE_T	abr_type = LHDCV5_ABR_48K_RES;
+  int32_t func_ret = LHDCV5_FRET_SUCCESS;
+  uint32_t queueLength = 0;
+
+  if (lhdcBT == NULL)
+  {
+    ALOGW ("%s: lhdcBT is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_HANDLE_CB;
+  }
+
+  if (handle == NULL)
+  {
+    ALOGW ("%s: Handle is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_HANDLE_PARA;
+  }
+
+  if (handle->qualityStatus != LHDCV5_QUALITY_AUTO)
+  {
+    ALOGW ("%s: Not ABR (%d)", __func__, handle->qualityStatus);
+    return LHDCV5_FRET_SUCCESS;
+  }
+
+  if (queueLen < 0)
+  {
+    ALOGW ("%s: Invalid queue length (%u)!", __func__, queueLen);
+    return LHDCV5_FRET_INVALID_HANDLE_PARA;
+  }
+
+  if (handle->sample_rate == LHDCV5_SR_44100HZ)
+  {
+    abr_type = LHDCV5_ABR_44K_RES;
+    element_size = LHDCV5_44K_BITRATE_ELEMENTS_SIZE;
+    abr_table = &(auto_bitrate_adjust_table_lhdcv5_44k[0]);
+  }
+  else if (handle->sample_rate == LHDCV5_SR_48000HZ)
+  {
+    abr_type = LHDCV5_ABR_48K_RES;
+    element_size = LHDCV5_48K_BITRATE_ELEMENTS_SIZE;
+    abr_table = &(auto_bitrate_adjust_table_lhdcv5_48k[0]);
+  }
+  else if (handle->sample_rate == LHDCV5_SR_96000HZ)
+  {
+    abr_type = LHDCV5_ABR_96K_RES;
+    element_size = LHDCV5_96K_BITRATE_ELEMENTS_SIZE;
+    abr_table = &(auto_bitrate_adjust_table_lhdcv5_96k[0]);
+  }
+  else if (handle->sample_rate == LHDCV5_SR_192000HZ)
+  {
+    abr_type = LHDCV5_ABR_192K_RES;
+    element_size = LHDCV5_192K_BITRATE_ELEMENTS_SIZE;
+    abr_table = &(auto_bitrate_adjust_table_lhdcv5_192k[0]);
+  }
+  else
+  {
+    ALOGW ("%s: Sample rate is invalid (%u)!", __func__, handle->sample_rate);
+    return LHDCV5_FRET_CODEC_NOT_READY;
+  }
+
+  if (handle->dnBitrateCnt > 0 && handle->dnBitrateCnt >= DOWN_RATE_TIME_CNT)
+  {
+    queueLength = handle->dnBitrateSum / handle->dnBitrateCnt;
+
+    //handle->dnBitrateSum = 0;
+    //handle->dnBitrateCnt = 0;
+    func_ret = lhdcv5_util_reset_down_bitrate (handle);
+    if (func_ret != LHDCV5_FRET_SUCCESS)
+    {
+      ALOGW ("%s:(DN) lhdcv5_util_reset_down_bitrate error %d",  __func__, func_ret);
+      goto fail;
+    }
+
+    if (queueLength > ABR_DOWN_QUEUE_LENGTH_THRESHOLD)
+    {
+      ALOGD ("%s:(DN) dnBitrateSum:%u / dnBitrateCnt:%u = queueLength:%u", __func__,
+          handle->dnBitrateSum, handle->dnBitrateCnt, queueLength);
+
+      new_abr_bitrate_inx = 0;
+      func_ret = lhdcv5_util_get_bitrate_inx (abr_table[new_abr_bitrate_inx], &new_bitrate_inx);
+      if (func_ret != LHDCV5_FRET_SUCCESS)
+      {
+        ALOGW ("%s:(DN) lhdcv5_util_get_bitrate_inx error %d",  __func__, func_ret);
+        goto fail;
+      }
+
+      func_ret = lhdcv5_util_get_bitrate_inx (handle->lastBitrate, &last_bitrate_inx);
+      if (func_ret != LHDCV5_FRET_SUCCESS)
+      {
+        ALOGW ("%s:(DN) lhdcv5_util_get_bitrate_inx error %d",  __func__, func_ret);
+        goto fail;
+      }
+
+      if (new_bitrate_inx < last_bitrate_inx)
+      {
+        func_ret = lhdcv5_util_set_target_bitrate_inx (lhdcBT, new_bitrate_inx, &new_bitrate_inx_set, false);
+        if (func_ret != LHDCV5_FRET_SUCCESS)
+        {
+          ALOGW ("%s:(DN) lhdcv5_util_set_target_bitrate_inx error %d", __func__, func_ret);
+          goto fail;
+        }
+
+        ALOGD ("%s:(DN) [AutoBiTrAtE] Down bitrate[%u] to new bitrate(%u)[%u], queueLength(%u)",  __func__,
+            last_bitrate_inx, abr_table[new_abr_bitrate_inx], new_bitrate_inx_set, queueLength);
+
+        func_ret = lhdcv5_util_reset_up_bitrate (handle);
+        if (func_ret != LHDCV5_FRET_SUCCESS)
+        {
+          ALOGW ("%s:(DN) lhdcv5_util_reset_up_bitrate error %d", __func__, func_ret);
+          goto fail;
+        }
+      }
+      else
+      {
+        ALOGD ("%s:(DN) [AutoBiTrAtE] Down bitrate condition fails, new rate:%u, current rate:%u",  __func__,
+            abr_table[new_abr_bitrate_inx],
+            handle->lastBitrate);
+      }
+    }
+  }
+
+  if (handle->upBitrateCnt > 0 && handle->upBitrateCnt >= UP_RATE_TIME_CNT)
+  {
+    uint32_t queueLength = handle->upBitrateSum / handle->upBitrateCnt;
+    uint32_t queuSumTmp = handle->upBitrateSum;
+
+    ALOGV ("%s:(UP) Before upBitrateSum:%u / upBitrateCnt:%u = queueLength:%u", __func__,
+        handle->upBitrateSum, handle->upBitrateCnt, queueLength);
+
+    //handle->upBitrateSum = 0;
+    //handle->upBitrateCnt = 0;
+    func_ret = lhdcv5_util_reset_up_bitrate (handle);
+    if (func_ret != LHDCV5_FRET_SUCCESS)
+    {
+      ALOGW ("%s:(UP) lhdcv5_util_reset_up_bitrate error %d", __func__, func_ret);
+      goto fail;
+    }
+
+    func_ret = lhdcv5_encoder_inx_of_abr_bitrate (abr_type,
+        handle->lastBitrate,
+        &new_abr_bitrate_inx);
+    if (func_ret != LHDCV5_FRET_SUCCESS)
+    {
+      ALOGW ("%s:(UP) lhdcv5_encoder_inx_of_abr_bitrate error %d", __func__, func_ret);
+      goto fail;
+    }
+
+    if (new_abr_bitrate_inx < (element_size - 1))
+    {
+      new_abr_bitrate_inx++;
+    }
+
+    func_ret = lhdcv5_util_get_bitrate_inx (abr_table[new_abr_bitrate_inx], &new_bitrate_inx);
+    if (func_ret != LHDCV5_FRET_SUCCESS)
+    {
+      ALOGW ("%s:(UP) lhdcv5_util_get_bitrate_inx error %d", __func__, func_ret);
+      goto fail;
+    }
+
+    func_ret = lhdcv5_util_get_bitrate_inx (handle->lastBitrate, &last_bitrate_inx);
+    if (func_ret != LHDCV5_FRET_SUCCESS)
+    {
+      ALOGW ("%s:(UP) lhdcv5_util_get_bitrate_inx error %d", __func__, func_ret);
+      goto fail;
+    }
+
+    if ((new_bitrate_inx > last_bitrate_inx) && (queuSumTmp < ABR_UP_QUEUE_LENGTH_THRESHOLD))
+    {
+      func_ret = lhdcv5_util_set_target_bitrate_inx (lhdcBT, new_bitrate_inx, &new_bitrate_inx_set, false);
+      if (func_ret != LHDCV5_FRET_SUCCESS)
+      {
+        ALOGW ("%s:(UP) lhdcv5_util_set_target_bitrate_inx error %d", __func__, func_ret);
+        goto fail;
+      }
+      ALOGD ("%s:(UP) [AutoBiTrAtE] Up bitrate[%u] to new_bitrate(%u)[%u], queueLength(%u)",
+          __func__, last_bitrate_inx, abr_table[new_abr_bitrate_inx], new_bitrate_inx_set, queueLength);
+
+      func_ret = lhdcv5_util_reset_down_bitrate (handle);
+      if (func_ret != LHDCV5_FRET_SUCCESS)
+      {
+        ALOGW ("%s:(UP) lhdcv5_util_reset_down_bitrate error %d", __func__, func_ret);
+        goto fail;
+      }
+    }
+    else
+    {
+      ALOGD ("%s:(UP) [AutoBiTrAtE] Up bitrate condition fails, new rate:%u, current rate:%u, queue sum:%u",  __func__,
+          abr_table[new_abr_bitrate_inx],
+          handle->lastBitrate,
+          queuSumTmp);
+    }
+  }
+
+  if (queueLen > 0)
+  {
+    handle->upBitrateSum += queueLen;
+    handle->dnBitrateSum += queueLen;
+  }
+
+  handle->upBitrateCnt++;
+  handle->dnBitrateCnt++;
+
+  fail:
+  return func_ret;
+}
+
+
+/*
+ ******************************************************************
+ LHDC library public API group
+ ******************************************************************
+ */
+
+//----------------------------------------------------------------
+// lhdcv5BT_free_handle ()
+//
+// Free all resources allocated
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcv5BT_get_handle ()
+//	Return
+//		LHDCV5_FRET_SUCCESS: Succeed to free all resources
+//		otherwise: Fail to free all resources
+//----------------------------------------------------------------
+int32_t lhdcv5BT_free_handle
+(
+    HANDLE_LHDCV5_BT	handle
+) 
+{
+  int32_t func_ret = LHDCV5_FRET_SUCCESS;
+
+  if (handle == NULL)
+  {
+    ALOGW ("%s: Handle is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_HANDLE_CB;
+  }
+
+  // reset resources
+  func_ret = lhdcv5_util_free_handle (handle);
+
+  // free handle
+  if(handle)
+  {
+    ALOGD ("%s: free handle %p!", __func__, handle);
+    free(handle);
+    handle = NULL;
+  }
+
+  return func_ret;
+}
+
+
+//----------------------------------------------------------------
+// lhdcv5BT_get_handle ()
+//
+// Allocate resources required by LHDC 5.0 Encoder 
+// 	Parameter
+//		version: version defined in BT A2DP capability
+//		handle: a pointer to the resource allocated 
+// 	Return
+//		LHDCV5_FRET_SUCCESS: Succeed to allocate resources
+//		otherwise: Fail to allocate resources
+//----------------------------------------------------------------
+int32_t lhdcv5BT_get_handle
+(
+    uint32_t			version,
+    HANDLE_LHDCV5_BT	*handle
+) 
+{
+  int32_t		func_ret = LHDCV5_FRET_SUCCESS;
+  uint32_t mem_req_bytes = 0;
+  HANDLE_LHDCV5_BT hLhdcBT = NULL;
+
+  if (version != LHDCV5_VERSION_1)
+  {
+    ALOGW ("%s: Invalid version (%u)!", __func__, version);
+    return LHDCV5_FRET_ERROR;
+  }
+
+  if (handle == NULL)
+  {
+    ALOGW ("%s: Input parameter is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_INPUT_PARAM;
+  }
+
+  func_ret = lhdcv5_util_get_mem_req (version, &mem_req_bytes);
+
+  if (func_ret != LHDCV5_FRET_SUCCESS || mem_req_bytes <= 0)
+  {
+    ALOGW ("%s: Fail to get required memory size (%d)!", __func__, func_ret);
+    return LHDCV5_FRET_ERROR;
+  }
+
+  hLhdcBT = (HANDLE_LHDCV5_BT)malloc(mem_req_bytes);
+  if (hLhdcBT == NULL)
+  {
+    ALOGW ("%s: Fail to allocate memory for encoder!", __func__);
+    return LHDCV5_FRET_ERROR;
+  }
+
+  func_ret = lhdcv5_util_get_handle (version, hLhdcBT, mem_req_bytes);
+
+  if (func_ret != LHDCV5_FRET_SUCCESS)
+  {
+    ALOGW ("%s: Fail to get handle (%d)!", __func__, func_ret);
+    free(hLhdcBT);
+    return LHDCV5_FRET_ERROR;
+  }
+
+  *handle = hLhdcBT;
+
+  if ((*handle) == NULL)
+  {
+    ALOGW ("%s: Get handle NULL!", __func__);
+    return LHDCV5_FRET_INVALID_HANDLE_CB;
+  }
+
+  return LHDCV5_FRET_SUCCESS;
+}
+
+
+//----------------------------------------------------------------
+// lhdcv5BT_get_bitrate ()
+//
+// Get the bit rate used during LHDC 5.0 encoding
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcv5BT_get_handle ()
+//		bitrate: a pointer to bit rate used during LHDC 5.0 encoding,
+//				 range [64000, 1000000]
+//	Return
+//		LHDCV5_FRET_SUCCESS: Succeed to allocate resources
+//		otherwise: Fail to allocate resources
+//----------------------------------------------------------------
+int32_t lhdcv5BT_get_bitrate
+(
+    HANDLE_LHDCV5_BT	handle,
+    uint32_t			*bitrate
+) 
+{
+  int32_t		func_ret = LHDCV5_FRET_SUCCESS;
+
+  if (handle == NULL)
+  {
+    ALOGW ("%s: Handle is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_HANDLE_CB;
+  }
+
+  if (bitrate == NULL)
+  {
+    ALOGW ("%s: Input parameter is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_INPUT_PARAM;
+  }
+
+  func_ret = lhdcv5_util_get_target_bitrate (handle, bitrate);
+
+  if (func_ret != LHDCV5_FRET_SUCCESS)
+  {
+    ALOGW ("%s: Failed to get bit rate (%d)!", __func__, func_ret);
+    return LHDCV5_FRET_ERROR;
+  }
+
+  if ((*bitrate < 64000) || (*bitrate > 1000000))
+  {
+    ALOGW ("%s: Invalid bit rate returned (%u)!", __func__, *bitrate);
+    return LHDCV5_FRET_ERROR;
+  }
+
+  return LHDCV5_FRET_SUCCESS;
+}
+
+
+//----------------------------------------------------------------
+// lhdcv5BT_set_bitrate ()
+//
+// Set the bit rate used during LHDC 5.0 encoding
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		bitrate_inx: an index of bit rate to set
+//	Return
+//		LHDCV5_FRET_SUCCESS: succeed to set the bit rate
+//		Other: fail to set the bit rate
+//----------------------------------------------------------------
+int32_t lhdcv5BT_set_bitrate
+(
+    HANDLE_LHDCV5_BT 	handle,
+    uint32_t			bitrate_inx
+)
+{
+  uint32_t	bitrate_inx_set = bitrate_inx;
+  int32_t		func_ret = LHDCV5_FRET_SUCCESS;
+
+  if (handle == NULL)
+  {
+    ALOGW ("%s: Handle is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_HANDLE_CB;
+  }
+
+  if ((bitrate_inx < LHDCV5_QUALITY_LOW0) ||
+      (bitrate_inx >= LHDCV5_QUALITY_INVALID))
+  {
+    ALOGW ("%s: Invalid bit rate index (%u)!", __func__, bitrate_inx);
+    return LHDCV5_FRET_INVALID_INPUT_PARAM;
+  }
+
+  if (bitrate_inx == LHDCV5_QUALITY_RESET_AUTO) {
+    bitrate_inx_set = LHDCV5_ABR_DEFAULT_BITRATE;
+    ALOGD ("%s: [Reset BiTrAtE] reset to bitrate (%s)", __func__, rate_to_string (bitrate_inx_set));
+    bitrate_inx = LHDCV5_ABR_DEFAULT_BITRATE;
+    // change bitrate only, not update quality index
+    func_ret = lhdcv5_util_set_target_bitrate_inx (handle, bitrate_inx, &bitrate_inx_set, false);
+  } else {
+    // also update quality index
+    func_ret = lhdcv5_util_set_target_bitrate_inx (handle, bitrate_inx, &bitrate_inx_set, true);
+  }
+
+  if (func_ret != LHDCV5_FRET_SUCCESS)
+  {
+    ALOGW ("%s: failed to set bitrate (%d)!", __func__, func_ret);
+    return LHDCV5_FRET_ERROR;
+  }
+
+  ALOGD ("%s: Update target bitrate(%s)",  __func__,
+      rate_to_string (bitrate_inx_set));
+
+  return LHDCV5_FRET_SUCCESS;
+}
+
+
+//----------------------------------------------------------------
+// lhdcv5BT_set_max_bitrate ()
+//
+// Set the MAX. bit rate for LHDC 5.0 encoding
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		max_bitrate_inx: MAX. bit rate (index) for LHDC 5.0 encoding
+//	Return
+//		LHDCV5_FRET_SUCCESS: succeed to set the MAX. bit rate
+//		Other: fail to set the MAX. bit rate
+//----------------------------------------------------------------
+int32_t lhdcv5BT_set_max_bitrate
+(
+    HANDLE_LHDCV5_BT	handle,
+    uint32_t			max_bitrate_inx
+) 
+{
+  uint32_t max_bitrate_inx_set = max_bitrate_inx;
+  int32_t func_ret = LHDCV5_FRET_SUCCESS;
+
+  if (handle == NULL)
+  {
+    ALOGW ("%s: Handle is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_HANDLE_CB;
+  }
+
+  if ((max_bitrate_inx < LHDCV5_QUALITY_LOW) ||
+      (max_bitrate_inx >= LHDCV5_QUALITY_AUTO))
+  {
+    ALOGW ("%s: Invalid max bit rate index (%u)!", __func__, max_bitrate_inx);
+    return LHDCV5_FRET_INVALID_INPUT_PARAM;
+  }
+
+  func_ret = lhdcv5_util_set_max_bitrate_inx (handle, max_bitrate_inx, &max_bitrate_inx_set);
+
+  if (func_ret != LHDCV5_FRET_SUCCESS)
+  {
+    ALOGW ("%s: failed to set max. bit rate index (%u), (%d)!", __func__, max_bitrate_inx, func_ret);
+    return LHDCV5_FRET_ERROR;
+  }
+
+  ALOGD ("%s: Update Max target bitrate(%s)",  __func__, rate_to_string (max_bitrate_inx_set));
+
+  return LHDCV5_FRET_SUCCESS;
+}
+
+
+//----------------------------------------------------------------
+// lhdcv5BT_set_min_bitrate ()
+//
+// Set the MIN. bit rate for LHDC 5.0 encoding
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		min_bitrate_inx: MIN. bit rate (index) for LHDC 5.0 encoding
+//	Return
+//		LHDCV5_FRET_SUCCESS: succeed to set the MIN. bit rate
+//		Other: fail to set the MIN. bit rate
+//----------------------------------------------------------------
+
+int32_t lhdcv5BT_set_min_bitrate
+(
+    HANDLE_LHDCV5_BT 	handle,
+    uint32_t			min_bitrate_inx
+)
+{
+  uint32_t 	min_bitrate_inx_set = (uint32_t) LHDCV5_QUALITY_LOW0;
+  int32_t			func_ret = LHDCV5_FRET_SUCCESS;
+
+  if (handle == NULL)
+  {
+    ALOGW ("%s: Handle is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_HANDLE_CB;
+  }
+
+  if ((min_bitrate_inx < LHDCV5_QUALITY_LOW0) ||
+      (min_bitrate_inx > LHDCV5_QUALITY_LOW))
+  {
+    ALOGW ("%s: Invalid min bit rate index (%u)!", __func__, min_bitrate_inx);
+    return LHDCV5_FRET_INVALID_INPUT_PARAM;
+  }
+
+  func_ret = lhdcv5_util_set_min_bitrate_inx (handle, min_bitrate_inx, &min_bitrate_inx_set);
+
+  if (func_ret != LHDCV5_FRET_SUCCESS)
+  {
+    ALOGW ("%s: failed to set min. bit rate (%d)!", __func__, func_ret);
+    return LHDCV5_FRET_ERROR;
+  }
+
+  return LHDCV5_FRET_SUCCESS;
+}
+
+
+//----------------------------------------------------------------
+// lhdcv5BT_adjust_bitrate ()
+//
+// Adjust bit rate automatically according to number of packets in queue for LHDC 5.0 encoding
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		queue_len: number of packets in queue
+//	Return
+//		LHDCV5_FRET_SUCCESS: succeed to adjust bit rate automatically 
+//		Other: fail to adjust bit rate automatically 
+//----------------------------------------------------------------
+
+int32_t lhdcv5BT_adjust_bitrate
+(
+    HANDLE_LHDCV5_BT 	handle,
+    uint32_t			queueLen
+) 
+{
+  LHDCV5_ENC_TYPE_T	enc_type = LHDCV5_ENC_TYPE_LHDCV5;
+  lhdcv5_abr_para_t	* abr_para = NULL;
+  int32_t				func_ret = LHDCV5_FRET_SUCCESS;
+
+  if (handle == NULL)
+  {
+    ALOGW ("%s: Handle is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_HANDLE_CB;
+  }
+
+  if (queueLen < 0)
+  {
+    ALOGW ("%s: Invalid input queue length (%u)!", __func__, queueLen);
+    return LHDCV5_FRET_INVALID_INPUT_PARAM;
+  }
+
+  func_ret = lhdcv5_util_adjust_bitrate (handle, &enc_type, &abr_para);
+
+  if ((func_ret != LHDCV5_FRET_SUCCESS) || (abr_para == NULL))
+  {
+    ALOGW ("%s: Failed to get auto bit rate parameters (%d) (%p)!", __func__, func_ret, abr_para);
+    return LHDCV5_FRET_ERROR;
+  }
+
+  switch (enc_type)
+  {
+  case LHDCV5_ENC_TYPE_LHDCV5:
+
+    func_ret = lhdcv5_encoder_adjust_bitrate (handle, abr_para, queueLen);
+
+    if (func_ret != LHDCV5_FRET_SUCCESS)
+    {
+      ALOGW ("%s: Failed to adjust auto bit rate (%d)!", __func__, func_ret);
+      return LHDCV5_FRET_ERROR;
+    }
+    break;
+
+  default:
+    ALOGW ("%s: Invalid encode type (%d)!", __func__, enc_type);
+    return LHDCV5_FRET_INVALID_CODEC;
+  }
+
+  return LHDCV5_FRET_SUCCESS;
+}
+
+
+//----------------------------------------------------------------
+// lhdcv5BT_set_ext_func_state ()
+//
+// Set the ext. function state (AR, JAS, Meta, LARC)
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		field: specify the ext. function
+//		enabled: ext. function is set to enabled (true) or disabled (false)
+//		priv: a pointer to the exra data needed for ext. function
+//		priv_data_len: number of bytes of the extra data
+//	Return
+//		LHDCV5_FRET_SUCCESS: succeed to set specified ext. function to enabled (true) or disabled (false)
+//		Other: fail to set .
+//----------------------------------------------------------------
+
+int32_t lhdcv5BT_set_ext_func_state
+(
+    HANDLE_LHDCV5_BT 	handle,
+    LHDCV5_EXT_FUNC_T	field,
+    bool 				enabled,
+    void 				* priv,
+    uint32_t 			priv_data_len
+)
+{
+  int32_t	func_ret = LHDCV5_FRET_SUCCESS;
+
+  if (handle == NULL)
+  {
+    ALOGW ("%s: Handle is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_HANDLE_CB;
+  }
+
+  if ((field < LHDCV5_EXT_FUNC_AR) ||
+      (field >= LHDCV5_EXT_FUNC_INVALID))
+  {
+    ALOGW ("%s: Invalid ext. func. field (%d)!", __func__, field);
+    return LHDCV5_FRET_INVALID_INPUT_PARAM;
+  }
+
+  func_ret = lhdcv5_util_set_ext_func_state (handle,
+      (LHDCV5_EXT_FUNC_T) field,
+      enabled,
+      priv,
+      priv_data_len,	// data length MUST be 8 for META
+      LHDCV5_META_LOOP_CNT_STD);
+
+  if (func_ret != LHDCV5_FRET_SUCCESS)
+  {
+    ALOGW ("%s: failed to set ext. function state (%d)!", __func__, func_ret);
+    return LHDCV5_FRET_ERROR;
+  }
+
+  return LHDCV5_FRET_SUCCESS;
+}
+
+
+//----------------------------------------------------------------
+// lhdcv5BT_init_encoder ()
+//
+// Initialize LHDC 5.0 encoder
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		sampling_freq: sample frequency
+//		bit_per_sample: bits per sample
+//		bitrate_inx: bit rate index
+//		mtu: BT A2DP MTU 
+//		interval: interval: period of time triggering LHDC 5.0 encoding in ms
+//	Return
+//		LHDCV5_FRET_SUCCESS: succeed to initialize 
+//		Other: fail to initialize.
+//----------------------------------------------------------------
+int32_t lhdcv5BT_init_encoder
+(
+    HANDLE_LHDCV5_BT 	handle,
+    uint32_t 			sampling_freq,
+    uint32_t 			bits_per_sample,
+    uint32_t 			bitrate_inx,
+    uint32_t 			mtu,
+    uint32_t 			interval
+) 
+{
+  int32_t		func_ret = LHDCV5_FRET_SUCCESS;
+
+  if (handle == NULL)
+  {
+    ALOGW ("%s: Handle is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_HANDLE_CB;
+  }
+
+  if ((sampling_freq != LHDCV5_SR_44100HZ) &&
+      (sampling_freq != LHDCV5_SR_48000HZ) &&
+      (sampling_freq != LHDCV5_SR_96000HZ) &&
+      (sampling_freq != LHDCV5_SR_192000HZ))
+  {
+    ALOGW ("%s: Invalid sampling frequency (%u)!", __func__, sampling_freq);
+    return LHDCV5_FRET_INVALID_INPUT_PARAM;
+  }
+
+  if ((bits_per_sample != LHDCV5BT_SMPL_FMT_S16) &&
+      (bits_per_sample != LHDCV5BT_SMPL_FMT_S24) &&
+      (bits_per_sample != LHDCV5BT_SMPL_FMT_S32))
+  {
+    ALOGW ("%s: Invalid bits per sample (%u)!", __func__, bits_per_sample);
+    return LHDCV5_FRET_INVALID_INPUT_PARAM;
+  }
+
+  if ((bitrate_inx < LHDCV5_QUALITY_LOW0) ||
+      (bitrate_inx > LHDCV5_QUALITY_AUTO))
+  {
+    ALOGW ("%s: Invalid bit rate (index) (%d)!", __func__, bitrate_inx);
+    return LHDCV5_FRET_INVALID_INPUT_PARAM;
+  }
+
+
+  func_ret = lhdcv5_util_init_encoder (handle,
+      (unsigned int) sampling_freq,
+      (unsigned int) bits_per_sample,
+      (unsigned int) bitrate_inx,
+      (unsigned int) LHDCV5_FRAME_5MS,
+      (unsigned int) mtu,
+      (unsigned int) interval);
+
+  if (func_ret != LHDCV5_FRET_SUCCESS)
+  {
+    ALOGW ("%s: Failed to init LHDC 5.0 encoder (%d)!", __func__, func_ret);
+    return LHDCV5_FRET_ERROR;
+  }
+
+  return LHDCV5_FRET_SUCCESS;
+}
+
+
+//----------------------------------------------------------------
+// lhdcv5BT_get_block_Size ()
+//
+// Get number of samples per block for LHDC 5.0 encoder
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned by function lhdcv5Bt_get_handle ()
+//		samples_per_frame: number of samples per block returned
+//	Return
+//		LHDCV5_FRET_SUCCESS: succeed to get number of samples per block 
+//		Other: fail to get number of samples per block.
+//----------------------------------------------------------------
+int32_t lhdcv5BT_get_block_Size
+(
+    HANDLE_LHDCV5_BT	handle,
+    uint32_t			* samples_per_frame
+)
+{
+  int32_t		func_ret = LHDCV5_FRET_SUCCESS;
+
+
+  if (handle == NULL)
+  {
+    ALOGW ("%s: Handle is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_HANDLE_CB;
+  }
+
+  if (samples_per_frame == NULL)
+  {
+    ALOGW ("%s: Input parameter is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_INPUT_PARAM;
+  }
+
+  func_ret = lhdcv5_util_get_block_Size (handle, samples_per_frame);
+
+  if ((func_ret != LHDCV5_FRET_SUCCESS) || ((*samples_per_frame) <= 0))
+  {
+    ALOGW ("%s: Failed to get block size (%d) (%d)!", __func__, func_ret, *samples_per_frame);
+    return LHDCV5_FRET_ERROR;
+  }
+
+  return LHDCV5_FRET_SUCCESS;
+}
+
+
+//----------------------------------------------------------------
+// lhdcv5BT_encode ()
+//
+// Encode pcm samples by LHDC 5.0
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		p_in_pcm: a pointer to a buffer contains PCM samples for encoding
+//		p_out_buf: a pointer to a buffer to put encoded stream
+//		out_buf_bytes: output buffer's size (in byte)
+//		p_out_bytes: a pointer to number of bytes of encoded stream in buffer
+//		p_out_frames: a pointer to number of frames of encoded stream in buffer
+//	Return
+//		LHDCV5_FRET_SUCCESS: succeed to encode pcm samples
+//		Other: fail to encode pcm samples
+//----------------------------------------------------------------
+int32_t lhdcv5BT_encode
+(
+    HANDLE_LHDCV5_BT 	handle,
+    void				* p_in_pcm,
+    uint32_t			pcm_bytes,
+    uint8_t				* p_out_buf,
+    uint32_t			out_buf_bytes,
+    uint32_t 			* p_out_bytes,
+    uint32_t 			* p_out_frames
+)
+{
+  int32_t		func_ret = LHDCV5_FRET_SUCCESS;
+
+  if (handle == NULL)
+  {
+    ALOGW ("%s: Handle is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_HANDLE_CB;
+  }
+
+  if ((p_in_pcm == NULL) || (p_out_buf == NULL) ||
+      (p_out_bytes == NULL) || (p_out_frames == NULL))
+  {
+    ALOGW ("%s: input parameter is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_INPUT_PARAM;
+  }
+
+  func_ret = lhdcv5_util_enc_process (handle,
+      p_in_pcm,
+      pcm_bytes,
+      p_out_buf,
+      out_buf_bytes,
+      p_out_bytes,
+      p_out_frames);
+
+  if (func_ret != LHDCV5_FRET_SUCCESS)
+  {
+    ALOGW ("%s: Failed to encode pcm samples (%d)!", __func__, func_ret);
+    return LHDCV5_FRET_ERROR;
+  }
+
+  return LHDCV5_FRET_SUCCESS;
+}
+
+
+
+/*
+ ******************************************************************
+ Extend API functions group
+ ******************************************************************
+ */
+static bool lhdcBT_code_ver_wrap
+(
+    unsigned char *pucConfig,
+    unsigned int *exFuncCode,
+    unsigned int *exFuncVer
+)
+{
+  *exFuncVer = (((unsigned int) pucConfig[3]) & ((unsigned int)0xff)) |
+      ((((unsigned int) pucConfig[2]) & ((unsigned int)0xff)) << 8)  |
+      ((((unsigned int) pucConfig[1]) & ((unsigned int)0xff)) << 16) |
+      ((((unsigned int) pucConfig[0]) & ((unsigned int)0xff)) << 24);
+
+  *exFuncCode = (((unsigned int) pucConfig[7]) & ((unsigned int)0xff)) |
+      ((((unsigned int) pucConfig[6]) & ((unsigned int)0xff)) << 8)  |
+      ((((unsigned int) pucConfig[5]) & ((unsigned int)0xff)) << 16) |
+      ((((unsigned int) pucConfig[4]) & ((unsigned int)0xff)) << 24);
+
+  return true;
+}
+
+//
+// META, JAS
+//
+//----------------------------------------------------------------
+// lhdcBT_set_cfg_meta_v1 ()
+//
+// Set configuration for meta data
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		userConfig: a pointer to configuration
+//		configLen: number of bytes of configuration
+//	Return
+//		EXTEND_FUNC_RET_OK: succeed to set configuration  
+//		Other: fail to set configuration.
+//----------------------------------------------------------------
+static int lhdcBT_set_cfg_meta_v1
+(
+    HANDLE_LHDCV5_BT 	handle,
+    const char			*userConfig,
+    const int 			configLen
+) 
+{
+  PST_LHDC_SET_META pset_meta = (PST_LHDC_SET_META) userConfig;
+  unsigned char	* pmeta_metadata = NULL;
+  int				func_ret = LHDCV5_FRET_SUCCESS;
+
+  if (handle == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: Handle is NULL (%p)!",  __func__, handle);
+    return EXTEND_FUNC_RET_INVALID_HANDLE;
+  }
+
+  if (userConfig == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: Config is NULL (%p)!",  __func__, userConfig);
+    return EXTEND_FUNC_RET_INVALID_PARAMETER;
+  }
+
+  if (configLen < (int) sizeof (ST_LHDC_SET_META))
+  {
+    // Buffer is to small
+    ALOGW ("(LHDC-exAPI) %s: Buffer too small (%d)!",  __func__, configLen);
+    return EXTEND_FUNC_RET_BUF_UNDERRUN;
+  }
+
+  if (pset_meta->meta_ver != META_ST_VER_V2)
+  {
+    ALOGW ("(LHDC-exAPI) %s: version is not match (%d)!",  __func__, pset_meta->meta_ver);
+    return EXTEND_FUNC_RET_INVALID_PARAMETER;
+  }
+
+  if (pset_meta->meta_mem_size != (int) sizeof (ST_LHDC_SET_META))
+  {
+    ALOGW("(LHDC-exAPI) %s: META data size is  not match (%d)!", __func__, pset_meta->meta_mem_size);
+    return EXTEND_FUNC_RET_INVALID_PARAMETER;
+  }
+
+  if (configLen < ((int) pset_meta->meta_metadata_length) + ((int) sizeof (ST_LHDC_SET_META)))
+  {
+    ALOGW("(LHDC-exAPI) %s: cfg size too small (%d)!", __func__, configLen);
+    return EXTEND_FUNC_RET_INVALID_PARAMETER;
+  }
+
+  pmeta_metadata = (uint8_t*) (pset_meta + 1);
+
+  func_ret = lhdcv5_util_set_ext_func_state (handle,
+      LHDCV5_EXT_FUNC_META,
+      pset_meta->meta_enable,
+      pmeta_metadata,
+      pset_meta->meta_metadata_length,
+      pset_meta->meta_set);
+
+  if (func_ret != LHDCV5_FRET_SUCCESS)
+  {
+    ALOGW ("(LHDC-exAPI) %s: Fail to set META data (%d)!",  __func__, func_ret);
+    return EXTEND_FUNC_RET_ERROR;
+  }
+
+  return EXTEND_FUNC_RET_OK;
+}
+
+
+//----------------------------------------------------------------
+// lhdcBT_get_cfg_meta_v1 ()
+//
+// Get configuration for meta data
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		userConfig: a pointer to configuration
+//		configLen: number of bytes of configuration
+//	Return
+//		EXTEND_FUNC_RET_OK: succeed to get configuration   
+//		Other: fail to get configuration.
+//----------------------------------------------------------------
+static int lhdcBT_get_cfg_meta_v1
+(
+    HANDLE_LHDCV5_BT 	handle,
+    char				* userConfig,
+    const int 			configLen
+) 
+{
+  PST_LHDC_GET_META pget_meta = (PST_LHDC_GET_META) userConfig;
+  bool 		jas_enabled = false;
+  bool		meta_enabled = false;
+  int			func_ret = LHDCV5_FRET_SUCCESS;
+
+
+  if (handle == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: Handle is NULL (%p)!",  __func__, handle);
+    return EXTEND_FUNC_RET_INVALID_HANDLE;
+  }
+
+  if (userConfig == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: User Config is NULL (%p)!",  __func__, userConfig);
+    return EXTEND_FUNC_RET_INVALID_PARAMETER;
+  }
+
+  if (configLen < (int) sizeof (ST_LHDC_GET_META))
+  {
+    // Buffer is to small
+    ALOGW ("(LHDC-exAPI) %s: Buffer too small (%d)!",  __func__, configLen);
+    return EXTEND_FUNC_RET_BUF_UNDERRUN;
+  }
+
+  func_ret = lhdcv5_util_get_ext_func_state (handle, LHDCV5_EXT_FUNC_META, &meta_enabled);
+  if (func_ret != LHDCV5_FRET_SUCCESS)
+  {
+    ALOGW ("(LHDC-exAPI) %s: Fail to get META flag (%d)!",  __func__, func_ret);
+    return EXTEND_FUNC_RET_ERROR;
+  }
+  ALOGW ("(LHDC-exAPI) %s: LHDCV5_EXT_FUNC_META: meta_enabled=%d",  __func__, meta_enabled);
+
+  func_ret = lhdcv5_util_get_ext_func_state (handle, LHDCV5_EXT_FUNC_JAS, &jas_enabled);
+  if (func_ret != LHDCV5_FRET_SUCCESS)
+  {
+    ALOGW ("(LHDC-exAPI) %s: Fail to get JAS flag (%d)!",  __func__, func_ret);
+    return EXTEND_FUNC_RET_ERROR;
+  }
+  ALOGW ("(LHDC-exAPI) %s: LHDCV5_EXT_FUNC_JAS: jas_enabled=%d",  __func__, jas_enabled);
+
+  pget_meta->meta_ver = META_ST_VER_V2;
+  pget_meta->meta_mem_size = (int) sizeof (ST_LHDC_GET_META);
+  pget_meta->meta_st = meta_enabled ? 0x03 : 0x01;  // Get current frame include metadata or not
+  pget_meta->jas_status = jas_enabled ? 1 : 0;
+
+  return EXTEND_FUNC_RET_OK;
+}
+
+
+//
+// AR Function
+//
+//----------------------------------------------------------------
+// lhdcBT_set_data_gyro_2d_v1 ()
+//
+// Set data for gyro (x, y)
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		userData: a pointer to data
+//		dataLen: number of bytes of data
+//	Return
+//		0: succeed to set data  
+//		Other: fail to set data.
+//----------------------------------------------------------------
+static int lhdcBT_set_data_gyro_2d_v1
+(
+    HANDLE_LHDCV5_BT 	handle,
+    const char 			* userData,
+    const int 			dataLen
+) 
+{
+  PST_LHDC_AR_GYRO pargyro = (PST_LHDC_AR_GYRO) userData;
+  int 		func_ret = LHDCV5_FRET_SUCCESS;
+
+  if (handle == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: Handle is NULL (%p)!",  __func__, handle);
+    return EXTEND_FUNC_RET_INVALID_HANDLE;
+  }
+
+  if (userData == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: User Data is NULL (%p)!",  __func__, userData);
+    return EXTEND_FUNC_RET_INVALID_PARAMETER;
+  }
+
+  if (dataLen < (int) sizeof (ST_LHDC_AR_GYRO))
+  {
+    // Buffer is to small
+    ALOGW ("(LHDC-exAPI) %s: Buffer too small (%d)!",  __func__, dataLen);
+    return EXTEND_FUNC_RET_BUF_UNDERRUN;
+  }
+
+
+  ALOGV ("(LHDC-exAPI) %s: set coordinate[x:%d y:%d z:%d]",  __func__,
+      pargyro->world_coordinate_x,
+      pargyro->world_coordinate_y,
+      pargyro->world_coordinate_z);
+
+  func_ret = lhdcv5_util_ar_set_gyro_pos (handle,
+      pargyro->world_coordinate_x,
+      pargyro->world_coordinate_y,
+      pargyro->world_coordinate_z);
+
+  if (func_ret != LHDCV5_FRET_SUCCESS)
+  {
+    ALOGD ("(LHDC-exAPI) %s: Fail to set gyro's position[x:%d y:%d z:%d] for AR (%d)!",  __func__,
+        pargyro->world_coordinate_x,
+        pargyro->world_coordinate_y,
+        pargyro->world_coordinate_z,
+        func_ret);
+    return EXTEND_FUNC_RET_ERROR;
+  }
+
+  return EXTEND_FUNC_RET_OK;
+}
+
+
+//----------------------------------------------------------------
+// lhdcBT_set_cfg_ar_v3 ()
+//
+// Set configuration for AR
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		userConfig: a pointer to configuration
+//		configLen: number of bytes of configuration
+//	Return
+//		0: succeed to set configuration  
+//		Other: fail to set configuration.
+//----------------------------------------------------------------
+static int lhdcBT_set_cfg_ar_v3
+(
+    HANDLE_LHDCV5_BT 	handle,
+    const char 			* userConfig,
+    const int 			configLen
+) 
+{
+  PST_LHDC_AR pset_ar_cfg = (PST_LHDC_AR) userConfig;
+  int 		func_ret = LHDCV5_FRET_SUCCESS;
+
+  if (handle == NULL)
+  {
+    ALOGW("(LHDC-exAPI) %s: Handle is NULL (%p)!",  __func__, handle);
+    return EXTEND_FUNC_RET_INVALID_HANDLE;
+  }
+
+  if (userConfig == NULL)
+  {
+    ALOGW("(LHDC-exAPI) %s: User Config is NULL (%p)!",  __func__, userConfig);
+    return EXTEND_FUNC_RET_INVALID_PARAMETER;
+  }
+
+  if (configLen < (int) sizeof (ST_LHDC_AR))
+  {
+    // Buffer is to small
+    ALOGW("(LHDC-exAPI) %s: Buffer too small (%d)!",  __func__, configLen);
+    return EXTEND_FUNC_RET_BUF_UNDERRUN;
+  }
+
+  ALOGD("(LHDC-exAPI) %s: ver(%d) size(%d) app_ar_enabled(%d) Ch_Pos(%d %d %d %d %d %d)"
+      , __func__,
+      pset_ar_cfg->ver,
+      pset_ar_cfg->size,
+      pset_ar_cfg->app_ar_enabled,
+      pset_ar_cfg->Ch1_Pos, pset_ar_cfg->Ch2_Pos, pset_ar_cfg->Ch2_Pos,
+      pset_ar_cfg->Ch4_Pos, pset_ar_cfg->Ch5_Pos, pset_ar_cfg->Ch6_Pos);
+
+  ALOGD("(LHDC-exAPI) %s: PreGain(L:R): ch1[%f:%f] ch2[%f:%f] ch3[%f:%f] ch4[%f:%f] ch5[%f:%f] ch6[%f:%f]"
+      , __func__,
+      pset_ar_cfg->Ch1_L_PreGain, pset_ar_cfg->Ch1_R_PreGain,
+      pset_ar_cfg->Ch2_L_PreGain, pset_ar_cfg->Ch2_R_PreGain,
+      pset_ar_cfg->Ch3_L_PreGain, pset_ar_cfg->Ch3_R_PreGain,
+      pset_ar_cfg->Ch4_L_PreGain, pset_ar_cfg->Ch4_R_PreGain,
+      pset_ar_cfg->Ch5_L_PreGain, pset_ar_cfg->Ch5_R_PreGain,
+      pset_ar_cfg->Ch6_L_PreGain, pset_ar_cfg->Ch6_R_PreGain);
+
+  ALOGD("(LHDC-exAPI) %s: PostGain: ch1[%f] ch2[%f] ch3[%f] ch4[%f] ch5[%f] ch6[%f]"
+      , __func__,
+      pset_ar_cfg->Ch1_PostGain, pset_ar_cfg->Ch2_PostGain,
+      pset_ar_cfg->Ch3_PostGain, pset_ar_cfg->Ch4_PostGain,
+      pset_ar_cfg->Ch5_PostGain, pset_ar_cfg->Ch6_PostGain);
+
+  ALOGD("(LHDC-exAPI) %s: Dry_Val(%f) Wet_Val(%f)" , __func__,
+      pset_ar_cfg->Dry_Val, pset_ar_cfg->Wet_Val);
+
+  ALOGD("(LHDC-exAPI) %s: Dis[%f %f %f %f %f] Rev[%f %f %f %f %f]" , __func__,
+      pset_ar_cfg->Dis_1, pset_ar_cfg->Dis_2, pset_ar_cfg->Dis_3, pset_ar_cfg->Dis_4, pset_ar_cfg->Dis_5,
+      pset_ar_cfg->Rev_1, pset_ar_cfg->Rev_2, pset_ar_cfg->Rev_3, pset_ar_cfg->Rev_4, pset_ar_cfg->Rev_5);
+
+  ALOGD("(LHDC-exAPI) %s: Rev_gain(%f) ThreeD_gain(%f)" , __func__,
+      pset_ar_cfg->Rev_gain, pset_ar_cfg->ThreeD_gain);
+
+  ALOGD ("(LHDC-exAPI) %s: to set AR enable: %d",  __func__, pset_ar_cfg->app_ar_enabled);
+  func_ret = lhdcv5_util_ar_set_cfg (handle,
+      &pset_ar_cfg->Ch1_Pos,
+      6,
+      &pset_ar_cfg->Ch1_L_PreGain,
+      32,
+      pset_ar_cfg->app_ar_enabled);
+
+  if (func_ret != LHDCV5_FRET_SUCCESS)
+  {
+    ALOGW ("(LHDC-exAPI) %s: func_ret %d",  __func__, func_ret);
+    return EXTEND_FUNC_RET_ERROR;
+  }
+
+  return EXTEND_FUNC_RET_OK;
+}
+
+
+//----------------------------------------------------------------
+// lhdcBT_get_cfg_ar_v1 ()
+//
+// Get configuration for AR
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		userConfig: a pointer to configuration
+//		configLen: number of bytes of configuration
+//	Return
+//		EXTEND_FUNC_RET_OK: succeed to get configuration   
+//		Other: fail to get configuration.
+//----------------------------------------------------------------
+static int lhdcBT_get_cfg_ar_v1
+(
+    HANDLE_LHDCV5_BT 	handle,
+    char 				* userConfig,
+    const int 			configLen
+) 
+{
+  PST_LHDC_AR pset_ar_cfg = (PST_LHDC_AR) userConfig;
+  int 		func_ret = LHDCV5_FRET_SUCCESS;
+
+  if (handle == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: Handle is NULL (%p)!",  __func__, handle);
+    return EXTEND_FUNC_RET_INVALID_HANDLE;
+  }
+
+  if (userConfig == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: User Config is NULL (%p)!",  __func__, userConfig);
+    return EXTEND_FUNC_RET_INVALID_PARAMETER;
+  }
+
+  if (configLen < (int) sizeof (ST_LHDC_AR))
+  {
+    // Buffer is to small
+    ALOGW ("(LHDC-exAPI) %s: Buffer too small (%d)!",  __func__, configLen);
+    return EXTEND_FUNC_RET_BUF_UNDERRUN;
+  }
+
+  func_ret = lhdcv5_util_ar_get_cfg (handle,
+      &pset_ar_cfg->Ch1_Pos,
+      6,
+      &pset_ar_cfg->Ch1_L_PreGain,
+      32);
+
+  if (func_ret != LHDCV5_FRET_SUCCESS)
+  {
+    ALOGW ("(LHDC-exAPI) %s: Fail to get AR config (%d)!",  __func__, func_ret);
+    return EXTEND_FUNC_RET_ERROR;
+  }
+
+  return EXTEND_FUNC_RET_OK;
+}
+
+// 1. API -- Set User Config (Extend)
+//----------------------------------------------------------------
+// lhdcv5BT_set_user_exconfig ()
+//
+// Set configuration
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		userConfig: a pointer to configuration
+//		clen: number of bytes of configuration
+//	Return
+//		EXTEND_FUNC_RET_OK: succeed to set configuration   
+//		Other: fail to set configuration.
+//----------------------------------------------------------------
+int lhdcv5BT_set_user_exconfig
+(
+    HANDLE_LHDCV5_BT 	handle,
+    const char			* userConfig,
+    const int 			clen
+) 
+{
+  unsigned char 	* pucConfig = (unsigned char *) userConfig;
+  unsigned int 	exFuncVer;
+  unsigned int 	exFuncCode;
+  int 			func_ret = EXTEND_FUNC_RET_OK;
+
+  if (handle == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: Handle is NULL (%p)!",  __func__, handle);
+    return EXTEND_FUNC_RET_INVALID_HANDLE;
+  }
+
+  if (userConfig == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: User Config is NULL (%p)!",  __func__, userConfig);
+    return EXTEND_FUNC_RET_INVALID_PARAMETER;
+  }
+
+  if (clen < (int) EXTEND_FUNC_MIN_BUFFER_LEN)
+  {
+    // Buffer is to small
+    ALOGW ("(LHDC-exAPI) %s: Buffer too small (%d)!",  __func__, clen);
+    return EXTEND_FUNC_RET_BUF_UNDERRUN;
+  }
+
+  lhdcBT_code_ver_wrap(pucConfig, &exFuncCode , &exFuncVer);
+
+  switch (exFuncCode)
+  {
+  case EXTEND_FUNC_CODE_SET_CONFIG_META:
+
+    switch (exFuncVer)
+    {
+    case EXTEND_FUNC_VER_SET_CONFIG_META_V1:
+      ALOGD ("(LHDC-exAPI) %s: SET_CONFIG_META",  __func__);
+      func_ret = lhdcBT_set_cfg_meta_v1 (handle, userConfig, clen);
+
+      if (func_ret != LHDCV5_FRET_SUCCESS)
+      {
+        ALOGW ("(LHDC-exAPI) %s: Fail to set META data (%d)!",  __func__, func_ret);
+        return EXTEND_FUNC_RET_ERROR;
+      }
+      break;
+
+    default:
+      ALOGW ("(LHDC-exAPI) %s: Invalid Ex. Function Version (0x%X)!",  __func__, exFuncVer);
+      return EXTEND_FUNC_RET_VERSION_NOT_SUPPORT;
+    }
+    break;
+
+    case EXTEND_FUNC_CODE_SET_CONFIG_AR:
+      switch (exFuncVer)
+      {
+      case EXTEND_FUNC_VER_SET_CONFIG_AR_V3:
+        ALOGD ("(LHDC-exAPI) %s: SET_CONFIG_AR",  __func__);
+        func_ret = lhdcBT_set_cfg_ar_v3 (handle, userConfig, clen);
+
+        if (func_ret != LHDCV5_FRET_SUCCESS)
+        {
+          ALOGW ("(LHDC-exAPI) %s: Fail to set AR config (%d)!",  __func__, func_ret);
+          return EXTEND_FUNC_RET_ERROR;
+        }
+        break;
+
+      default:
+        ALOGW ("(LHDC-exAPI) %s: Invalid Ex. Function Version (0x%X)!",  __func__, exFuncVer);
+        return EXTEND_FUNC_RET_VERSION_NOT_SUPPORT;
+      }
+      break;
+
+      default:
+        ALOGW ("(LHDC-exAPI) %s: Invalid Ex. Function Code (0x%X)!",  __func__, exFuncCode);
+        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+  } // switch (exFuncCode)
+
+  return EXTEND_FUNC_RET_OK;
+}
+
+
+// 2. API -- Get User Config (Extend)
+//----------------------------------------------------------------
+// lhdcv5BT_get_user_exconfig ()
+//
+// Get configuration
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		userConfig: a pointer to configuration
+//		clen: number of bytes of configuration
+//	Return
+//		EXTEND_FUNC_RET_OK: succeed to get configuration   
+//		Other: fail to get configuration.
+//----------------------------------------------------------------
+
+int lhdcv5BT_get_user_exconfig
+(
+    HANDLE_LHDCV5_BT 	handle,
+    char				* userConfig,
+    int 				clen
+) 
+{
+  unsigned char 	* pucConfig = (unsigned char *) userConfig;
+  unsigned int 	exFuncVer;
+  unsigned int 	exFuncCode;
+  int 			func_ret = EXTEND_FUNC_RET_OK;
+
+  if (handle == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: Handle is NULL (%p)!",  __func__, handle);
+    return EXTEND_FUNC_RET_INVALID_HANDLE;
+  }
+
+  if (userConfig == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: User Config is NULL (%p)!",  __func__, userConfig);
+    return EXTEND_FUNC_RET_INVALID_PARAMETER;
+  }
+
+  if (clen < (int)EXTEND_FUNC_MIN_BUFFER_LEN)
+  {
+    // Buffer is to small
+    ALOGW ("(LHDC-exAPI) %s: Buffer too small (%d)!",  __func__, clen);
+    return EXTEND_FUNC_RET_BUF_UNDERRUN;
+  }
+
+  lhdcBT_code_ver_wrap(pucConfig, &exFuncCode , &exFuncVer);
+
+  switch (exFuncCode)
+  {
+  case EXTEND_FUNC_CODE_GET_CONFIG_META:
+
+    switch (exFuncVer)
+    {
+    case EXTEND_FUNC_VER_GET_CONFIG_META_V1:
+      ALOGD ("(LHDC-exAPI) %s: GET_CONFIG_META",  __func__);
+      func_ret = lhdcBT_get_cfg_meta_v1 (handle, userConfig, clen);
+
+      if (func_ret != LHDCV5_FRET_SUCCESS)
+      {
+        ALOGW ("(LHDC-exAPI) %s: Fail to get META data (%d)!",  __func__, func_ret);
+        return EXTEND_FUNC_RET_ERROR;
+      }
+      break;
+
+    default:
+      ALOGW ("(LHDC-exAPI) %s: Invalid Ex. Function Version (0x%X)!",  __func__, exFuncVer);
+      return EXTEND_FUNC_RET_VERSION_NOT_SUPPORT;
+    }
+    break;
+
+    case EXTEND_FUNC_CODE_GET_CONFIG_AR:
+
+      switch (exFuncVer)
+      {
+      case EXTEND_FUNC_VER_GET_CONFIG_AR_V1:
+        ALOGD ("(LHDC-exAPI) %s: GET_CONFIG_AR",  __func__);
+        func_ret = lhdcBT_get_cfg_ar_v1 (handle, userConfig, clen);
+
+        if (func_ret != LHDCV5_FRET_SUCCESS)
+        {
+          ALOGW ("(LHDC-exAPI) %s: Fail to get AR config (%d)!",  __func__, func_ret);
+          return EXTEND_FUNC_RET_ERROR;
+        }
+        break;
+
+      default:
+        ALOGW ("(LHDC-exAPI) %s: Invalid Ex. Function Version (0x%X)!",  __func__, exFuncVer);
+        return EXTEND_FUNC_RET_VERSION_NOT_SUPPORT;
+      }
+      break;
+
+      default:
+        ALOGW ("(LHDC-exAPI) %s: Invalid Ex. Function Code (0x%X)!",  __func__, exFuncCode);
+        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+  } // switch (exFuncCode)
+
+
+  return EXTEND_FUNC_RET_OK;
+}
+
+
+// 3. API -- Set User Data (Extend)
+//----------------------------------------------------------------
+// lhdcv5BT_set_user_exdata ()
+//
+// Set data
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		userData: a pointer to data
+//		clen: number of bytes of data
+//	Return
+//		EXTEND_FUNC_RET_OK: succeed to set data   
+//		Other: fail to set data.
+//----------------------------------------------------------------
+void lhdcv5BT_set_user_exdata
+(
+    HANDLE_LHDCV5_BT 	handle,
+    const char			* userData,
+    const int 			clen
+) 
+{
+  unsigned char 	* pucData = (unsigned char *) userData;
+  unsigned int 	exFuncVer;
+  unsigned int 	exFuncCode;
+  int 			func_ret = EXTEND_FUNC_RET_OK;
+
+  if (handle == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: Handle is NULL (%p)!",  __func__, handle);
+    return; // EXTEND_FUNC_RET_INVALID_HANDLE;
+  }
+
+  if (userData == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: User Data is NULL (%p)!",  __func__, userData);
+    return; // EXTEND_FUNC_RET_INVALID_PARAMETER;
+  }
+
+  if (clen < (int) EXTEND_FUNC_MIN_BUFFER_LEN)
+  {
+    // Buffer is to small
+    ALOGW ("(LHDC-exAPI) %s: Buffer is too small (%d)!",  __func__, clen);
+    return;
+  }
+
+  lhdcBT_code_ver_wrap(pucData, &exFuncCode , &exFuncVer);
+
+  switch (exFuncCode)
+  {
+  case EXTEND_FUNC_CODE_SET_DATA_GYRO2D:
+
+    switch (exFuncVer)
+    {
+    case EXTEND_FUNC_VER_SET_DATA_GYRO2D_V1:
+      ALOGD ("(LHDC-exAPI) %s: SET_DATA_GYRO",  __func__);
+      func_ret = lhdcBT_set_data_gyro_2d_v1 (handle, userData, clen);
+
+      if (func_ret != LHDCV5_FRET_SUCCESS)
+      {
+        ALOGW ("(LHDC-exAPI) %s: Fail to get gyro's data (%d)!",  __func__, func_ret);
+        return;
+      }
+      break;
+
+    default:
+      ALOGW ("(LHDC-exAPI) %s: Invalid Ex. Function Version (0x%X)!",  __func__, exFuncVer);
+      break; // EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+    }
+    break;
+
+    default:
+      ALOGW ("(LHDC-exAPI) %s: Invalid Ex. Function Code (0x%X)!",  __func__, exFuncCode);
+      break;
+  } // switch (exFuncCode)
+
+  return;
+}
+
+
+// 4. API -- Get Version
+//----------------------------------------------------------------
+// lhdcv5BT_get_user_exApiver ()
+//
+// Get version
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		version: a pointer to version
+//		clen: number of bytes of version
+//	Return
+//		0: succeed to set data   
+//		Other: fail to set data.
+//----------------------------------------------------------------
+int lhdcv5BT_get_user_exApiver
+(
+    HANDLE_LHDCV5_BT 	handle,
+    char 				* version,
+    int 				clen
+) 
+{
+  unsigned char 	* pucApiVer = (unsigned char *) version;
+  unsigned int 	exFuncVer = 0;
+  unsigned int 	exFuncCode = 0;
+
+  if (handle == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: Handle is NULL (%p)!",  __func__, handle);
+    return EXTEND_FUNC_RET_INVALID_HANDLE;
+  }
+
+  if (version == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: API verion pointer is NULL (%p)!",  __func__, version);
+    return EXTEND_FUNC_RET_INVALID_PARAMETER;
+  }
+
+  if (clen < (int)EXTEND_FUNC_MIN_BUFFER_LEN)
+  {
+    // Buffer is to small
+    ALOGW ("(LHDC-exAPI) %s: Buffer too small (%d)!",  __func__, clen);
+    return EXTEND_FUNC_RET_BUF_UNDERRUN;
+  }
+
+  lhdcBT_code_ver_wrap(pucApiVer, &exFuncCode , &exFuncVer);
+
+  switch (exFuncCode)
+  {
+  // Config APIs:
+  case EXTEND_FUNC_CODE_SET_CONFIG_META:
+    exFuncVer = EXTEND_FUNC_VER_SET_CONFIG_META_V1;
+    break;
+
+  case EXTEND_FUNC_CODE_SET_CONFIG_AR:
+    exFuncVer = EXTEND_FUNC_VER_SET_CONFIG_AR_V3;
+    break;
+
+  case EXTEND_FUNC_CODE_GET_CONFIG_META:
+    exFuncVer = EXTEND_FUNC_VER_GET_CONFIG_META_V1;
+    break;
+
+  case EXTEND_FUNC_CODE_GET_CONFIG_AR:
+    exFuncVer = EXTEND_FUNC_VER_GET_CONFIG_AR_V1;
+    break;
+
+    // Data APIs:
+  case EXTEND_FUNC_CODE_SET_DATA_GYRO2D:
+    exFuncVer = EXTEND_FUNC_VER_SET_DATA_GYRO2D_V1;
+    break;
+
+    // A2DP codec config APIs:
+  case EXTEND_FUNC_CODE_GET_SPECIFIC:
+    exFuncVer = EXTEND_FUNC_VER_GET_SPECIFIC_V2;
+    break;
+
+  default:
+    ALOGW ("(LHDC-exAPI) %s: Invalid Ex. Function Code (0x%X)!",  __func__, exFuncCode);
+    return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+  } // switch (exFuncCode)
+
+  // fill version of target API
+  pucApiVer[3] = (unsigned char) (exFuncVer & ((unsigned int)0xff));
+  pucApiVer[2] = (unsigned char) ((exFuncVer >> 8) & ((unsigned int)0xff));
+  pucApiVer[1] = (unsigned char) ((exFuncVer >> 16) & ((unsigned int)0xff));
+  pucApiVer[0] = (unsigned char) ((exFuncVer >> 24) & ((unsigned int)0xff));
+
+  ALOGD ("(LHDC-exAPI) %s: APICode:[%02X %02X %02X %02X] Ver:[%02X %02X %02X %02X]",  __func__,
+      pucApiVer[4],
+      pucApiVer[5],
+      pucApiVer[6],
+      pucApiVer[7],
+      pucApiVer[0],
+      pucApiVer[1],
+      pucApiVer[2],
+      pucApiVer[3]);
+
+  return EXTEND_FUNC_RET_OK;
+}
+
diff --git a/external/liblhdcv5dec/Android.bp b/external/liblhdcv5dec/Android.bp
new file mode 100755
index 00000000..942aadb6
--- /dev/null
+++ b/external/liblhdcv5dec/Android.bp
@@ -0,0 +1,50 @@
+
+cc_prebuilt_library_shared {
+    name: "liblhdcv5dec",
+    
+    export_include_dirs: ["include"],
+    arch: {
+        arm: {
+            srcs: ["libs/armeabi-v7a/liblhdcv5dec.so",],
+        },
+        arm64: {
+            srcs: ["libs/arm64-v8a/liblhdcv5dec.so",],
+        },
+    },
+
+    strip: {
+        none:true,
+    },
+
+    shared_libs: [
+        "liblog",
+        "libstdc++",
+    ],
+}
+
+cc_library_shared {
+    name: "liblhdcv5BT_dec",
+    //vendor_available: true,
+    //vndk: {
+    //    enabled: true,
+    //},
+    arch: {
+        arm: {
+            instruction_set: "arm",
+        },
+    },
+    export_include_dirs: ["inc"],
+    local_include_dirs: ["inc", "include", ],
+    srcs: [
+        "src/lhdcv5BT_dec.c",
+    ],
+    // -D_32BIT_FIXED_POINT should be added to cflags for devices without a FPU
+    // unit such as ARM Cortex-R series or external 32-bit DSPs.
+    cflags: ["-O2", "-Wall", "-Wextra", "-Wmacro-redefined"],
+
+    shared_libs: [
+        "libcutils",
+        "liblog",
+        "liblhdcv5dec",
+    ],
+}
diff --git a/external/liblhdcv5dec/CHANGES b/external/liblhdcv5dec/CHANGES
new file mode 100755
index 00000000..123e8633
--- /dev/null
+++ b/external/liblhdcv5dec/CHANGES
@@ -0,0 +1,7 @@
+Release Note.
+=========================================================
+Jun 21, 2022, by jimmy.chen@savitech.co
+  *Update version to 5.0.5
+
+Feb, 21, 2022, by jimmy.chen@savitech.co
+  *Add LHDCV5 Decoder v5.0.1
diff --git a/external/liblhdcv5dec/LICENSE b/external/liblhdcv5dec/LICENSE
new file mode 100755
index 00000000..261eeb9e
--- /dev/null
+++ b/external/liblhdcv5dec/LICENSE
@@ -0,0 +1,201 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/external/liblhdcv5dec/MODULE_LICENSE_APACHE2 b/external/liblhdcv5dec/MODULE_LICENSE_APACHE2
new file mode 100755
index 00000000..e69de29b
diff --git a/external/liblhdcv5dec/NOTICE b/external/liblhdcv5dec/NOTICE
new file mode 100755
index 00000000..ea044d3b
--- /dev/null
+++ b/external/liblhdcv5dec/NOTICE
@@ -0,0 +1,27 @@
+/******************************************************************************
+ *
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ *****************************************************************************
+ * Originally developed and contributed by Ittiam Systems Pvt. Ltd, Bangalore
+ */
+
+---------------
+ Certification
+---------------
+   Taking the certification process is required to use LHDC in your products.
+   For the detail of certification process, see the following URL:
+      https://www.savitech.co/
+
diff --git a/external/liblhdcv5dec/inc/lhdcv5BT_dec.h b/external/liblhdcv5dec/inc/lhdcv5BT_dec.h
new file mode 100755
index 00000000..6e50bd9c
--- /dev/null
+++ b/external/liblhdcv5dec/inc/lhdcv5BT_dec.h
@@ -0,0 +1,69 @@
+#ifndef _LHDCV5BT_DEC_H_
+#define _LHDCV5BT_DEC_H_
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "lhdcv5_util_dec.h"
+
+#define LHDCV5BT_SAMPLE_RATE_44K    (44100)
+#define LHDCV5BT_SAMPLE_RATE_48K    (48000)
+#define LHDCV5BT_SAMPLE_RATE_96K    (96000)
+#define LHDCV5BT_SAMPLE_RATE_192K   (192000)
+
+#define LHDCV5BT_BIT_DEPTH_16    (16)
+#define LHDCV5BT_BIT_DEPTH_24    (24)
+#define LHDCV5BT_BIT_DEPTH_32    (32)
+
+#define LHDCV5BT_BIT_RATE_64K    (64000)
+#define LHDCV5BT_BIT_RATE_128K   (128000)
+#define LHDCV5BT_BIT_RATE_192K   (192000)
+#define LHDCV5BT_BIT_RATE_256K   (256000)
+#define LHDCV5BT_BIT_RATE_320K   (320000)
+#define LHDCV5BT_BIT_RATE_400K   (400000)
+#define LHDCV5BT_BIT_RATE_600K   (600000)
+#define LHDCV5BT_BIT_RATE_900K   (900000)
+#define LHDCV5BT_BIT_RATE_1000K  (1000000)
+
+
+
+typedef struct  
+{
+  lhdc_ver_t version;
+  uint32_t sample_rate;
+  uint32_t bits_depth;
+  uint32_t bit_rate;
+} tLHDCV5_DEC_CONFIG;
+
+
+// lib APIs
+int32_t lhdcv5BT_dec_init_decoder(HANDLE_LHDCV5_BT *handle, tLHDCV5_DEC_CONFIG *config);
+int32_t lhdcv5BT_dec_check_frame_data_enough(const uint8_t *frameData, uint32_t frameBytes, uint32_t *packetBytes);
+int32_t lhdcv5BT_dec_decode(const uint8_t *frameData, uint32_t frameBytes, uint8_t* pcmData, uint32_t* pcmBytes, uint32_t bits_depth);
+int32_t lhdcv5BT_dec_deinit_decoder(HANDLE_LHDCV5_BT handle);
+
+#define LHDCBT_DEC_NOT_UPD_SEQ_NO			0
+#define LHDCBT_DEC_UPD_SEQ_NO				1
+
+typedef enum __LHDCV5BT_DEC_API_RET__
+{
+  LHDCV5BT_DEC_API_SUCCEED            =  0,
+  LHDCV5BT_DEC_API_FAIL               = -1,
+  LHDCV5BT_DEC_API_INVALID_INPUT      = -2,
+  LHDCV5BT_DEC_API_INVALID_OUTPUT     = -3,
+  LHDCV5BT_DEC_API_INVALID_SEQ_NO     = -4,
+  LHDCV5BT_DEC_API_INIT_DECODER_FAIL  = -5,
+  LHDCV5BT_DEC_API_CHANNEL_SETUP_FAIL = -6,
+  LHDCV5BT_DEC_API_FRAME_INFO_FAIL    = -7,
+  LHDCV5BT_DEC_API_INPUT_NOT_ENOUGH   = -8,
+  LHDCV5BT_DEC_API_OUTPUT_NOT_ENOUGH  = -9,
+  LHDCV5BT_DEC_API_DECODE_FAIL        = -10,
+  LHDCV5BT_DEC_API_ALLOC_MEM_FAIL  = -11,
+
+} LHDCV5BT_DEC_API_RET_T;
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _LHDCBT_DEC_H_ */
diff --git a/external/liblhdcv5dec/include/lhdcv5Util.h b/external/liblhdcv5dec/include/lhdcv5Util.h
new file mode 100644
index 00000000..733bd567
--- /dev/null
+++ b/external/liblhdcv5dec/include/lhdcv5Util.h
@@ -0,0 +1,98 @@
+/*
+ * lhdcv5Util.h
+ *
+ *  Created on: 2022/03/18
+ *      Author: jimmy chen
+ */
+
+#ifndef LHDC_UTIL_H
+#define LHDC_UTIL_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// Copy definition from external
+#define BTIF_BD_ADDR_SIZE    6
+
+// Define for LHDC stream type.
+typedef enum {
+  LHDC_STRM_TYPE_COMBINE,
+  LHDC_STRM_TYPE_SPLIT
+}LHDC_STRM_TYPE;
+
+typedef enum {
+  VERSION_2 = 200,
+  VERSION_3 = 300,
+  VERSION_4 = 400,
+  VERSION_LLAC = 500,
+  VERSION_5 = 550
+}lhdc_ver_t;
+
+typedef enum {
+  LHDCV2_BLOCK_SIZE = 512,
+  LHDCV3_BLOCK_SIZE = 256,
+}lhdc_block_size_t;
+
+typedef struct savi_bt_local_info_t{
+  uint8_t bt_addr[BTIF_BD_ADDR_SIZE];
+  const char *bt_name;
+  uint8_t bt_len;
+  uint8_t ble_addr[BTIF_BD_ADDR_SIZE];
+  const char *ble_name;
+  uint8_t ble_len;
+}savi_bt_local_info;
+
+typedef struct _lhdc_frame_Info
+{
+  uint32_t frame_len;
+  uint32_t isSplit;
+  uint32_t isLeft;
+
+} lhdc_frame_Info_t;
+
+
+typedef enum {
+  LHDC_OUTPUT_STEREO = 0,
+  LHDC_OUTPUT_LEFT_CAHNNEL,
+  LHDC_OUTPUT_RIGHT_CAHNNEL,
+} lhdc_channel_t;
+
+typedef int LHDCSample;
+
+typedef void (*print_log_fp)(char*  msg);
+typedef int (*LHDC_GET_BT_INFO)(savi_bt_local_info * bt_info);
+
+
+
+#define A2DP_LHDC_HDR_LATENCY_LOW   0x00
+#define A2DP_LHDC_HDR_LATENCY_MID   0x01
+#define A2DP_LHDC_HDR_LATENCY_HIGH  0x02
+#define A2DP_LHDC_HDR_LATENCY_MASK  (A2DP_LHDC_HDR_LATENCY_MID | A2DP_LHDC_HDR_LATENCY_HIGH)
+
+#define A2DP_LHDC_HDR_FRAME_NO_MASK 0xfc
+
+
+int32_t lhdcv5_util_init_decoder(uint32_t bitPerSample, uint32_t sampleRate, uint32_t scaleTo16Bits, lhdc_ver_t version);
+uint32_t lhdcv5_util_dec_put_data(uint8_t * pInpBuf, uint32_t NumBytes);
+uint32_t lhdcv5_util_dec_process(uint8_t * pOutBuf, uint8_t * pInput, uint32_t len);
+bool lhdcv5_util_set_license(uint8_t * licTable, LHDC_GET_BT_INFO pFunc);
+int32_t lhdcv5_util_set_license_check_period (uint8_t period);
+char *lhdcv5_util_dec_get_version();
+
+int32_t lhdcv5_util_dec_destroy();
+
+void lhdc_register_log_cb(print_log_fp cb);
+
+uint32_t lhdcv5_util_dec_get_sample_size (void);
+bool lhdcv5_util_dec_fetch_frame_info(uint8_t * frameData, lhdc_frame_Info_t * frameInfo);
+
+uint32_t lhdcv5_util_dec_channel_selsect(lhdc_channel_t channel_type);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* End of LHDC_UTIL_H */
diff --git a/external/liblhdcv5dec/include/lhdcv5_util_dec.h b/external/liblhdcv5dec/include/lhdcv5_util_dec.h
new file mode 100755
index 00000000..576d8c5c
--- /dev/null
+++ b/external/liblhdcv5dec/include/lhdcv5_util_dec.h
@@ -0,0 +1,100 @@
+/*
+ * lhdcv5_util_dec.h
+ *
+ */
+
+#ifndef LHDCV5_UTIL_DEC_H
+#define LHDCV5_UTIL_DEC_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef void * HANDLE_LHDCV5_BT;
+
+// Copy definition from external
+#define BTIF_BD_ADDR_SIZE    6
+
+// Define for LHDC stream type.
+typedef enum {
+  LHDC_STRM_TYPE_COMBINE,
+  LHDC_STRM_TYPE_SPLIT
+}LHDC_STRM_TYPE;
+
+typedef enum {
+  VERSION_5 = 550
+}lhdc_ver_t;
+
+typedef enum {
+  LHDCV2_BLOCK_SIZE = 512,
+  LHDCV3_BLOCK_SIZE = 256,
+}lhdc_block_size_t;
+
+typedef struct savi_bt_local_info_t{
+  uint8_t bt_addr[BTIF_BD_ADDR_SIZE];
+  const char *bt_name;
+  uint8_t bt_len;
+  uint8_t ble_addr[BTIF_BD_ADDR_SIZE];
+  const char *ble_name;
+  uint8_t ble_len;
+}savi_bt_local_info;
+
+typedef struct _lhdc_frame_Info
+{
+  uint32_t frame_len;
+  uint32_t isSplit;
+  uint32_t isLeft;
+
+} lhdc_frame_Info_t;
+
+
+typedef enum {
+  LHDC_OUTPUT_STEREO = 0,
+  LHDC_OUTPUT_LEFT_CAHNNEL,
+  LHDC_OUTPUT_RIGHT_CAHNNEL,
+} lhdc_channel_t;
+
+typedef int LHDCSample;
+
+typedef void (*print_log_fp)(char*  msg);
+typedef int (*LHDC_GET_BT_INFO)(savi_bt_local_info * bt_info);
+
+
+
+#define A2DP_LHDC_HDR_LATENCY_LOW   0x00
+#define A2DP_LHDC_HDR_LATENCY_MID   0x01
+#define A2DP_LHDC_HDR_LATENCY_HIGH  0x02
+#define A2DP_LHDC_HDR_LATENCY_MASK  (A2DP_LHDC_HDR_LATENCY_MID | A2DP_LHDC_HDR_LATENCY_HIGH)
+
+#define A2DP_LHDC_HDR_FRAME_NO_MASK 0xfc
+
+
+int32_t lhdcv5_util_init_decoder(uint32_t *ptr, uint32_t bitPerSample, uint32_t sampleRate, uint32_t scaleTo16Bits, lhdc_ver_t version);
+
+int32_t lhdcv5_util_dec_process(uint8_t * pOutBuf, uint8_t * pInput, uint32_t InLen, uint32_t *OutLen);
+char *lhdcv5_util_dec_get_version();
+
+int32_t lhdcv5_util_dec_destroy();
+
+void lhdcv5_util_dec_register_log_cb(print_log_fp cb);
+
+int32_t lhdcv5_util_dec_get_sample_size (uint32_t *frame_samples);
+int32_t lhdcv5_util_dec_fetch_frame_info(uint8_t *frameData, uint32_t frameDataLen, lhdc_frame_Info_t *frameInfo);
+
+int32_t lhdcv5_util_dec_channel_selsect(lhdc_channel_t channel_type);
+int32_t lhdcv5_util_dec_get_mem_req(lhdc_ver_t version, uint32_t *mem_req_bytes);
+
+//Return
+#define LHDCV5_UTIL_DEC_SUCCESS 0
+#define LHDCV5_UTIL_DEC_ERROR_NO_INIT -1
+#define LHDCV5_UTIL_DEC_ERROR_PARAM -2
+#define LHDCV5_UTIL_DEC_ERROR -3
+#define LHDCV5_UTIL_DEC_ERROR_WRONG_DEC -10
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* End of LHDCV5_UTIL_DEC_H */
diff --git a/external/liblhdcv5dec/libs/arm64-v8a/liblhdcv5dec.so b/external/liblhdcv5dec/libs/arm64-v8a/liblhdcv5dec.so
new file mode 100755
index 00000000..bdb2d245
Binary files /dev/null and b/external/liblhdcv5dec/libs/arm64-v8a/liblhdcv5dec.so differ
diff --git a/external/liblhdcv5dec/libs/armeabi-v7a/liblhdcv5dec.so b/external/liblhdcv5dec/libs/armeabi-v7a/liblhdcv5dec.so
new file mode 100755
index 00000000..c68665b3
Binary files /dev/null and b/external/liblhdcv5dec/libs/armeabi-v7a/liblhdcv5dec.so differ
diff --git a/external/liblhdcv5dec/src/lhdcv5BT_dec.c b/external/liblhdcv5dec/src/lhdcv5BT_dec.c
new file mode 100755
index 00000000..92f1534d
--- /dev/null
+++ b/external/liblhdcv5dec/src/lhdcv5BT_dec.c
@@ -0,0 +1,409 @@
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include "lhdcv5BT_dec.h"
+
+#define LOG_NDEBUG 0
+#define LOG_TAG "lhdcv5BT_dec"
+#include <cutils/log.h>
+
+static uint8_t serial_no = 0xff;
+
+// description
+//   a function to log in LHDC decoder library
+// Parameter
+//   msg: char string to print
+static void print_log_cb(char *msg)
+{
+  if (msg == NULL) {
+    return;
+  }
+
+  ALOGD("[V5Dec_lib] %s", msg);
+}
+
+
+// description
+//   check number of frames in one packet and return pointer to first byte of 1st frame in current packet
+// Parameter
+//   input: pointer to input buffer
+//   input_len: length (bytes) of input buffer pointed by input
+//   pLout: pointer to pointer to output buffer
+//   pLlen: length (bytes) of encoded stream in output buffer
+//   upd_seq_no: sequence number type
+// return:
+//   > 0: number of frames in current packet
+//   == 0: No frames in current packet
+//   < 0: error
+static int32_t assemble_lhdcv5_packet(uint32_t *frame_num, uint8_t *input, uint32_t input_len,
+    uint8_t **pLout, uint32_t *pLlen, int upd_seq_no)
+{
+  uint8_t hdr = 0, seqno = 0xff;
+  uint32_t status = 0;
+  uint32_t lhdc_total_frame_nb = 0;
+
+  if ((input == NULL) ||
+      (pLout == NULL) ||
+      (pLlen == NULL)) {
+    ALOGD("%s: null ptr", __func__);
+    return -1;
+  }
+
+  if (input_len < 2) {
+    ALOGD("%s: input len too small", __func__);
+    return -1;
+  }
+
+  hdr = (*input);
+  input++;
+  seqno = (*input);
+  input++;
+  input_len -= 2;
+
+  //Check latency and update value when changed.
+  status = hdr & A2DP_LHDC_HDR_LATENCY_MASK;
+
+  //Get number of frame in packet.
+  status = (hdr & A2DP_LHDC_HDR_FRAME_NO_MASK) >> 2;
+
+  if (status <= 0) {
+    ALOGD("%s: no any frame in packet.", __func__);
+    *frame_num = 0;
+    return 0;
+  }
+
+  lhdc_total_frame_nb = status;
+
+  if (seqno != serial_no) {
+    ALOGD("%s: packet lost! now(%d), expect(%d)", __func__, seqno, serial_no);
+    //serial_no = seqno;
+    //return -1;
+  }
+
+  if (upd_seq_no == LHDCBT_DEC_UPD_SEQ_NO) {
+    serial_no = seqno + 1;
+  }
+
+  *pLlen = input_len;
+  *pLout = input;
+
+  *frame_num = (int) lhdc_total_frame_nb;
+
+  ALOGD("%s: total frame number (%d)", __func__, *frame_num);
+  return 0;
+}
+
+
+// description
+//   init. LHDC V5 decoder
+// Parameter
+//   handle: codec handle(ptr for heap) from bt stack
+//   config: configuration for LHDC V5 decoder
+// return:
+//   == 0: succeed
+//   != 0: error code
+int32_t lhdcv5BT_dec_init_decoder(HANDLE_LHDCV5_BT *handle, tLHDCV5_DEC_CONFIG *config)
+{
+  int32_t func_ret = LHDCV5_UTIL_DEC_SUCCESS;
+  uint32_t mem_req_bytes = 0;
+  HANDLE_LHDCV5_BT hLhdcBT = NULL;
+
+  ALOGD("%s: decoder lib version = %s", __func__, lhdcv5_util_dec_get_version());
+
+  if (handle == NULL || config == NULL) {
+    ALOGD("%s: null ptr handle %p config %p", __func__, handle, config);
+    return LHDCV5BT_DEC_API_INVALID_INPUT;
+  }
+
+  ALOGD("%s: bits_depth:%u sample_rate=%u bit_rate=%u version=%d", __func__,
+      config->bits_depth, config->sample_rate, config->bit_rate, config->version);
+
+  if ((config->bits_depth != LHDCV5BT_BIT_DEPTH_16) &&
+      (config->bits_depth != LHDCV5BT_BIT_DEPTH_24) &&
+      (config->bits_depth != LHDCV5BT_BIT_DEPTH_32)) {
+    ALOGD("%s: bits_depth %d not supported", __func__, config->bits_depth);
+    return LHDCV5BT_DEC_API_INVALID_INPUT;
+  }
+
+  if ((config->sample_rate != LHDCV5BT_SAMPLE_RATE_44K) &&
+      (config->sample_rate != LHDCV5BT_SAMPLE_RATE_48K) &&
+      (config->sample_rate != LHDCV5BT_SAMPLE_RATE_96K) &&
+      (config->sample_rate != LHDCV5BT_SAMPLE_RATE_192K)) {
+    ALOGD("%s: sample_rate %d not supported", __func__, config->sample_rate);
+    return LHDCV5BT_DEC_API_INVALID_INPUT;
+  }
+
+  if ((0 > config->bit_rate) || (config->bit_rate > LHDCV5BT_BIT_RATE_1000K)) {
+    ALOGD("%s: bit_rate %d not supported", __func__, config->bit_rate);
+    return LHDCV5BT_DEC_API_INVALID_INPUT;
+  }
+
+  if ((config->version != VERSION_5)) {
+    ALOGD("%s: version %d not supported", __func__, config->version);
+    return LHDCV5BT_DEC_API_INVALID_INPUT;
+  }
+
+  lhdcv5_util_dec_register_log_cb(&print_log_cb);
+
+  func_ret = lhdcv5_util_dec_get_mem_req(config->version, &mem_req_bytes);
+  if (func_ret != LHDCV5_UTIL_DEC_SUCCESS || mem_req_bytes <= 0) {
+    ALOGW("%s: Fail to get required memory size (%d)!", __func__, func_ret);
+    return LHDCV5BT_DEC_API_ALLOC_MEM_FAIL;
+  }
+
+  hLhdcBT = (HANDLE_LHDCV5_BT)malloc(mem_req_bytes);
+  if (hLhdcBT == NULL) {
+    ALOGW ("%s: Fail to allocate memory!", __func__);
+    return LHDCV5BT_DEC_API_ALLOC_MEM_FAIL;
+  }
+
+  ALOGD("%s: init lhdcv5 decoder...", __func__);
+  //TODO: send mem_req_bytes for size check
+  func_ret = lhdcv5_util_init_decoder(hLhdcBT, config->bits_depth,
+      config->sample_rate, config->bit_rate, config->version);
+  if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
+    ALOGW ("%s: failed to init decoder (%d)!", __func__, func_ret);
+    free(hLhdcBT);
+    return LHDCV5BT_DEC_API_INIT_DECODER_FAIL;
+  }
+
+  *handle = hLhdcBT;
+  if ((*handle) == NULL) {
+    ALOGW ("%s: handle return NULL!", __func__);
+    return LHDCV5BT_DEC_API_INIT_DECODER_FAIL;
+  }
+
+  func_ret = lhdcv5_util_dec_channel_selsect(LHDC_OUTPUT_STEREO);
+  if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
+    ALOGW ("%s: failed to configure channel (%d)!", __func__, func_ret);
+    return LHDCV5BT_DEC_API_CHANNEL_SETUP_FAIL;
+  }
+
+  serial_no = 0xff;
+
+  ALOGD("%s: init lhdcv5 decoder success", __func__);
+  return LHDCV5BT_DEC_API_SUCCEED;
+}
+
+
+// description
+//   check whether all frames of one packet are in buffer?
+// Parameter
+//   frameData: pointer to input buffer
+//   frameBytes: length (bytes) of input buffer pointed by frameData
+//   packetBytes: return the final number of queued data in decoder lib (for validation)
+// return:
+//   == 0: succeed
+//   < 0: error
+int32_t lhdcv5BT_dec_check_frame_data_enough(const uint8_t *frameData,
+    uint32_t frameBytes, uint32_t *packetBytes)
+{
+  uint8_t *frameDataStart = (uint8_t *)frameData;
+  uint8_t *in_buf = NULL;
+  uint32_t in_len = 0;
+  uint32_t frame_num = 0;
+  lhdc_frame_Info_t lhdc_frame_Info;
+  uint32_t ptr_offset = 0;
+  int32_t func_ret = LHDCV5_UTIL_DEC_SUCCESS;
+
+  if ((frameData == NULL) || (packetBytes == NULL)) {
+    return LHDCV5_UTIL_DEC_ERROR_PARAM;
+  }
+
+  *packetBytes = 0;
+
+  func_ret = assemble_lhdcv5_packet(&frame_num, frameDataStart, frameBytes, &in_buf, &in_len,
+      LHDCBT_DEC_NOT_UPD_SEQ_NO);
+  if (func_ret < 0 || in_buf == NULL) {
+    ALOGE("%s: failed setup input buffer", __func__);
+    return LHDCV5BT_DEC_API_FAIL;
+  }
+
+  if (frame_num == 0) {
+    return LHDCV5BT_DEC_API_SUCCEED;
+  }
+
+  ALOGD("%s: incoming frame size(%d), decoding size(%d), total frame num(%d)", __func__,
+      frameBytes, in_len, frame_num);
+
+  ptr_offset = 0;
+
+  while ((frame_num > 0) && (ptr_offset < in_len))
+  {
+    func_ret = lhdcv5_util_dec_fetch_frame_info(in_buf + ptr_offset, in_len, &lhdc_frame_Info);
+    if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
+      ALOGD("%s: fetch frame info fail (%d)", __func__, func_ret);
+      return LHDCV5BT_DEC_API_FRAME_INFO_FAIL;
+    }
+
+    ALOGV("%s: frame_num[%d]: ptr_offset (%d), frame_len (%d)", __func__,
+        (int)frame_num, (int)ptr_offset, (int)lhdc_frame_Info.frame_len);
+
+    if ((ptr_offset + lhdc_frame_Info.frame_len) > in_len) {
+      ALOGD(" %s: frame_num[%d]: Not Enough... ptr_offset(%d), frame_len(%d)",
+          __func__, (int)frame_num, (int)ptr_offset, (int)lhdc_frame_Info.frame_len);
+      return LHDCV5BT_DEC_API_INPUT_NOT_ENOUGH;
+    }
+
+    ptr_offset += lhdc_frame_Info.frame_len;
+
+    frame_num--;
+  }
+
+  *packetBytes = ptr_offset;
+
+  return LHDCV5BT_DEC_API_SUCCEED;
+}
+
+
+// description
+//   decode all frames in one packet
+// Parameter
+//   frameData: pointer to input buffer from bt stack
+//   frameBytes: length (bytes) of input buffer pointed by frameData
+//   pcmData: pointer to output buffer to bt stack
+//   pcmBytes: length (bytes) of pcm samples in output buffer
+//   bits_depth: bit per sample
+// return:
+//   == 0: succeed
+//   < 0: error
+int32_t lhdcv5BT_dec_decode(const uint8_t *frameData, uint32_t frameBytes,
+    uint8_t *pcmData, uint32_t *pcmBytes, uint32_t bits_depth)
+{
+  uint8_t *frameDataStart = (uint8_t *)frameData;
+  uint32_t dec_sum = 0;
+  uint32_t lhdc_out_len = 0;
+  uint8_t *in_buf = NULL;   //buffer position to input to decode process
+  uint32_t in_len = 0;
+  uint32_t frame_num = 0;
+  lhdc_frame_Info_t lhdc_frame_Info;
+  uint32_t ptr_offset = 0;
+  uint32_t frame_samples;
+  uint32_t frame_bytes;
+  uint32_t pcmSpaceBytes;
+  int32_t func_ret = LHDCV5_UTIL_DEC_SUCCESS;
+
+  ALOGV("%s: enter frameBytes %d", __func__, (int)frameBytes);
+
+  if ((frameData == NULL) ||
+      (pcmData == NULL) ||
+      (pcmBytes == NULL)) {
+    return LHDCV5BT_DEC_API_INVALID_INPUT;
+  }
+
+  pcmSpaceBytes = *pcmBytes;
+  *pcmBytes = 0;
+
+  /*
+  if(frameBytes >= 16) {
+    for(int i=0; i<16; i++) {
+      ALOGD(" %s: dumpFrame[%d]= 0x%02X", __func__, i, (int)*(frameDataStart+i));
+    }
+  } else {
+    for(int i=0; i<(int)frameBytes; i++) {
+      ALOGD(" %s: dumpFrame[%d]= 0x%02X", __func__, i, (int)*(frameDataStart+i));
+    }
+  }
+   */
+
+  func_ret = assemble_lhdcv5_packet(&frame_num, frameDataStart, frameBytes, &in_buf, &in_len,
+      LHDCBT_DEC_UPD_SEQ_NO);
+  if (func_ret < 0 || in_buf == NULL) {
+    ALOGE("%s: failed setup input buffer", __func__);
+    return LHDCV5BT_DEC_API_FAIL;
+  }
+
+  if (frame_num == 0) {
+    return LHDCV5BT_DEC_API_SUCCEED;
+  }
+
+  func_ret = lhdcv5_util_dec_get_sample_size(&frame_samples);
+  if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
+    ALOGD("%s: fetch frame samples failed (%d)", __func__, func_ret);
+    return LHDCV5BT_DEC_API_FRAME_INFO_FAIL;
+  }
+  ALOGV("%s: output frame samples %d", __func__, (int)frame_samples);
+
+  if (bits_depth == LHDCV5BT_BIT_DEPTH_16) {
+    frame_bytes = frame_samples * 2 * 2;
+  } else {
+    // 24 or 32
+    frame_bytes = frame_samples * 4 * 2;
+  }
+
+  ptr_offset = 0;
+  dec_sum = 0;
+
+  while ((frame_num > 0) && (ptr_offset < in_len))
+  {
+    func_ret = lhdcv5_util_dec_fetch_frame_info(in_buf + ptr_offset, in_len, &lhdc_frame_Info);
+    if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
+      ALOGD("%s: fetch frame info fail (%d)", __func__, func_ret);
+      return LHDCV5BT_DEC_API_FRAME_INFO_FAIL;
+    }
+
+    if ((ptr_offset + lhdc_frame_Info.frame_len) > in_len) {
+      return LHDCV5BT_DEC_API_INPUT_NOT_ENOUGH;
+    }
+
+    if ((dec_sum + frame_bytes) > pcmSpaceBytes) {
+      return LHDCV5BT_DEC_API_OUTPUT_NOT_ENOUGH;
+    }
+
+    //ALOGD("%s: get ptr_offset=%d, dec_sum=%d", __func__, ptr_offset, dec_sum);
+    func_ret = lhdcv5_util_dec_process(
+        ((uint8_t *)pcmData) + dec_sum,
+        in_buf + ptr_offset,
+        lhdc_frame_Info.frame_len,
+        &lhdc_out_len);
+    if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
+      ALOGD("%s: decode fail (%d)", __func__, func_ret);
+      return LHDCV5BT_DEC_API_DECODE_FAIL;
+    }
+
+    ALOGD("%s: frame_num[%d]: input_frame_len %d output_len %d", __func__,
+        (int)frame_num, (int)lhdc_frame_Info.frame_len, (int)lhdc_out_len);
+
+    ptr_offset += lhdc_frame_Info.frame_len;
+    dec_sum += lhdc_out_len;
+
+    frame_num--;
+  }
+
+  *pcmBytes = (uint32_t) dec_sum;
+
+  return LHDCV5BT_DEC_API_SUCCEED;
+}
+
+
+// description
+//   de-initialize (free) all resources allocated by LHDC V5 decoder
+// Parameter
+//   none
+// return:
+//   == 0: success
+int32_t lhdcv5BT_dec_deinit_decoder(HANDLE_LHDCV5_BT handle)
+{
+  int32_t func_ret = 0;
+
+  if(handle == NULL) {
+    ALOGD("%s: empty handle", __func__);
+    return LHDCV5BT_DEC_API_SUCCEED;
+  }
+
+  func_ret = lhdcv5_util_dec_destroy();
+  if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
+    ALOGD("%s: deinit decoder error (%d)", __func__, func_ret);
+    return LHDCV5BT_DEC_API_FAIL;
+  }
+
+  if(handle) {
+    ALOGD ("%s: free handle %p!", __func__, handle);
+    free(handle);
+  }
+
+  return LHDCV5BT_DEC_API_SUCCEED;
+}
+
diff --git a/frameworks/base/api/current.txt b/frameworks/base/api/current.txt
index cd78602d..b5dba948 100755
--- a/frameworks/base/api/current.txt
+++ b/frameworks/base/api/current.txt
@@ -7945,7 +7945,14 @@ package android.bluetooth {
     method public java.util.List<android.bluetooth.BluetoothDevice> getConnectedDevices();
     method public int getConnectionState(android.bluetooth.BluetoothDevice);
     method public java.util.List<android.bluetooth.BluetoothDevice> getDevicesMatchingConnectionStates(int[]);
+    method public int getLhdcCodecExtendAPIConfigA2dpCodecSpecific(android.bluetooth.BluetoothDevice, byte[]);
+    method public int getLhdcCodecExtendAPIConfigAR(android.bluetooth.BluetoothDevice, byte[]);
+    method public int getLhdcCodecExtendAPIConfigMeta(android.bluetooth.BluetoothDevice, byte[]);
+    method public int getLhdcCodecExtendAPIVer(android.bluetooth.BluetoothDevice, byte[]);
     method public boolean isA2dpPlaying(android.bluetooth.BluetoothDevice);
+    method public int setLhdcCodecExtendAPIConfigAR(android.bluetooth.BluetoothDevice, byte[]);
+    method public int setLhdcCodecExtendAPIConfigMeta(android.bluetooth.BluetoothDevice, byte[]);
+    method public void setLhdcCodecExtendAPIDataGyro2D(android.bluetooth.BluetoothDevice, byte[]);
     field public static final String ACTION_CONNECTION_STATE_CHANGED = "android.bluetooth.a2dp.profile.action.CONNECTION_STATE_CHANGED";
     field public static final String ACTION_PLAYING_STATE_CHANGED = "android.bluetooth.a2dp.profile.action.PLAYING_STATE_CHANGED";
     field public static final int STATE_NOT_PLAYING = 11; // 0xb
@@ -38726,6 +38733,7 @@ package android.provider {
     field public static final String APPLY_RAMPING_RINGER = "apply_ramping_ringer";
     field public static final String AUTO_TIME = "auto_time";
     field public static final String AUTO_TIME_ZONE = "auto_time_zone";
+    field public static final String BLUETOOTH_A2DPSINK = "bluetooth_a2dpsink";
     field public static final String BLUETOOTH_ON = "bluetooth_on";
     field public static final String BOOT_COUNT = "boot_count";
     field public static final String CONTACT_METADATA_SYNC_ENABLED = "contact_metadata_sync_enabled";
@@ -38803,6 +38811,7 @@ package android.provider {
     field @Deprecated public static final String ALLOW_MOCK_LOCATION = "mock_location";
     field public static final String ANDROID_ID = "android_id";
     field @Deprecated public static final String BACKGROUND_DATA = "background_data";
+    field @Deprecated public static final String BLUETOOTH_A2DPSINK = "bluetooth_a2dpsink";
     field @Deprecated public static final String BLUETOOTH_ON = "bluetooth_on";
     field public static final android.net.Uri CONTENT_URI;
     field @Deprecated public static final String DATA_ROAMING = "data_roaming";
@@ -38896,6 +38905,7 @@ package android.provider {
     field @Deprecated public static final String ANIMATOR_DURATION_SCALE = "animator_duration_scale";
     field @Deprecated public static final String AUTO_TIME = "auto_time";
     field @Deprecated public static final String AUTO_TIME_ZONE = "auto_time_zone";
+    field @Deprecated public static final String BLUETOOTH_A2DPSINK = "bluetooth_a2dpsink";
     field public static final String BLUETOOTH_DISCOVERABILITY = "bluetooth_discoverability";
     field public static final String BLUETOOTH_DISCOVERABILITY_TIMEOUT = "bluetooth_discoverability_timeout";
     field @Deprecated public static final String BLUETOOTH_ON = "bluetooth_on";
diff --git a/frameworks/base/core/java/android/bluetooth/BluetoothA2dp.java b/frameworks/base/core/java/android/bluetooth/BluetoothA2dp.java
index 1fe1b100..2b956876 100755
--- a/frameworks/base/core/java/android/bluetooth/BluetoothA2dp.java
+++ b/frameworks/base/core/java/android/bluetooth/BluetoothA2dp.java
@@ -619,7 +619,8 @@ public final class BluetoothA2dp implements BluetoothProfile {
     @UnsupportedAppUsage
     public void setCodecConfigPreference(BluetoothDevice device,
                                          BluetoothCodecConfig codecConfig) {
-        if (DBG) Log.d(TAG, "setCodecConfigPreference(" + device + ")");
+        if (DBG) Log.d(TAG, "setCodecConfigPreference(" + device + ")");        
+       
         try {
             final IBluetoothA2dp service = getService();
             if (service != null && isEnabled()) {
@@ -632,6 +633,110 @@ public final class BluetoothA2dp implements BluetoothProfile {
             return;
         }
     }
+    
+    //Savitech Patch - LHDC Extended Function APIs Start
+    public int getLhdcCodecExtendAPIVer(BluetoothDevice device, 
+									byte[] exApiVer) {
+        try {
+            final IBluetoothA2dp service = getService();
+            if (service != null && isEnabled()) {
+                return service.getLhdcCodecExtendAPIVer(device, exApiVer);            	    
+            }
+            if (service == null) Log.w(TAG, "Proxy not attached to service");
+            return -1;
+        } catch (RemoteException e) {
+            Log.e(TAG, "Error talking to BT service", e);
+            return -1;
+        }
+    }
+    
+    public int setLhdcCodecExtendAPIConfigAR(BluetoothDevice device, 
+									byte[] codecConfig) {
+        try {
+            final IBluetoothA2dp service = getService();
+            if (service != null && isEnabled()) {
+                return service.setLhdcCodecExtendAPIConfigAR(device, codecConfig);            	    
+            }
+            if (service == null) Log.w(TAG, "Proxy not attached to service");
+            return -1;
+        } catch (RemoteException e) {
+            Log.e(TAG, "Error talking to BT service", e);
+            return -1;
+        }
+    }
+    
+    public int getLhdcCodecExtendAPIConfigAR(BluetoothDevice device, 
+									byte[] codecConfig) {
+        try {
+            final IBluetoothA2dp service = getService();
+            if (service != null && isEnabled()) {
+                return service.getLhdcCodecExtendAPIConfigAR(device, codecConfig);            	    
+            }
+            if (service == null) Log.w(TAG, "Proxy not attached to service");
+            return -1;
+        } catch (RemoteException e) {
+            Log.e(TAG, "Error talking to BT service", e);
+            return -1;
+        }
+    }    
+
+	public int setLhdcCodecExtendAPIConfigMeta(BluetoothDevice device, 
+									byte[] codecConfig) {
+        try {
+            final IBluetoothA2dp service = getService();
+            if (service != null && isEnabled()) {
+                return service.setLhdcCodecExtendAPIConfigMeta(device, codecConfig);            	    
+            }
+            if (service == null) Log.w(TAG, "Proxy not attached to service");
+            return -1;
+        } catch (RemoteException e) {
+            Log.e(TAG, "Error talking to BT service", e);
+            return -1;
+        }
+    }
+    
+    public int getLhdcCodecExtendAPIConfigMeta(BluetoothDevice device, 
+									byte[] codecConfig) {
+        try {
+            final IBluetoothA2dp service = getService();
+            if (service != null && isEnabled()) {
+                return service.getLhdcCodecExtendAPIConfigMeta(device, codecConfig);            	    
+            }
+            if (service == null) Log.w(TAG, "Proxy not attached to service");
+            return -1;
+        } catch (RemoteException e) {
+            Log.e(TAG, "Error talking to BT service", e);
+            return -1;
+        }
+    }
+    
+    public int getLhdcCodecExtendAPIConfigA2dpCodecSpecific(BluetoothDevice device, 
+									byte[] codecConfig) {
+        try {
+            final IBluetoothA2dp service = getService();
+            if (service != null && isEnabled()) {
+                return service.getLhdcCodecExtendAPIConfigA2dpCodecSpecific(device, codecConfig);            	    
+            }
+            if (service == null) Log.w(TAG, "Proxy not attached to service");
+            return -1;
+        } catch (RemoteException e) {
+            Log.e(TAG, "Error talking to BT service", e);
+            return -1;
+        }
+    }    
+    
+	public void setLhdcCodecExtendAPIDataGyro2D(BluetoothDevice device, 
+									byte[] codecData) {
+        try {
+            final IBluetoothA2dp service = getService();
+            if (service != null && isEnabled()) {
+                service.setLhdcCodecExtendAPIDataGyro2D(device, codecData);            	    
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "Error talking to BT service", e);
+        }
+    }
+    //Savitech Patch - LHDC Extended Function APIs End
 
     /**
      * Enables the optional codecs.
diff --git a/frameworks/base/core/java/android/bluetooth/BluetoothCodecConfig.java b/frameworks/base/core/java/android/bluetooth/BluetoothCodecConfig.java
index 591c418c..014bed51 100755
--- a/frameworks/base/core/java/android/bluetooth/BluetoothCodecConfig.java
+++ b/frameworks/base/core/java/android/bluetooth/BluetoothCodecConfig.java
@@ -43,8 +43,18 @@ public final class BluetoothCodecConfig implements Parcelable {
     public static final int SOURCE_CODEC_TYPE_APTX_HD = 3;
     @UnsupportedAppUsage
     public static final int SOURCE_CODEC_TYPE_LDAC = 4;
+    // Savitech Patch - START
     @UnsupportedAppUsage
-    public static final int SOURCE_CODEC_TYPE_MAX = 5;
+    public static final int SOURCE_CODEC_TYPE_LHDCV3 = 5;
+    @UnsupportedAppUsage
+    public static final int SOURCE_CODEC_TYPE_LHDCV2 = 6;
+    @UnsupportedAppUsage
+    public static final int SOURCE_CODEC_TYPE_LHDCV1 = 7;
+    @UnsupportedAppUsage
+    public static final int SOURCE_CODEC_TYPE_LHDCV5 = 8;
+    // Savitech Patch - END
+    @UnsupportedAppUsage
+    public static final int SOURCE_CODEC_TYPE_MAX = 9;
 
     @UnsupportedAppUsage
     public static final int SOURCE_CODEC_TYPE_INVALID = 1000 * 1000;
@@ -301,6 +311,16 @@ public final class BluetoothCodecConfig implements Parcelable {
                 return "aptX HD";
             case SOURCE_CODEC_TYPE_LDAC:
                 return "LDAC";
+            // Savitech Patch - START
+            case SOURCE_CODEC_TYPE_LHDCV3:
+                return "LHDC V3";
+            case SOURCE_CODEC_TYPE_LHDCV2:
+                return "LHDC V2";
+            case SOURCE_CODEC_TYPE_LHDCV1:
+                return "LHDC V1";
+            case SOURCE_CODEC_TYPE_LHDCV5:
+                return "LHDC V5";
+            // Savitech Patch - END
             case SOURCE_CODEC_TYPE_INVALID:
                 return "INVALID CODEC";
             default:
@@ -449,6 +469,11 @@ public final class BluetoothCodecConfig implements Parcelable {
     public boolean sameAudioFeedingParameters(BluetoothCodecConfig other) {
         return (other != null && other.mSampleRate == mSampleRate
                 && other.mBitsPerSample == mBitsPerSample
-                && other.mChannelMode == mChannelMode);
+                && other.mChannelMode == mChannelMode
+                // Savitech Patch - START
+                && other.mCodecSpecific1 == mCodecSpecific1
+                && other.mCodecSpecific2 == mCodecSpecific2
+		        && other.mCodecSpecific3 == mCodecSpecific3);
+        		//Savitech Patch - END
     }
 }
diff --git a/frameworks/base/core/java/android/provider/Settings.java b/frameworks/base/core/java/android/provider/Settings.java
index d14164e3..bc6a5c41 100755
--- a/frameworks/base/core/java/android/provider/Settings.java
+++ b/frameworks/base/core/java/android/provider/Settings.java
@@ -4842,6 +4842,14 @@ public final class Settings {
         public static final String BLUETOOTH_ON = Global.BLUETOOTH_ON;
 
         private static final Validator BLUETOOTH_ON_VALIDATOR = BOOLEAN_VALIDATOR;
+        
+        /**
+         * Savitech Patch - A2DP_Sink_ON_OFF_Switch
+         * @deprecated Use {@link android.provider.Settings.Global#BLUETOOTH_A2DPSINK} instead
+         */
+        @Deprecated
+        public static final String BLUETOOTH_A2DPSINK = Global.BLUETOOTH_A2DPSINK;
+        private static final Validator BLUETOOTH_A2DPSINK_VALIDATOR = BOOLEAN_VALIDATOR;        
 
         /**
          * @deprecated Use {@link android.provider.Settings.Global#DATA_ROAMING} instead
@@ -5127,6 +5135,7 @@ public final class Settings {
             MOVED_TO_GLOBAL.add(Settings.Global.ADB_ENABLED);
             MOVED_TO_GLOBAL.add(Settings.Global.ASSISTED_GPS_ENABLED);
             MOVED_TO_GLOBAL.add(Settings.Global.BLUETOOTH_ON);
+            MOVED_TO_GLOBAL.add(Settings.Global.BLUETOOTH_A2DPSINK);	//Savitech Patch - A2DP_Sink_ON_OFF_Switch
             MOVED_TO_GLOBAL.add(Settings.Global.BUGREPORT_IN_POWER_MENU);
             MOVED_TO_GLOBAL.add(Settings.Global.CDMA_CELL_BROADCAST_SMS);
             MOVED_TO_GLOBAL.add(Settings.Global.CDMA_ROAMING_MODE);
@@ -5816,6 +5825,14 @@ public final class Settings {
         public static final String BLUETOOTH_ON = Global.BLUETOOTH_ON;
 
         private static final Validator BLUETOOTH_ON_VALIDATOR = BOOLEAN_VALIDATOR;
+        
+        /**
+         * Savitech Patch - A2DP_Sink_ON_OFF_Switch
+         * @deprecated Use {@link android.provider.Settings.Global#BLUETOOTH_ON} instead
+         */
+        @Deprecated
+        public static final String BLUETOOTH_A2DPSINK = Global.BLUETOOTH_A2DPSINK;
+        private static final Validator BLUETOOTH_A2DPSINK_VALIDATOR = BOOLEAN_VALIDATOR;
 
         /**
          * @deprecated Use {@link android.provider.Settings.Global#DATA_ROAMING} instead
@@ -9750,6 +9767,14 @@ public final class Settings {
         public static final String BLUETOOTH_ON = "bluetooth_on";
 
         private static final Validator BLUETOOTH_ON_VALIDATOR = BOOLEAN_VALIDATOR;
+        
+        /**
+         * Savitech Patch - A2DP_Sink_ON_OFF_Switch
+         * Whether bluetooth A2DP Sink is enabled/disabled
+         * 0=disabled. 1=enabled.
+         */
+        public static final String BLUETOOTH_A2DPSINK = "bluetooth_a2dpsink";        
+        private static final Validator BLUETOOTH_A2DPSINK_VALIDATOR = BOOLEAN_VALIDATOR;        
 
         /**
          * CDMA Cell Broadcast SMS
@@ -13874,6 +13899,7 @@ public final class Settings {
             LOW_POWER_MODE_STICKY_AUTO_DISABLE_ENABLED,
             LOW_POWER_MODE_STICKY_AUTO_DISABLE_LEVEL,
             BLUETOOTH_ON,
+            BLUETOOTH_A2DPSINK,	//Savitech Patch - A2DP_Sink_ON_OFF_switch
             PRIVATE_DNS_MODE,
             PRIVATE_DNS_SPECIFIER,
             SOFT_AP_TIMEOUT_ENABLED,
@@ -13927,6 +13953,8 @@ public final class Settings {
             VALIDATORS.put(DYNAMIC_POWER_SAVINGS_DISABLE_THRESHOLD,
                     DYNAMIC_POWER_SAVINGS_VALIDATOR);
             VALIDATORS.put(BLUETOOTH_ON, BLUETOOTH_ON_VALIDATOR);
+            VALIDATORS.put(BLUETOOTH_A2DPSINK, BLUETOOTH_A2DPSINK_VALIDATOR);	//Savitech Patch - A2DP_Sink_ON_OFF_Switch
+            
             VALIDATORS.put(PRIVATE_DNS_MODE, PRIVATE_DNS_MODE_VALIDATOR);
             VALIDATORS.put(PRIVATE_DNS_SPECIFIER, PRIVATE_DNS_SPECIFIER_VALIDATOR);
             VALIDATORS.put(SOFT_AP_TIMEOUT_ENABLED, SOFT_AP_TIMEOUT_ENABLED_VALIDATOR);
diff --git a/frameworks/base/core/tests/bluetoothtests/src/android/bluetooth/BluetoothCodecConfigTest.java b/frameworks/base/core/tests/bluetoothtests/src/android/bluetooth/BluetoothCodecConfigTest.java
index 59b46656..8ac31246 100755
--- a/frameworks/base/core/tests/bluetoothtests/src/android/bluetooth/BluetoothCodecConfigTest.java
+++ b/frameworks/base/core/tests/bluetoothtests/src/android/bluetooth/BluetoothCodecConfigTest.java
@@ -34,6 +34,12 @@ public class BluetoothCodecConfigTest extends TestCase {
         BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX,
         BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_HD,
         BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC,
+        //Savitech Patch - START
+        BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3,
+        BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2,
+        BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV1,
+        BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5,
+        //Savitech Patch - END
         BluetoothCodecConfig.SOURCE_CODEC_TYPE_MAX,
         BluetoothCodecConfig.SOURCE_CODEC_TYPE_INVALID,
     };
@@ -204,6 +210,20 @@ public class BluetoothCodecConfigTest extends TestCase {
             if (codec_type == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC) {
                 assertEquals("LDAC", bcc.getCodecName());
             }
+            // Savitech Patch - START
+            if (codec_type == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3) {
+                assertEquals("LHDC V3", bcc.getCodecName());
+            }
+            if (codec_type == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2) {
+                assertEquals("LHDC V2", bcc.getCodecName());
+            }
+            if (codec_type == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV1) {
+                assertEquals("LHDC V1", bcc.getCodecName());
+            }
+            if (codec_type == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5) {
+                assertEquals("LHDC V5", bcc.getCodecName());
+            }
+            //Savitech Patch - END
             if (codec_type == BluetoothCodecConfig.SOURCE_CODEC_TYPE_MAX) {
                 assertEquals("UNKNOWN CODEC(" + BluetoothCodecConfig.SOURCE_CODEC_TYPE_MAX + ")",
                              bcc.getCodecName());
diff --git a/frameworks/base/packages/SettingsLib/res/values/arrays.xml b/frameworks/base/packages/SettingsLib/res/values/arrays.xml
index 39c55fd1..79bd21c3 100755
--- a/frameworks/base/packages/SettingsLib/res/values/arrays.xml
+++ b/frameworks/base/packages/SettingsLib/res/values/arrays.xml
@@ -140,6 +140,12 @@
         <item><xliff:g id="qualcomm">Qualcomm</xliff:g> <xliff:g id="aptx">aptX</xliff:g> audio</item>
         <item><xliff:g id="qualcomm">Qualcomm</xliff:g> <xliff:g id="aptx_hd">aptX HD</xliff:g> audio</item>
         <item>LDAC</item>
+        <!-- Savitech Patch - START -->
+        <item>Savitech LHDC V3/V4</item>
+        <item>Savitech LHDC V2</item>
+        <item>Savitech LHDC V1</item>
+        <item>Savitech LHDC-V</item>
+        <!-- Savitech Patch - END -->
         <item>Enable Optional Codecs</item>
         <item>Disable Optional Codecs</item>
     </string-array>
@@ -154,6 +160,12 @@
         <item>4</item>
         <item>5</item>
         <item>6</item>
+        <!-- Savitech Patch - START -->
+        <item>7</item>
+        <item>8</item>
+        <item>9</item>
+        <item>10</item>
+        <!-- Savitech Patch - END -->
     </string-array>
 
     <!-- Summaries for Bluetooth Audio Codec selection preference. [CHAR LIMIT=50]-->
@@ -164,6 +176,12 @@
         <item><xliff:g id="qualcomm">Qualcomm</xliff:g> <xliff:g id="aptx">aptX</xliff:g> audio</item>
         <item><xliff:g id="qualcomm">Qualcomm</xliff:g> <xliff:g id="aptx_hd">aptX HD</xliff:g> audio</item>
         <item>LDAC</item>
+        <!-- Savitech Patch - START -->
+        <item>Savitech LHDC V3/V4</item>
+        <item>Savitech LHDC V2</item>
+        <item>Savitech LHDC V1</item>
+        <item>Savitech LHDC-V</item>
+        <!-- Savitech Patch - END -->
         <item>Enable Optional Codecs</item>
         <item>Disable Optional Codecs</item>
     </string-array>
@@ -175,6 +193,10 @@
         <item>48.0 kHz</item>
         <item>88.2 kHz</item>
         <item>96.0 kHz</item>
+        <!-- Savitech Patch - START -->
+        <item>176.4 kHz</item>
+        <item>192.0 kHz</item>
+        <!-- Savitech Patch - END -->
     </string-array>
 
     <!-- Values for Bluetooth Audio Codec Sample Rate selection preference. -->
@@ -184,6 +206,10 @@
         <item>2</item>
         <item>4</item>
         <item>8</item>
+        <!-- Savitech Patch - START -->
+        <item>16</item>
+        <item>32</item>
+        <!-- Savitech Patch - END -->
     </string-array>
 
     <!-- Summaries for Bluetooth Audio Codec Sample Rate selection preference. [CHAR LIMIT=50]-->
@@ -193,6 +219,10 @@
         <item>48.0 kHz</item>
         <item>88.2 kHz</item>
         <item>96.0 kHz</item>
+        <!-- Savitech Patch - START -->
+        <item>176.4 kHz</item>
+        <item>192.0 kHz</item>
+        <!-- Savitech Patch - END -->
     </string-array>
 
     <!-- Titles for Bluetooth Audio Codec Bits Per Sample selection preference. [CHAR LIMIT=50] -->
@@ -263,7 +293,106 @@
         <item>Optimized for Connection Quality</item>
         <item>Best Effort (Adaptive Bit Rate)</item>
     </string-array>
+    
+    <!-- Savitech Patch - START -->
+    <!-- Titles for Bluetooth Audio Codec LHDC AR Effect selection preference. [CHAR LIMIT=70] -->
+    <string-array name="bluetooth_enable_a2dp_codec_lhdc_ar_effect_titles" translatable="false" >
+        <item>OFF</item>
+        <item>ON</item>
+    </string-array>
+    
+    <!-- Values for Bluetooth Audio Codec LHDC AR Effect selection preference -->
+    <string-array name="bluetooth_enable_a2dp_codec_lhdc_ar_effect_values" translatable="false" >
+        <item>0</item>
+        <item>2</item>
+    </string-array>
+    
+    <!-- Summaries for Bluetooth Audio Codec LHDC AR Effect selection preference [CHAR LIMIT=70]-->
+    <string-array name="bluetooth_enable_a2dp_codec_lhdc_ar_effect_summaries" translatable="false" >
+        <item>LHDC AR effect off</item>
+        <item>LHDC AR effect on</item>
+    </string-array>
+
+    
+    <!-- Titles for Bluetooth Audio Codec LHDC Playback Quality selection preference. [CHAR LIMIT=70] -->
+    <string-array name="bluetooth_a2dp_codec_lhdc_playback_quality_titles" translatable="false" >
+        <item>Optimized for Connection Quality (64kbps)</item>
+        <item>Optimized for Connection Quality (128kbps)</item>
+        <item>Optimized for Connection Quality (192kbps)</item>
+        <item>Optimized for Connection Quality (256kbps)</item>
+        <item>Optimized for Connection Quality (320kbps)</item>
+        <item>Optimized for Connection Quality (400kbps)</item>
+        <item>Balanced Audio And Connection Quality (500kbps)</item>
+        <item>High Audio Quality (900kbps)</item>
+        <item>Extremely High Audio Quality (1000kbps)</item>
+        <item>Best Effort (Auto Bit Rate)</item>
+    </string-array>
+    
+    <!-- Values for Bluetooth Audio Codec LHDC Playback Quaility selection preference. -->
+    <string-array name="bluetooth_a2dp_codec_lhdc_playback_quality_values" translatable="false" >
+        <item>32768</item>
+        <item>32769</item>
+        <item>32770</item>
+        <item>32771</item>
+        <item>32772</item>
+        <item>32773</item>
+        <item>32774</item>
+        <item>32775</item>
+        <item>32776</item>
+        <item>32777</item>
+    </string-array>
+    
+    <!-- Summaries for Bluetooth Audio Codec LHDC Playback Quality selection preference. [CHAR LIMIT=70]-->
+    <string-array name="bluetooth_a2dp_codec_lhdc_playback_quality_summaries" translatable="false" >
+        <item>Optimized for Connection Quality (64kbps)</item>
+        <item>Optimized for Connection Quality (128kbps)</item>
+        <item>Optimized for Connection Quality (192kbps)</item>
+        <item>Optimized for Connection Quality (256kbps)</item>
+        <item>Optimized for Connection Quality (320kbps)</item>
+        <item>Optimized for Connection Quality</item>
+        <item>Balanced Audio And Connection Quality</item>
+        <item>High Audio Quality</item>
+        <item>Extremely High Audio Quality</item>
+        <item>Best Effort (Auto Bit Rate)</item>
+    </string-array>
+    
+    <!-- Titles for Bluetooth Audio Codec LHDC Latency selection preference. [CHAR LIMIT=70] -->
+    <string-array name="bluetooth_a2dp_codec_lhdc_latency_titles" translatable="false" >
+        <item>Low latency disable</item>
+        <item>Low latency enable (only support aosp 9+)</item>
+    </string-array>
+    
+    <!-- Values for Bluetooth Audio Codec LHDC Latency selection preference. -->
+    <string-array name="bluetooth_a2dp_codec_lhdc_latency_values" translatable="false" >
+        <item>49152</item>
+        <item>49153</item>
+    </string-array>
+    
+    <!-- Summaries for Bluetooth Audio Codec LHDC Latency selection preference. [CHAR LIMIT=70]-->
+    <string-array name="bluetooth_a2dp_codec_lhdc_latency_summaries" translatable="false" >
+        <item>Low latency disable</item>
+        <item>Low latency enable</item>
+    </string-array>
+    
+    <!-- Titles for Bluetooth Audio Codec LHDC Lossless selection preference. [CHAR LIMIT=70] -->
+    <string-array name="bluetooth_enable_a2dp_codec_lhdc_lossless_titles" translatable="false" >
+        <item>OFF</item>
+        <item>ON</item>
+    </string-array>
+
+    <!-- Values for Bluetooth Audio Codec LHDC Lossless selection preference -->
+    <string-array name="bluetooth_enable_a2dp_codec_lhdc_lossless_values" translatable="false" >
+        <item>0</item>
+        <item>2</item>
+    </string-array>
 
+    <!-- Summaries for Bluetooth Audio Codec LHDC Lossless selection preference [CHAR LIMIT=70]-->
+    <string-array name="bluetooth_enable_a2dp_codec_lhdc_lossless_summaries" translatable="false" >
+        <item>LHDC Lossless OFF</item>
+        <item>LHDC Lossless ON</item>
+    </string-array>
+    <!-- Savitech Patch - END -->
+    
     <!-- Summaries for Android Auto Bluetooth Audio Active Device status. [CHAR LIMIT=50]-->
     <string-array name="bluetooth_audio_active_device_summaries" >
         <!-- Status message when the device is not Active. -->
diff --git a/frameworks/base/packages/SettingsLib/res/values/strings.xml b/frameworks/base/packages/SettingsLib/res/values/strings.xml
index 0e918394..62618919 100755
--- a/frameworks/base/packages/SettingsLib/res/values/strings.xml
+++ b/frameworks/base/packages/SettingsLib/res/values/strings.xml
@@ -619,6 +619,28 @@
     <!-- UI debug setting: Select Bluetooth Audio LDAC Codec: LDAC Playback Quality -->
     <string name="bluetooth_select_a2dp_codec_ldac_playback_quality_dialog_title">Trigger Bluetooth Audio LDAC\u000ACodec Selection: Playback Quality</string>
 
+    <!-- Savitech LHDC - START -->
+    <!-- UI debug setting: Select Bluetooth Audio LHDC AR effect -->
+    <string name="bluetooth_enable_a2dp_codec_lhdc_ar_effect">Enable LHDC AR Audio</string>
+    <!-- UI debug setting: Select Bluetooth Audio LHDC AR effect: LHDC AR Audio -->
+    <string name="bluetooth_enable_a2dp_codec_lhdc_ar_effect_dialog_title">Select Bluetooth Audio LHDC Codec:\u000AAR Audio</string>
+
+    <!-- UI debug setting: Select Bluetooth Audio LHDC Playback Quality -->
+    <string name="bluetooth_select_a2dp_codec_lhdc_playback_quality">Bluetooth Audio LHDC Codec: Playback Quality</string>
+    <!-- UI debug setting: Select Bluetooth Audio LHDC Codec: LHDC Playback Quality -->
+    <string name="bluetooth_select_a2dp_codec_lhdc_playback_quality_dialog_title">Select Bluetooth Audio LHDC Codec:\u000APlayback Quality</string>
+
+    <!-- UI debug setting: Select Bluetooth Audio LHDC Playback Quality -->
+    <string name="bluetooth_select_a2dp_codec_lhdc_latency">Bluetooth Audio LHDC Codec: Latency</string>
+    <!-- UI debug setting: Select Bluetooth Audio LHDC Codec: LHDC Playback Quality -->
+    <string name="bluetooth_select_a2dp_codec_lhdc_latency_dialog_title">Select Bluetooth Audio LHDC Codec:\u000ALatency</string>
+
+    <!-- UI debug setting: Select Bluetooth Audio LHDC Lossless -->
+    <string name="bluetooth_enable_a2dp_codec_lhdc_lossless">Enable LHDC Lossless</string>
+    <!-- UI debug setting: Select Bluetooth Audio LHDC Lossless: LHDC Lossless Audio -->
+    <string name="bluetooth_enable_a2dp_codec_lhdc_lossless_dialog_title">Select Bluetooth Audio LHDC Codec:\u000ALossless Audio</string>
+    <!-- Savitech LHDC - END -->
+
     <!-- [CHAR LIMIT=NONE] Label for displaying Bluetooth Audio Codec Parameters while streaming -->
     <string name="bluetooth_select_a2dp_codec_streaming_label">Streaming: <xliff:g id="streaming_parameter">%1$s</xliff:g></string>
 
diff --git a/frameworks/base/packages/SettingsProvider/res/values/defaults.xml b/frameworks/base/packages/SettingsProvider/res/values/defaults.xml
index 05246a42..55194a95 100755
--- a/frameworks/base/packages/SettingsProvider/res/values/defaults.xml
+++ b/frameworks/base/packages/SettingsProvider/res/values/defaults.xml
@@ -37,6 +37,9 @@
     <bool name="def_haptic_feedback">true</bool>
 
     <bool name="def_bluetooth_on">true</bool>
+    <!-- Savitech Patch - A2DP_Sink_ON_OFF_Switch -->
+    <bool name="def_bluetooth_a2dpsink">false</bool>
+        
     <bool name="def_wifi_display_on">false</bool>
     <bool name="def_install_non_market_apps">false</bool>
     <bool name="def_package_verifier_enable">true</bool>
diff --git a/frameworks/base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java b/frameworks/base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
index 5e2b7c86..7fede35a 100755
--- a/frameworks/base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
+++ b/frameworks/base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
@@ -2490,6 +2490,10 @@ class DatabaseHelper extends SQLiteOpenHelper {
 
             loadBooleanSetting(stmt, Settings.Global.BLUETOOTH_ON,
                     R.bool.def_bluetooth_on);
+            
+            // Savitech Patch - A2DP_Sink_ON_OFF_Switch
+            loadBooleanSetting(stmt, Settings.Global.BLUETOOTH_A2DPSINK,
+                    R.bool.def_bluetooth_a2dpsink);
 
             // Enable or disable Cell Broadcast SMS
             loadSetting(stmt, Settings.Global.CDMA_CELL_BROADCAST_SMS,
diff --git a/frameworks/base/services/core/java/com/android/server/BluetoothManagerService.java b/frameworks/base/services/core/java/com/android/server/BluetoothManagerService.java
index 188d6549..30bfff1f 100755
--- a/frameworks/base/services/core/java/com/android/server/BluetoothManagerService.java
+++ b/frameworks/base/services/core/java/com/android/server/BluetoothManagerService.java
@@ -132,6 +132,8 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
 
     // Bluetooth persisted setting is off
     private static final int BLUETOOTH_OFF = 0;
+    // Savitech Patch - A2DP_Sink_ON_OFF_Switch (Default OFF)
+    private static final int BLUETOOTH_A2DPSINK_OFF = 0;
     // Bluetooth persisted setting is on
     // and Airplane mode won't affect Bluetooth state at start up
     private static final int BLUETOOTH_ON_BLUETOOTH = 1;
@@ -199,6 +201,7 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
     // synchronize with broadcast receiver.
     private boolean mQuietEnableExternal;
     private boolean mEnableExternal;
+    private boolean mA2DPSinkEnableExternal;	// Savitech Patch - A2DP_Sink_ON_OFF_Switch
 
     // Map of apps registered to keep BLE scanning on.
     private Map<IBinder, ClientDeathRecipient> mBleApps =
@@ -387,6 +390,7 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
         mState = BluetoothAdapter.STATE_OFF;
         mQuietEnableExternal = false;
         mEnableExternal = false;
+        mA2DPSinkEnableExternal = false;	// Savitech Patch - A2DP_Sink_ON_OFF_Switch
         mAddress = null;
         mName = null;
         mErrorRecoveryRetryCounter = 0;
@@ -425,6 +429,15 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
             }
             mEnableExternal = true;
         }
+        
+        // Savitech Patch - A2DP_Sink_ON_OFF_Switch START
+        if (isBluetoothPersistedA2DPSinkOn()) {
+            mA2DPSinkEnableExternal = true;
+            Slog.d(TAG, "Startup: Get persisted A2DP Sink state is ON.");
+        } else {
+        	Slog.d(TAG, "Startup: Get persisted A2DP Sink state is OFF.");
+        }
+        // Savitech Patch - A2DP_Sink_ON_OFF_Switch END
 
         String airplaneModeRadios =
                 Settings.Global.getString(mContentResolver, Settings.Global.AIRPLANE_MODE_RADIOS);
@@ -477,6 +490,19 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
         }
         return state != BLUETOOTH_OFF;
     }
+    
+    /**
+     *  Savitech Patch - A2DP_Sink_ON_OFF_Switch
+     *  Returns true if the Bluetooth A2DP Sink saved state is "on"
+     */
+    private boolean isBluetoothPersistedA2DPSinkOn() {
+        if (!supportBluetoothPersistedState()) {
+            return false;
+        }
+        int state = Settings.Global.getInt(mContentResolver, Settings.Global.BLUETOOTH_A2DPSINK, 0);
+        Slog.d(TAG, "Bluetooth A2DP Sink persisted state: " + state);
+        return state != BLUETOOTH_A2DPSINK_OFF;
+    }
 
     /**
      *  Returns true if the Bluetooth saved state is BLUETOOTH_ON_BLUETOOTH
@@ -501,6 +527,18 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
         Settings.Global.putInt(mContext.getContentResolver(), Settings.Global.BLUETOOTH_ON, value);
         Binder.restoreCallingIdentity(callingIdentity);
     }
+    
+    /**
+     *  Savitech Patch - A2DP_Sink_ON_OFF_Switch
+     *  Save the Bluetooth A2DP Sink on/off state
+     */
+    private void persistBluetoothA2DPSinkSetting(int value) {
+        Slog.d(TAG, "Persisting Bluetooth A2DP Sink Setting: " + value);
+        // waive WRITE_SECURE_SETTINGS permission check
+        long callingIdentity = Binder.clearCallingIdentity();
+        Settings.Global.putInt(mContext.getContentResolver(), Settings.Global.BLUETOOTH_A2DPSINK, value);
+        Binder.restoreCallingIdentity(callingIdentity);
+    }
 
     /**
      * Returns true if the Bluetooth Adapter's name and address is
@@ -971,6 +1009,17 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
         synchronized (mReceiver) {
             if (persist) {
                 persistBluetoothSetting(BLUETOOTH_OFF);
+                
+                // Savitech Patch - A2DP_Sink_ON_OFF_Switch
+                if(mA2DPSinkEnableExternal == false) {
+                	Slog.d(TAG, "disable(): Toggle A2DP Sink state from OFF to ON then store to persist!");
+                	mA2DPSinkEnableExternal = true;
+                	persistBluetoothA2DPSinkSetting(1);                	
+                } else {
+                	Slog.d(TAG, "disable(): Toggle A2DP Sink state from ON to OFF then store to persist!");
+                	mA2DPSinkEnableExternal = false;
+                	persistBluetoothA2DPSinkSetting(0);	
+                }
             }
             mEnableExternal = false;
             sendDisableMsg(BluetoothProtoEnums.ENABLE_DISABLE_REASON_APPLICATION_REQUEST,
diff --git a/frameworks/base/test-base/jarjar-rules.txt b/frameworks/base/test-base/jarjar-rules.txt
index fd8555c8..f6f79139 100755
--- a/frameworks/base/test-base/jarjar-rules.txt
+++ b/frameworks/base/test-base/jarjar-rules.txt
@@ -1,3 +1 @@
-rule junit.** repackaged.junit.@1
-rule android.test.** repackaged.android.test.@1
-rule com.android.internal.util.** repackaged.com.android.internal.util.@1
+../test-base/jarjar-rules.txt
\ No newline at end of file
diff --git a/frameworks/base/test-runner/jarjar-rules.txt b/frameworks/base/test-runner/jarjar-rules.txt
index fd8555c8..f6f79139 100755
--- a/frameworks/base/test-runner/jarjar-rules.txt
+++ b/frameworks/base/test-runner/jarjar-rules.txt
@@ -1,3 +1 @@
-rule junit.** repackaged.junit.@1
-rule android.test.** repackaged.android.test.@1
-rule com.android.internal.util.** repackaged.com.android.internal.util.@1
+../test-base/jarjar-rules.txt
\ No newline at end of file
diff --git a/hardware/interfaces/bluetooth/audio/2.0/default/session/BluetoothAudioSupportedCodecsDB.cpp b/hardware/interfaces/bluetooth/audio/2.0/default/session/BluetoothAudioSupportedCodecsDB.cpp
new file mode 100644
index 00000000..8f67260a
--- /dev/null
+++ b/hardware/interfaces/bluetooth/audio/2.0/default/session/BluetoothAudioSupportedCodecsDB.cpp
@@ -0,0 +1,416 @@
+/*
+ * Copyright 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "BTAudioProviderSessionCodecsDB"
+
+#include "BluetoothAudioSupportedCodecsDB.h"
+
+#include <android-base/logging.h>
+
+namespace android {
+namespace bluetooth {
+namespace audio {
+
+using ::android::hardware::bluetooth::audio::V2_0::AacObjectType;
+using ::android::hardware::bluetooth::audio::V2_0::AacParameters;
+using ::android::hardware::bluetooth::audio::V2_0::AacVariableBitRate;
+using ::android::hardware::bluetooth::audio::V2_0::AptxParameters;
+using ::android::hardware::bluetooth::audio::V2_0::BitsPerSample;
+using ::android::hardware::bluetooth::audio::V2_0::ChannelMode;
+using ::android::hardware::bluetooth::audio::V2_0::CodecType;
+using ::android::hardware::bluetooth::audio::V2_0::LdacChannelMode;
+using ::android::hardware::bluetooth::audio::V2_0::LdacParameters;
+using ::android::hardware::bluetooth::audio::V2_0::LdacQualityIndex;
+using ::android::hardware::bluetooth::audio::V2_0::SampleRate;
+using ::android::hardware::bluetooth::audio::V2_0::SbcAllocMethod;
+using ::android::hardware::bluetooth::audio::V2_0::SbcBlockLength;
+using ::android::hardware::bluetooth::audio::V2_0::SbcChannelMode;
+using ::android::hardware::bluetooth::audio::V2_0::SbcNumSubbands;
+using ::android::hardware::bluetooth::audio::V2_0::SbcParameters;
+
+// Default Supported PCM Parameters
+static const PcmParameters kDefaultSoftwarePcmCapabilities = {
+    .sampleRate = static_cast<SampleRate>(
+        SampleRate::RATE_44100 | SampleRate::RATE_48000 |
+        SampleRate::RATE_88200 | SampleRate::RATE_96000 | SampleRate::RATE_192000/*Savitech LHDC*/ |
+        SampleRate::RATE_16000 | SampleRate::RATE_24000),
+    .channelMode =
+        static_cast<ChannelMode>(ChannelMode::MONO | ChannelMode::STEREO),
+    .bitsPerSample = static_cast<BitsPerSample>(BitsPerSample::BITS_16 |
+                                                BitsPerSample::BITS_24 |
+                                                BitsPerSample::BITS_32)};
+
+// Default Supported Codecs
+// SBC: mSampleRate:(44100), mBitsPerSample:(16), mChannelMode:(MONO|STEREO)
+//      all blocks | subbands 8 | Loudness
+static const SbcParameters kDefaultOffloadSbcCapability = {
+    .sampleRate = SampleRate::RATE_44100,
+    .channelMode = static_cast<SbcChannelMode>(SbcChannelMode::MONO |
+                                               SbcChannelMode::JOINT_STEREO),
+    .blockLength = static_cast<SbcBlockLength>(
+        SbcBlockLength::BLOCKS_4 | SbcBlockLength::BLOCKS_8 |
+        SbcBlockLength::BLOCKS_12 | SbcBlockLength::BLOCKS_16),
+    .numSubbands = SbcNumSubbands::SUBBAND_8,
+    .allocMethod = SbcAllocMethod::ALLOC_MD_L,
+    .bitsPerSample = BitsPerSample::BITS_16,
+    .minBitpool = 2,
+    .maxBitpool = 53};
+
+// AAC: mSampleRate:(44100), mBitsPerSample:(16), mChannelMode:(STEREO)
+static const AacParameters kDefaultOffloadAacCapability = {
+    .objectType = AacObjectType::MPEG2_LC,
+    .sampleRate = SampleRate::RATE_44100,
+    .channelMode = ChannelMode::STEREO,
+    .variableBitRateEnabled = AacVariableBitRate::DISABLED,
+    .bitsPerSample = BitsPerSample::BITS_16};
+
+// LDAC: mSampleRate:(44100|48000|88200|96000), mBitsPerSample:(16|24|32),
+//       mChannelMode:(DUAL|STEREO)
+static const LdacParameters kDefaultOffloadLdacCapability = {
+    .sampleRate = static_cast<SampleRate>(
+        SampleRate::RATE_44100 | SampleRate::RATE_48000 |
+        SampleRate::RATE_88200 | SampleRate::RATE_96000),
+    .channelMode = static_cast<LdacChannelMode>(LdacChannelMode::DUAL |
+                                                LdacChannelMode::STEREO),
+    .qualityIndex = LdacQualityIndex::QUALITY_HIGH,
+    .bitsPerSample = static_cast<BitsPerSample>(BitsPerSample::BITS_16 |
+                                                BitsPerSample::BITS_24 |
+                                                BitsPerSample::BITS_32)};
+
+// aptX: mSampleRate:(44100|48000), mBitsPerSample:(16), mChannelMode:(STEREO)
+static const AptxParameters kDefaultOffloadAptxCapability = {
+    .sampleRate = static_cast<SampleRate>(SampleRate::RATE_44100 |
+                                          SampleRate::RATE_48000),
+    .bitsPerSample = BitsPerSample::BITS_16,
+    .channelMode = ChannelMode::STEREO};
+
+// aptX HD: mSampleRate:(44100|48000), mBitsPerSample:(24),
+//          mChannelMode:(STEREO)
+static const AptxParameters kDefaultOffloadAptxHdCapability = {
+    .sampleRate = static_cast<SampleRate>(SampleRate::RATE_44100 |
+                                          SampleRate::RATE_48000),
+    .bitsPerSample = BitsPerSample::BITS_24,
+    .channelMode = ChannelMode::STEREO};
+
+const std::vector<CodecCapabilities> kDefaultOffloadA2dpCodecCapabilities = {
+    {.codecType = CodecType::SBC, .capabilities = {}},
+    {.codecType = CodecType::AAC, .capabilities = {}},
+    {.codecType = CodecType::LDAC, .capabilities = {}},
+    {.codecType = CodecType::APTX, .capabilities = {}},
+    {.codecType = CodecType::APTX_HD, .capabilities = {}}};
+
+static bool IsSingleBit(uint32_t bitmasks, uint32_t bitfield) {
+  bool single = false;
+  uint32_t test_bit = 0x00000001;
+  while (test_bit <= bitmasks && test_bit <= bitfield) {
+    if (bitfield & test_bit && bitmasks & test_bit) {
+      if (single) return false;
+      single = true;
+    }
+    if (test_bit == 0x80000000) break;
+    test_bit <<= 1;
+  }
+  return single;
+}
+
+static bool IsOffloadSbcConfigurationValid(
+    const CodecConfiguration::CodecSpecific& codec_specific);
+static bool IsOffloadAacConfigurationValid(
+    const CodecConfiguration::CodecSpecific& codec_specific);
+static bool IsOffloadLdacConfigurationValid(
+    const CodecConfiguration::CodecSpecific& codec_specific);
+static bool IsOffloadAptxConfigurationValid(
+    const CodecConfiguration::CodecSpecific& codec_specific);
+static bool IsOffloadAptxHdConfigurationValid(
+    const CodecConfiguration::CodecSpecific& codec_specific);
+
+static bool IsOffloadSbcConfigurationValid(
+    const CodecConfiguration::CodecSpecific& codec_specific) {
+  if (codec_specific.getDiscriminator() !=
+      CodecConfiguration::CodecSpecific::hidl_discriminator::sbcConfig) {
+    LOG(WARNING) << __func__
+                 << ": Invalid CodecSpecific=" << toString(codec_specific);
+    return false;
+  }
+  const SbcParameters sbc_data = codec_specific.sbcConfig();
+  if (!IsSingleBit(static_cast<uint32_t>(sbc_data.sampleRate), 0xff) ||
+      !IsSingleBit(static_cast<uint32_t>(sbc_data.channelMode), 0x0f) ||
+      !IsSingleBit(static_cast<uint32_t>(sbc_data.blockLength), 0xf0) ||
+      !IsSingleBit(static_cast<uint32_t>(sbc_data.numSubbands), 0x0c) ||
+      !IsSingleBit(static_cast<uint32_t>(sbc_data.allocMethod), 0x03) ||
+      !IsSingleBit(static_cast<uint32_t>(sbc_data.bitsPerSample), 0x07) ||
+      sbc_data.minBitpool > sbc_data.maxBitpool) {
+    LOG(WARNING) << __func__
+                 << ": Invalid CodecSpecific=" << toString(codec_specific);
+    return false;
+  } else if ((sbc_data.sampleRate & kDefaultOffloadSbcCapability.sampleRate) &&
+             (sbc_data.channelMode &
+              kDefaultOffloadSbcCapability.channelMode) &&
+             (sbc_data.blockLength &
+              kDefaultOffloadSbcCapability.blockLength) &&
+             (sbc_data.numSubbands &
+              kDefaultOffloadSbcCapability.numSubbands) &&
+             (sbc_data.allocMethod &
+              kDefaultOffloadSbcCapability.allocMethod) &&
+             (sbc_data.bitsPerSample &
+              kDefaultOffloadSbcCapability.bitsPerSample) &&
+             (kDefaultOffloadSbcCapability.minBitpool <= sbc_data.minBitpool &&
+              sbc_data.maxBitpool <= kDefaultOffloadSbcCapability.maxBitpool)) {
+    return true;
+  }
+  LOG(WARNING) << __func__
+               << ": Unsupported CodecSpecific=" << toString(codec_specific);
+  return false;
+}
+
+static bool IsOffloadAacConfigurationValid(
+    const CodecConfiguration::CodecSpecific& codec_specific) {
+  if (codec_specific.getDiscriminator() !=
+      CodecConfiguration::CodecSpecific::hidl_discriminator::aacConfig) {
+    LOG(WARNING) << __func__
+                 << ": Invalid CodecSpecific=" << toString(codec_specific);
+    return false;
+  }
+  const AacParameters aac_data = codec_specific.aacConfig();
+  if (!IsSingleBit(static_cast<uint32_t>(aac_data.objectType), 0xf0) ||
+      !IsSingleBit(static_cast<uint32_t>(aac_data.sampleRate), 0xff) ||
+      !IsSingleBit(static_cast<uint32_t>(aac_data.channelMode), 0x03) ||
+      !IsSingleBit(static_cast<uint32_t>(aac_data.bitsPerSample), 0x07)) {
+    LOG(WARNING) << __func__
+                 << ": Invalid CodecSpecific=" << toString(codec_specific);
+    return false;
+  } else if ((aac_data.objectType & kDefaultOffloadAacCapability.objectType) &&
+             (aac_data.sampleRate & kDefaultOffloadAacCapability.sampleRate) &&
+             (aac_data.channelMode &
+              kDefaultOffloadAacCapability.channelMode) &&
+             (aac_data.variableBitRateEnabled == AacVariableBitRate::DISABLED ||
+              kDefaultOffloadAacCapability.variableBitRateEnabled ==
+                  AacVariableBitRate::ENABLED) &&
+             (aac_data.bitsPerSample &
+              kDefaultOffloadAacCapability.bitsPerSample)) {
+    return true;
+  }
+  LOG(WARNING) << __func__
+               << ": Unsupported CodecSpecific=" << toString(codec_specific);
+  return false;
+}
+
+static bool IsOffloadLdacConfigurationValid(
+    const CodecConfiguration::CodecSpecific& codec_specific) {
+  if (codec_specific.getDiscriminator() !=
+      CodecConfiguration::CodecSpecific::hidl_discriminator::ldacConfig) {
+    LOG(WARNING) << __func__
+                 << ": Invalid CodecSpecific=" << toString(codec_specific);
+    return false;
+  }
+  const LdacParameters ldac_data = codec_specific.ldacConfig();
+  if (!IsSingleBit(static_cast<uint32_t>(ldac_data.sampleRate), 0xff) ||
+      !IsSingleBit(static_cast<uint32_t>(ldac_data.channelMode), 0x07) ||
+      (ldac_data.qualityIndex > LdacQualityIndex::QUALITY_LOW &&
+       ldac_data.qualityIndex != LdacQualityIndex::QUALITY_ABR) ||
+      !IsSingleBit(static_cast<uint32_t>(ldac_data.bitsPerSample), 0x07)) {
+    LOG(WARNING) << __func__
+                 << ": Invalid CodecSpecific=" << toString(codec_specific);
+    return false;
+  } else if ((ldac_data.sampleRate &
+              kDefaultOffloadLdacCapability.sampleRate) &&
+             (ldac_data.channelMode &
+              kDefaultOffloadLdacCapability.channelMode) &&
+             (ldac_data.bitsPerSample &
+              kDefaultOffloadLdacCapability.bitsPerSample)) {
+    return true;
+  }
+  LOG(WARNING) << __func__
+               << ": Unsupported CodecSpecific=" << toString(codec_specific);
+  return false;
+}
+
+static bool IsOffloadAptxConfigurationValid(
+    const CodecConfiguration::CodecSpecific& codec_specific) {
+  if (codec_specific.getDiscriminator() !=
+      CodecConfiguration::CodecSpecific::hidl_discriminator::aptxConfig) {
+    LOG(WARNING) << __func__
+                 << ": Invalid CodecSpecific=" << toString(codec_specific);
+    return false;
+  }
+  const AptxParameters aptx_data = codec_specific.aptxConfig();
+  if (!IsSingleBit(static_cast<uint32_t>(aptx_data.sampleRate), 0xff) ||
+      !IsSingleBit(static_cast<uint32_t>(aptx_data.channelMode), 0x03) ||
+      !IsSingleBit(static_cast<uint32_t>(aptx_data.bitsPerSample), 0x07)) {
+    LOG(WARNING) << __func__
+                 << ": Invalid CodecSpecific=" << toString(codec_specific);
+    return false;
+  } else if ((aptx_data.sampleRate &
+              kDefaultOffloadAptxCapability.sampleRate) &&
+             (aptx_data.channelMode &
+              kDefaultOffloadAptxCapability.channelMode) &&
+             (aptx_data.bitsPerSample &
+              kDefaultOffloadAptxCapability.bitsPerSample)) {
+    return true;
+  }
+  LOG(WARNING) << __func__
+               << ": Unsupported CodecSpecific=" << toString(codec_specific);
+  return false;
+}
+
+static bool IsOffloadAptxHdConfigurationValid(
+    const CodecConfiguration::CodecSpecific& codec_specific) {
+  if (codec_specific.getDiscriminator() !=
+      CodecConfiguration::CodecSpecific::hidl_discriminator::aptxConfig) {
+    LOG(WARNING) << __func__
+                 << ": Invalid CodecSpecific=" << toString(codec_specific);
+    return false;
+  }
+  const AptxParameters aptx_data = codec_specific.aptxConfig();
+  if (!IsSingleBit(static_cast<uint32_t>(aptx_data.sampleRate), 0xff) ||
+      !IsSingleBit(static_cast<uint32_t>(aptx_data.channelMode), 0x03) ||
+      !IsSingleBit(static_cast<uint32_t>(aptx_data.bitsPerSample), 0x07)) {
+    LOG(WARNING) << __func__
+                 << ": Invalid CodecSpecific=" << toString(codec_specific);
+    return false;
+  } else if ((aptx_data.sampleRate &
+              kDefaultOffloadAptxHdCapability.sampleRate) &&
+             (aptx_data.channelMode &
+              kDefaultOffloadAptxHdCapability.channelMode) &&
+             (aptx_data.bitsPerSample &
+              kDefaultOffloadAptxHdCapability.bitsPerSample)) {
+    return true;
+  }
+  LOG(WARNING) << __func__
+               << ": Unsupported CodecSpecific=" << toString(codec_specific);
+  return false;
+}
+
+std::vector<PcmParameters> GetSoftwarePcmCapabilities() {
+  return std::vector<PcmParameters>(1, kDefaultSoftwarePcmCapabilities);
+}
+
+std::vector<CodecCapabilities> GetOffloadCodecCapabilities(
+    const SessionType& session_type) {
+  if (session_type != SessionType::A2DP_HARDWARE_OFFLOAD_DATAPATH) {
+    return std::vector<CodecCapabilities>(0);
+  }
+  std::vector<CodecCapabilities> offload_a2dp_codec_capabilities =
+      kDefaultOffloadA2dpCodecCapabilities;
+  for (auto& codec_capability : offload_a2dp_codec_capabilities) {
+    switch (codec_capability.codecType) {
+      case CodecType::SBC:
+        codec_capability.capabilities.sbcCapabilities(
+            kDefaultOffloadSbcCapability);
+        break;
+      case CodecType::AAC:
+        codec_capability.capabilities.aacCapabilities(
+            kDefaultOffloadAacCapability);
+        break;
+      case CodecType::LDAC:
+        codec_capability.capabilities.ldacCapabilities(
+            kDefaultOffloadLdacCapability);
+        break;
+      case CodecType::APTX:
+        codec_capability.capabilities.aptxCapabilities(
+            kDefaultOffloadAptxCapability);
+        break;
+      case CodecType::APTX_HD:
+        codec_capability.capabilities.aptxCapabilities(
+            kDefaultOffloadAptxHdCapability);
+        break;
+      case CodecType::UNKNOWN:
+        codec_capability = {};
+        break;
+    }
+  }
+  return offload_a2dp_codec_capabilities;
+}
+
+bool IsSoftwarePcmConfigurationValid(const PcmParameters& pcm_config) {
+  if ((pcm_config.sampleRate != SampleRate::RATE_44100 &&
+       pcm_config.sampleRate != SampleRate::RATE_48000 &&
+       pcm_config.sampleRate != SampleRate::RATE_88200 &&
+       pcm_config.sampleRate != SampleRate::RATE_96000 &&
+       pcm_config.sampleRate != SampleRate::RATE_192000/*Savitech LHDC*/ &&
+       pcm_config.sampleRate != SampleRate::RATE_16000 &&
+       pcm_config.sampleRate != SampleRate::RATE_24000) ||
+      (pcm_config.bitsPerSample != BitsPerSample::BITS_16 &&
+       pcm_config.bitsPerSample != BitsPerSample::BITS_24 &&
+       pcm_config.bitsPerSample != BitsPerSample::BITS_32) ||
+      (pcm_config.channelMode != ChannelMode::MONO &&
+       pcm_config.channelMode != ChannelMode::STEREO)) {
+    LOG(WARNING) << __func__
+                 << ": Invalid PCM Configuration=" << toString(pcm_config);
+    return false;
+  } else if (pcm_config.sampleRate &
+                 kDefaultSoftwarePcmCapabilities.sampleRate &&
+             pcm_config.bitsPerSample &
+                 kDefaultSoftwarePcmCapabilities.bitsPerSample &&
+             pcm_config.channelMode &
+                 kDefaultSoftwarePcmCapabilities.channelMode) {
+    LOG(WARNING) << __func__
+                 << ": PCM Configuration Supported=" << toString(pcm_config);
+    return true;
+  }
+  LOG(WARNING) << __func__
+               << ": Unsupported PCM Configuration=" << toString(pcm_config);
+  return false;
+}
+
+bool IsOffloadCodecConfigurationValid(const SessionType& session_type,
+                                      const CodecConfiguration& codec_config) {
+  if (session_type != SessionType::A2DP_HARDWARE_OFFLOAD_DATAPATH) {
+    LOG(ERROR) << __func__
+               << ": Invalid SessionType=" << toString(session_type);
+    return false;
+  } else if (codec_config.encodedAudioBitrate < 0x00000001 ||
+             0x00ffffff < codec_config.encodedAudioBitrate) {
+    LOG(ERROR) << __func__ << ": Unsupported Codec Configuration="
+               << toString(codec_config);
+    return false;
+  }
+  const CodecConfiguration::CodecSpecific& codec_specific = codec_config.config;
+  switch (codec_config.codecType) {
+    case CodecType::SBC:
+      if (IsOffloadSbcConfigurationValid(codec_specific)) {
+        return true;
+      }
+      return false;
+    case CodecType::AAC:
+      if (IsOffloadAacConfigurationValid(codec_specific)) {
+        return true;
+      }
+      return false;
+    case CodecType::LDAC:
+      if (IsOffloadLdacConfigurationValid(codec_specific)) {
+        return true;
+      }
+      return false;
+    case CodecType::APTX:
+      if (IsOffloadAptxConfigurationValid(codec_specific)) {
+        return true;
+      }
+      return false;
+    case CodecType::APTX_HD:
+      if (IsOffloadAptxHdConfigurationValid(codec_specific)) {
+        return true;
+      }
+      return false;
+    case CodecType::UNKNOWN:
+      return false;
+  }
+  return false;
+}
+
+}  // namespace audio
+}  // namespace bluetooth
+}  // namespace android
diff --git a/packages/apps/Bluetooth/jni/com_android_bluetooth_a2dp.cpp b/packages/apps/Bluetooth/jni/com_android_bluetooth_a2dp.cpp
index af125bda..8307914e 100755
--- a/packages/apps/Bluetooth/jni/com_android_bluetooth_a2dp.cpp
+++ b/packages/apps/Bluetooth/jni/com_android_bluetooth_a2dp.cpp
@@ -51,6 +51,25 @@ static std::shared_timed_mutex interface_mutex;
 static jobject mCallbacksObj = nullptr;
 static std::shared_timed_mutex callbacks_mutex;
 
+// Savitech Patch - START
+static char *jByteArrayToChar(JNIEnv *env, jbyteArray buf) {
+    char *chars = NULL;
+    jbyte *bytes;
+    bytes = env->GetByteArrayElements(buf, 0);
+    if (!bytes) {
+      jniThrowIOException(env, EINVAL);
+      return JNI_FALSE;
+    }
+    int chars_len = env->GetArrayLength(buf);
+    chars = new char[chars_len + 1];
+    memset(chars, 0, chars_len + 1);
+    memcpy(chars, bytes, chars_len);
+    chars[chars_len] = 0;
+    env->ReleaseByteArrayElements(buf, bytes, 0);
+    return chars;
+}
+// Savitech Patch - END
+
 static void bta2dp_connection_state_callback(const RawAddress& bd_addr,
                                              btav_connection_state_t state) {
   ALOGI("%s", __func__);
@@ -446,6 +465,7 @@ static jboolean setActiveDeviceNative(JNIEnv* env, jobject object,
 static jboolean setCodecConfigPreferenceNative(JNIEnv* env, jobject object,
                                                jbyteArray address,
                                                jobjectArray codecConfigArray) {
+
   ALOGI("%s: sBluetoothA2dpInterface: %p", __func__, sBluetoothA2dpInterface);
   std::shared_lock<std::shared_timed_mutex> lock(interface_mutex);
   if (!sBluetoothA2dpInterface) {
@@ -473,6 +493,172 @@ static jboolean setCodecConfigPreferenceNative(JNIEnv* env, jobject object,
   return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
 }
 
+/************************************************
+ * Savitech Patch - LHDC Extended API Start
+ ***********************************************/
+static jint getLhdcCodecExtendAPIVerNative(JNIEnv* env, jobject object,
+                                           jbyteArray address,
+                                           jbyteArray codecConfig){
+
+  int status = BT_STATUS_FAIL;
+  std::shared_lock<std::shared_timed_mutex> lock(interface_mutex);
+  if (!sBluetoothA2dpInterface) {
+    ALOGE("%s: Failed to get the Bluetooth A2DP Interface", __func__);
+    return status;
+  }
+
+  jbyte* addr = env->GetByteArrayElements(address, nullptr);
+  if (!addr) {
+    jniThrowIOException(env, EINVAL);
+    return status;
+  }
+
+  RawAddress bd_addr;
+  bd_addr.FromOctets(reinterpret_cast<const uint8_t*>(addr));
+
+  char *chars = NULL;
+  int chars_len = env->GetArrayLength(codecConfig);
+  chars = jByteArrayToChar(env, codecConfig);
+  if(!chars)
+  {
+    env->ReleaseByteArrayElements(address, addr, 0);
+    return status;
+  }
+
+  //to bt_av
+  status =
+      sBluetoothA2dpInterface->getApiVer_lhdc(bd_addr, chars, chars_len);
+
+  if (status != BT_STATUS_SUCCESS) {
+    ALOGE("%s: Failed codec configuration, status: %d", __func__, status);
+  }
+  else {
+    env->SetByteArrayRegion(codecConfig, 0, chars_len, reinterpret_cast<jbyte *>(chars));
+  }
+
+  env->ReleaseByteArrayElements(address, addr, 0);
+  delete[] chars;
+
+  return status;
+}
+
+static jint getLhdcCodecExtendAPIConfigNative(JNIEnv* env, jobject object,
+                                           jbyteArray address,
+                                           jbyteArray codecConfig){
+
+  int status = BT_STATUS_FAIL;
+  std::shared_lock<std::shared_timed_mutex> lock(interface_mutex);
+  if (!sBluetoothA2dpInterface) {
+    ALOGE("%s: Failed to get the Bluetooth A2DP Interface", __func__);
+    return status;
+  }
+
+  jbyte* addr = env->GetByteArrayElements(address, nullptr);
+  if (!addr) {
+    jniThrowIOException(env, EINVAL);
+    return status;
+  }
+
+  RawAddress bd_addr;
+  bd_addr.FromOctets(reinterpret_cast<const uint8_t*>(addr));
+
+  char *chars = NULL;
+  int chars_len = env->GetArrayLength(codecConfig);
+  chars = jByteArrayToChar(env, codecConfig);
+  if(!chars)
+  {
+    env->ReleaseByteArrayElements(address, addr, 0);
+    return status;
+  }
+
+  //to bt_av
+  status =
+      sBluetoothA2dpInterface->getApiCfg_lhdc(bd_addr, chars, chars_len);
+
+  if (status != BT_STATUS_SUCCESS) {
+    ALOGE("%s: Failed codec configuration, status: %d", __func__, status);
+  }
+  else {
+    env->SetByteArrayRegion(codecConfig, 0, chars_len, reinterpret_cast<jbyte *>(chars));
+  }
+
+  env->ReleaseByteArrayElements(address, addr, 0);
+  delete[] chars;
+
+  return status;
+}
+
+static jint setLhdcCodecExtendAPIConfigNative(JNIEnv* env, jobject object,
+                                           jbyteArray address,
+                                           jbyteArray codecConfig){
+
+  std::shared_lock<std::shared_timed_mutex> lock(interface_mutex);
+  if (!sBluetoothA2dpInterface) {
+    ALOGE("%s: Failed to get the Bluetooth A2DP Interface", __func__);
+    return JNI_FALSE;
+  }
+
+  jbyte* addr = env->GetByteArrayElements(address, nullptr);
+  if (!addr) {
+    jniThrowIOException(env, EINVAL);
+    return JNI_FALSE;
+  }
+
+  RawAddress bd_addr;
+  bd_addr.FromOctets(reinterpret_cast<const uint8_t*>(addr));
+
+  char *chars = NULL;
+  int chars_len = env->GetArrayLength(codecConfig);
+  chars = jByteArrayToChar(env, codecConfig);
+
+  //to bt_av
+  int status =
+      sBluetoothA2dpInterface->setApiCfg_lhdc(bd_addr, chars, chars_len);
+
+  if (status != BT_STATUS_SUCCESS) {
+    ALOGE("%s: Failed codec configuration, status: %d", __func__, status);
+    return status;
+  }
+  env->ReleaseByteArrayElements(address, addr, 0);
+  delete[] chars;
+
+  return status;
+}
+
+static void setLhdcCodecExtendAPIDataNative(JNIEnv* env, jobject object,
+                                           jbyteArray address,
+                                           jbyteArray codecData){
+
+  std::shared_lock<std::shared_timed_mutex> lock(interface_mutex);
+  if (!sBluetoothA2dpInterface) {
+    ALOGE("%s: Failed to get the Bluetooth A2DP Interface", __func__);
+    return;
+  }
+
+  jbyte* addr = env->GetByteArrayElements(address, nullptr);
+  if (!addr) {
+    jniThrowIOException(env, EINVAL);
+    return;
+  }
+
+  RawAddress bd_addr;
+  bd_addr.FromOctets(reinterpret_cast<const uint8_t*>(addr));
+
+  char *chars = NULL;
+  int chars_len = env->GetArrayLength(codecData);
+  chars = jByteArrayToChar(env, codecData);
+
+  //to bt_av
+  sBluetoothA2dpInterface->setAPiData_lhdc(bd_addr, chars, chars_len);
+
+  env->ReleaseByteArrayElements(address, addr, 0);
+  delete[] chars;
+}
+/************************************************
+ * Savitech Patch - LHDC Extended API End
+ ***********************************************/
+
+
 static JNINativeMethod sMethods[] = {
     {"classInitNative", "()V", (void*)classInitNative},
     {"initNative", "(I[Landroid/bluetooth/BluetoothCodecConfig;)V",
@@ -485,6 +671,12 @@ static JNINativeMethod sMethods[] = {
     {"setCodecConfigPreferenceNative",
      "([B[Landroid/bluetooth/BluetoothCodecConfig;)Z",
      (void*)setCodecConfigPreferenceNative},
+
+    // Savitech Patch - LHDC Extended API
+    {"getLhdcCodecExtendAPIVerNative", "([B[B)I", (void*)getLhdcCodecExtendAPIVerNative},
+    {"getLhdcCodecExtendAPIConfigNative", "([B[B)I", (void*)getLhdcCodecExtendAPIConfigNative},
+    {"setLhdcCodecExtendAPIConfigNative", "([B[B)I", (void*)setLhdcCodecExtendAPIConfigNative},
+    {"setLhdcCodecExtendAPIDataNative", "([B[B)V", (void*)setLhdcCodecExtendAPIDataNative},
 };
 
 int register_com_android_bluetooth_a2dp(JNIEnv* env) {
diff --git a/packages/apps/Bluetooth/res/values/config.xml b/packages/apps/Bluetooth/res/values/config.xml
index 711993e1..4c4612e2 100755
--- a/packages/apps/Bluetooth/res/values/config.xml
+++ b/packages/apps/Bluetooth/res/values/config.xml
@@ -14,6 +14,7 @@
 -->
 <resources>
     <bool name="profile_supported_a2dp">true</bool>
+    <!-- Savitech Patch - A2DP_Sink_Enable-->
     <bool name="profile_supported_a2dp_sink">false</bool>
     <bool name="profile_supported_hs_hfp">true</bool>
     <bool name="profile_supported_hfpclient">false</bool>
@@ -94,6 +95,11 @@
     <integer name="a2dp_source_codec_priority_aptx">3001</integer>
     <integer name="a2dp_source_codec_priority_aptx_hd">4001</integer>
     <integer name="a2dp_source_codec_priority_ldac">5001</integer>
+    <!-- Savitech Patch -->
+    <integer name="a2dp_source_codec_priority_lhdcv3">6003</integer>
+    <integer name="a2dp_source_codec_priority_lhdcv2">6002</integer>
+    <integer name="a2dp_source_codec_priority_lhdcv1">6001</integer>
+    <integer name="a2dp_source_codec_priority_lhdcv5">6004</integer>
 
     <!-- Package that is responsible for user interaction on pairing request,
          success or cancel.
diff --git a/packages/apps/Bluetooth/src/com/android/bluetooth/a2dp/A2dpCodecConfig.java b/packages/apps/Bluetooth/src/com/android/bluetooth/a2dp/A2dpCodecConfig.java
index 918c2cee..4dbded97 100755
--- a/packages/apps/Bluetooth/src/com/android/bluetooth/a2dp/A2dpCodecConfig.java
+++ b/packages/apps/Bluetooth/src/com/android/bluetooth/a2dp/A2dpCodecConfig.java
@@ -44,6 +44,11 @@ class A2dpCodecConfig {
     private int mA2dpSourceCodecPriorityAptx = BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
     private int mA2dpSourceCodecPriorityAptxHd = BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
     private int mA2dpSourceCodecPriorityLdac = BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
+    // Savitech Patch
+    private int mA2dpSourceCodecPriorityLhdcV3 = BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
+    private int mA2dpSourceCodecPriorityLhdcV2 = BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
+    private int mA2dpSourceCodecPriorityLhdcV1 = BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
+    private int mA2dpSourceCodecPriorityLhdcV5 = BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
 
     A2dpCodecConfig(Context context, A2dpNativeInterface a2dpNativeInterface) {
         mContext = context;
@@ -59,7 +64,7 @@ class A2dpCodecConfig {
                                   BluetoothCodecStatus codecStatus,
                                   BluetoothCodecConfig codecConfig) {
         Objects.requireNonNull(codecStatus);
-
+        
         // Check whether the codecConfig is selectable for this Bluetooth device.
         BluetoothCodecConfig[] selectableCodecs = codecStatus.getCodecsSelectableCapabilities();
         if (!Arrays.asList(selectableCodecs).stream().anyMatch(codec ->
@@ -89,6 +94,47 @@ class A2dpCodecConfig {
         codecConfigArray[0] = codecConfig;
         mA2dpNativeInterface.setCodecConfigPreference(device, codecConfigArray);
     }
+    
+    /************************************************
+     * Savitech Patch - LHDC Extended API Start
+     ***********************************************/
+    int getLhdcCodecExtendAPIVer(BluetoothDevice device,
+                                byte[] exApiVer) {
+        return mA2dpNativeInterface.getLhdcCodecExtendAPIVer(device, exApiVer);
+    }
+        
+    int setLhdcCodecExtendAPIConfigAR(BluetoothDevice device,
+                                byte[] codecConfig) {
+        return mA2dpNativeInterface.setLhdcCodecExtendAPIConfigAR(device, codecConfig);
+    }
+    
+    int getLhdcCodecExtendAPIConfigAR(BluetoothDevice device,
+                                byte[] codecConfig) {
+        return mA2dpNativeInterface.getLhdcCodecExtendAPIConfigAR(device, codecConfig);
+    }    
+    
+    int setLhdcCodecExtendAPIConfigMeta(BluetoothDevice device,
+                                byte[] codecConfig) {
+        return mA2dpNativeInterface.setLhdcCodecExtendAPIConfigMeta(device, codecConfig);
+    }
+    
+    int getLhdcCodecExtendAPIConfigMeta(BluetoothDevice device,
+                                byte[] codecConfig) {
+        return mA2dpNativeInterface.getLhdcCodecExtendAPIConfigMeta(device, codecConfig);
+    }    
+    
+    int getLhdcCodecExtendAPIConfigA2dpCodecSpecific(BluetoothDevice device,
+                                byte[] codecConfig) {
+        return mA2dpNativeInterface.getLhdcCodecExtendAPIConfigA2dpCodecSpecific(device, codecConfig);
+    }    
+    
+    void setLhdcCodecExtendAPIDataGyro2D(BluetoothDevice device,
+                                byte[] codecData) {
+        mA2dpNativeInterface.setLhdcCodecExtendAPIDataGyro2D(device, codecData);
+    }
+    /************************************************
+     * Savitech Patch - LHDC Extended API End
+     ***********************************************/
 
     void enableOptionalCodecs(BluetoothDevice device, BluetoothCodecConfig currentCodecConfig) {
         if (currentCodecConfig != null && !currentCodecConfig.isMandatoryCodec()) {
@@ -154,10 +200,15 @@ class A2dpCodecConfig {
     private static boolean isCodecConfigSelectable(BluetoothCodecConfig codecConfig,
             BluetoothCodecConfig[] selectableCodecs) {
         for (BluetoothCodecConfig config : selectableCodecs) {
-            if (codecConfig.getCodecType() == config.getCodecType()
-                    && (codecConfig.getSampleRate() & config.getSampleRate()) != 0
-                    && (codecConfig.getBitsPerSample() & config.getBitsPerSample()) != 0
-                    && (codecConfig.getChannelMode() & config.getChannelMode()) != 0) {
+        	
+        	// Savitech Patch
+            Log.w(TAG, "Selected=>" + codecConfig);
+            Log.w(TAG, "config=>" + config);
+            if (codecConfig.getCodecType() == config.getCodecType())
+                    //&& (codecConfig.getSampleRate() & config.getSampleRate()) != 0
+                    //&& (codecConfig.getBitsPerSample() & config.getBitsPerSample()) != 0
+                    //&& (codecConfig.getChannelMode() & config.getChannelMode()) != 0)
+                {
                 return true;
             }
         }
@@ -222,6 +273,48 @@ class A2dpCodecConfig {
             mA2dpSourceCodecPriorityLdac = value;
         }
 
+        // Savitech Patch - START
+        try {
+            value = resources.getInteger(R.integer.a2dp_source_codec_priority_lhdcv3);
+        } catch (NotFoundException e) {
+            value = BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
+        }
+        if ((value >= BluetoothCodecConfig.CODEC_PRIORITY_DISABLED) && (value
+                < BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST)) {
+            mA2dpSourceCodecPriorityLhdcV3 = value;
+        }
+
+        try {
+            value = resources.getInteger(R.integer.a2dp_source_codec_priority_lhdcv2);
+        } catch (NotFoundException e) {
+            value = BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
+        }
+        if ((value >= BluetoothCodecConfig.CODEC_PRIORITY_DISABLED) && (value
+                < BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST)) {
+            mA2dpSourceCodecPriorityLhdcV2 = value;
+        }
+
+        try {
+            value = resources.getInteger(R.integer.a2dp_source_codec_priority_lhdcv1);
+        } catch (NotFoundException e) {
+            value = BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
+        }
+        if ((value >= BluetoothCodecConfig.CODEC_PRIORITY_DISABLED) && (value
+                < BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST)) {
+            mA2dpSourceCodecPriorityLhdcV1 = value;
+        }
+
+        try {
+            value = resources.getInteger(R.integer.a2dp_source_codec_priority_lhdcv5);
+        } catch (NotFoundException e) {
+            value = BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
+        }
+        if ((value >= BluetoothCodecConfig.CODEC_PRIORITY_DISABLED) && (value
+                < BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST)) {
+            mA2dpSourceCodecPriorityLhdcV5 = value;
+        }
+        // Savitech Patch - END
+
         BluetoothCodecConfig codecConfig;
         BluetoothCodecConfig[] codecConfigArray =
                 new BluetoothCodecConfig[BluetoothCodecConfig.SOURCE_CODEC_TYPE_MAX];
@@ -255,6 +348,32 @@ class A2dpCodecConfig {
                 .CHANNEL_MODE_NONE, 0 /* codecSpecific1 */,
                 0 /* codecSpecific2 */, 0 /* codecSpecific3 */, 0 /* codecSpecific4 */);
         codecConfigArray[4] = codecConfig;
+        // Savitech Patch - START
+        codecConfig = new BluetoothCodecConfig(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3,
+                mA2dpSourceCodecPriorityLhdcV3, BluetoothCodecConfig.SAMPLE_RATE_NONE,
+                BluetoothCodecConfig.BITS_PER_SAMPLE_NONE, BluetoothCodecConfig.CHANNEL_MODE_NONE,
+                0 /* codecSpecific1 */, 0 /* codecSpecific2 */, 0 /* codecSpecific3 */,
+                0 /* codecSpecific4 */);
+        codecConfigArray[5] = codecConfig;
+        codecConfig = new BluetoothCodecConfig(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2,
+                mA2dpSourceCodecPriorityLhdcV2, BluetoothCodecConfig.SAMPLE_RATE_NONE,
+                BluetoothCodecConfig.BITS_PER_SAMPLE_NONE, BluetoothCodecConfig.CHANNEL_MODE_NONE,
+                0 /* codecSpecific1 */, 0 /* codecSpecific2 */, 0 /* codecSpecific3 */,
+                0 /* codecSpecific4 */);
+        codecConfigArray[6] = codecConfig;
+        codecConfig = new BluetoothCodecConfig(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV1,
+                mA2dpSourceCodecPriorityLhdcV1, BluetoothCodecConfig.SAMPLE_RATE_NONE,
+                BluetoothCodecConfig.BITS_PER_SAMPLE_NONE, BluetoothCodecConfig.CHANNEL_MODE_NONE,
+                0 /* codecSpecific1 */, 0 /* codecSpecific2 */, 0 /* codecSpecific3 */,
+                0 /* codecSpecific4 */);
+        codecConfigArray[7] = codecConfig;
+        codecConfig = new BluetoothCodecConfig(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5,
+                mA2dpSourceCodecPriorityLhdcV5, BluetoothCodecConfig.SAMPLE_RATE_NONE,
+                BluetoothCodecConfig.BITS_PER_SAMPLE_NONE, BluetoothCodecConfig.CHANNEL_MODE_NONE,
+                0 /* codecSpecific1 */, 0 /* codecSpecific2 */, 0 /* codecSpecific3 */,
+                0 /* codecSpecific4 */);
+        codecConfigArray[8] = codecConfig;
+        // Savitech Patch - END
 
         return codecConfigArray;
     }
diff --git a/packages/apps/Bluetooth/src/com/android/bluetooth/a2dp/A2dpNativeInterface.java b/packages/apps/Bluetooth/src/com/android/bluetooth/a2dp/A2dpNativeInterface.java
index cbdc28a6..ca8723ec 100755
--- a/packages/apps/Bluetooth/src/com/android/bluetooth/a2dp/A2dpNativeInterface.java
+++ b/packages/apps/Bluetooth/src/com/android/bluetooth/a2dp/A2dpNativeInterface.java
@@ -136,9 +136,58 @@ public class A2dpNativeInterface {
      */
     public boolean setCodecConfigPreference(BluetoothDevice device,
                                             BluetoothCodecConfig[] codecConfigArray) {
+
         return setCodecConfigPreferenceNative(getByteAddress(device),
                                               codecConfigArray);
-    }
+    }    
+    
+    /************************************************
+     * Savitech Patch - LHDC Extended API Start
+     ***********************************************/
+    public int getLhdcCodecExtendAPIVer(BluetoothDevice device,
+    									byte[] exApiVer) {
+	
+	    return getLhdcCodecExtendAPIVerNative(getByteAddress(device), exApiVer);
+	}
+
+    public int getLhdcCodecExtendAPIConfigAR(BluetoothDevice device,
+    									byte[] codecConfig) {
+	
+	    return getLhdcCodecExtendAPIConfigNative(getByteAddress(device), codecConfig);
+	}    
+    
+    public int setLhdcCodecExtendAPIConfigAR(BluetoothDevice device,
+    									byte[] codecConfig) {
+	
+	    return setLhdcCodecExtendAPIConfigNative(getByteAddress(device), codecConfig);
+	}
+	
+    public int getLhdcCodecExtendAPIConfigMeta(BluetoothDevice device,
+    									byte[] codecConfig) {
+	
+	    return getLhdcCodecExtendAPIConfigNative(getByteAddress(device), codecConfig);
+	}
+	
+    public int getLhdcCodecExtendAPIConfigA2dpCodecSpecific(BluetoothDevice device,
+    									byte[] codecConfig) {
+	
+	    return getLhdcCodecExtendAPIConfigNative(getByteAddress(device), codecConfig);
+	}
+	
+    public int setLhdcCodecExtendAPIConfigMeta(BluetoothDevice device,
+    									byte[] codecConfig) {
+	
+	    return setLhdcCodecExtendAPIConfigNative(getByteAddress(device), codecConfig);
+	}
+	
+	public void setLhdcCodecExtendAPIDataGyro2D(BluetoothDevice device,
+    									byte[] codecData) {
+	
+	    setLhdcCodecExtendAPIDataNative(getByteAddress(device), codecData);
+	}
+	/************************************************
+     * Savitech Patch - LHDC Extended API End
+     ***********************************************/
 
     private BluetoothDevice getDevice(byte[] address) {
         return mAdapter.getRemoteDevice(address);
@@ -213,4 +262,20 @@ public class A2dpNativeInterface {
     private native boolean setActiveDeviceNative(byte[] address);
     private native boolean setCodecConfigPreferenceNative(byte[] address,
                 BluetoothCodecConfig[] codecConfigArray);
+    
+    // Savitech Patch - LHDC Extended API
+    private native int getLhdcCodecExtendAPIVerNative(byte[] address,
+    			byte[] exApiVer);
+
+    private native int setLhdcCodecExtendAPIConfigNative(byte[] address,
+    			byte[] codecConfig);
+    			
+    private native int getLhdcCodecExtendAPIConfigNative(byte[] address,
+    			byte[] codecConfig);
+
+    private native int getLhdcCodecExtendAPIA2dpCodecConfigNative(byte[] address,
+    			byte[] codecConfig);
+	
+    private native void setLhdcCodecExtendAPIDataNative(byte[] address,
+    			byte[] codecData);    			
 }
diff --git a/packages/apps/Bluetooth/src/com/android/bluetooth/a2dp/A2dpService.java b/packages/apps/Bluetooth/src/com/android/bluetooth/a2dp/A2dpService.java
index dbec19bc..2db43102 100755
--- a/packages/apps/Bluetooth/src/com/android/bluetooth/a2dp/A2dpService.java
+++ b/packages/apps/Bluetooth/src/com/android/bluetooth/a2dp/A2dpService.java
@@ -704,6 +704,7 @@ public class A2dpService extends ProfileService {
     public void setCodecConfigPreference(BluetoothDevice device,
                                          BluetoothCodecConfig codecConfig) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+
         if (DBG) {
             Log.d(TAG, "setCodecConfigPreference(" + device + "): "
                     + Objects.toString(codecConfig));
@@ -727,7 +728,83 @@ public class A2dpService extends ProfileService {
         }
         mA2dpCodecConfig.setCodecConfigPreference(device, codecStatus, codecConfig);
     }
+    
+	/************************************************
+     * Savitech Patch - LHDC Extended API Start
+     ***********************************************/
+    public int getLhdcCodecExtendAPIVer(BluetoothDevice device, 
+									byte[] exApiVer) {
+        if (device == null) {
+            Log.e(TAG, "Cannot set codec config preference: no active A2DP device");
+            return -1;
+        }
+
+        return mA2dpCodecConfig.getLhdcCodecExtendAPIVer(device, exApiVer);
+    }
+        
+    public int setLhdcCodecExtendAPIConfigAR(BluetoothDevice device, 
+									byte[] codecConfig) {
+        if (device == null) {
+            Log.e(TAG, "Cannot set codec config preference: no active A2DP device");
+            return -1;
+        }
+
+        return mA2dpCodecConfig.setLhdcCodecExtendAPIConfigAR(device, codecConfig);
+    }
+    
+    public int getLhdcCodecExtendAPIConfigAR(BluetoothDevice device, 
+									byte[] codecConfig) {
+        if (device == null) {
+            Log.e(TAG, "Cannot set codec config preference: no active A2DP device");
+            return -1;
+        }
 
+        return mA2dpCodecConfig.getLhdcCodecExtendAPIConfigAR(device, codecConfig);
+    }    
+    
+    public int setLhdcCodecExtendAPIConfigMeta(BluetoothDevice device, 
+									byte[] codecConfig) {
+        if (device == null) {
+            Log.e(TAG, "Cannot set codec config preference: no active A2DP device");
+            return -1;
+        }
+
+        return mA2dpCodecConfig.setLhdcCodecExtendAPIConfigMeta(device, codecConfig);
+    }
+    
+    public int getLhdcCodecExtendAPIConfigMeta(BluetoothDevice device, 
+									byte[] codecConfig) {
+        if (device == null) {
+            Log.e(TAG, "Cannot set codec config preference: no active A2DP device");
+            return -1;
+        }
+
+        return mA2dpCodecConfig.getLhdcCodecExtendAPIConfigMeta(device, codecConfig);
+    }
+    
+    public int getLhdcCodecExtendAPIConfigA2dpCodecSpecific(BluetoothDevice device, 
+									byte[] codecConfig) {
+        if (device == null) {
+            Log.e(TAG, "Cannot set codec config preference: no active A2DP device");
+            return -1;
+        }
+
+        return mA2dpCodecConfig.getLhdcCodecExtendAPIConfigA2dpCodecSpecific(device, codecConfig);
+    }
+    
+    public void setLhdcCodecExtendAPIDataGyro2D(BluetoothDevice device, 
+									byte[] codecData) {
+        if (device == null) {
+            Log.e(TAG, "Cannot set codec config preference: no active A2DP device");
+            return;
+        }
+        
+        mA2dpCodecConfig.setLhdcCodecExtendAPIDataGyro2D(device, codecData);
+    }
+	/************************************************
+     * Savitech Patch - LHDC Extended API End
+     ***********************************************/
+    
     /**
      * Enables the optional codecs.
      *
@@ -1280,6 +1357,82 @@ public class A2dpService extends ProfileService {
             }
             service.setCodecConfigPreference(device, codecConfig);
         }
+        
+    	/************************************************
+         * Savitech Patch - LHDC Extended API Start
+         ***********************************************/        
+		@Override
+        public int getLhdcCodecExtendAPIVer(BluetoothDevice device, 
+        											byte[] exApiVer) {
+            A2dpService service = getService();
+            if (service == null) {
+                return -1;
+            }
+            return service.getLhdcCodecExtendAPIVer(device, exApiVer);
+        }
+                
+		@Override
+        public int setLhdcCodecExtendAPIConfigAR(BluetoothDevice device, 
+        											byte[] codecConfig) {
+            A2dpService service = getService();
+            if (service == null) {
+                return -1;
+            }
+            return service.setLhdcCodecExtendAPIConfigAR(device, codecConfig);
+        }
+        
+		@Override
+        public int getLhdcCodecExtendAPIConfigAR(BluetoothDevice device, 
+        											byte[] codecConfig) {
+            A2dpService service = getService();
+            if (service == null) {
+                return -1;
+            }
+            return service.getLhdcCodecExtendAPIConfigAR(device, codecConfig);
+        }        
+        
+		@Override
+        public int setLhdcCodecExtendAPIConfigMeta(BluetoothDevice device, 
+        											byte[] codecConfig) {
+            A2dpService service = getService();
+            if (service == null) {
+                return -1;
+            }
+            return service.setLhdcCodecExtendAPIConfigMeta(device, codecConfig);
+        }
+        
+		@Override
+        public int getLhdcCodecExtendAPIConfigMeta(BluetoothDevice device, 
+        											byte[] codecConfig) {
+            A2dpService service = getService();
+            if (service == null) {
+                return -1;
+            }
+            return service.getLhdcCodecExtendAPIConfigMeta(device, codecConfig);
+        }
+        
+		@Override
+        public int getLhdcCodecExtendAPIConfigA2dpCodecSpecific(BluetoothDevice device, 
+        											byte[] codecConfig) {
+            A2dpService service = getService();
+            if (service == null) {
+                return -1;
+            }
+            return service.getLhdcCodecExtendAPIConfigA2dpCodecSpecific(device, codecConfig);
+        }
+        
+		@Override
+        public void setLhdcCodecExtendAPIDataGyro2D(BluetoothDevice device, 
+        											byte[] codecData) {
+            A2dpService service = getService();
+            if (service == null) {
+                return;
+            }
+            service.setLhdcCodecExtendAPIDataGyro2D(device, codecData);
+        }
+    	/************************************************
+         * Savitech Patch - LHDC Extended API End
+         ***********************************************/
 
         @Override
         public void enableOptionalCodecs(BluetoothDevice device) {
diff --git a/packages/apps/Bluetooth/src/com/android/bluetooth/btservice/Config.java b/packages/apps/Bluetooth/src/com/android/bluetooth/btservice/Config.java
index 2b1f46c3..4c713afe 100755
--- a/packages/apps/Bluetooth/src/com/android/bluetooth/btservice/Config.java
+++ b/packages/apps/Bluetooth/src/com/android/bluetooth/btservice/Config.java
@@ -103,7 +103,15 @@ public class Config {
     };
 
     private static Class[] sSupportedProfiles = new Class[0];
-
+    
+    // Savitech Patch - A2DP_Sink_ON_OFF_switch
+    private static boolean isBluetoothPersistedA2DPSinkOn(Context context) {
+    	final ContentResolver resolver = context.getContentResolver();
+        int state = Settings.Global.getInt(resolver, Settings.Global.BLUETOOTH_A2DPSINK, 0);
+        Log.d(TAG, "persisted A2DP Sink state: " + state);
+        return (state != 0);
+    }
+    
     static void init(Context ctx) {
         if (ctx == null) {
             return;
@@ -122,6 +130,19 @@ public class Config {
                 Log.v(TAG, "Feature Flag enables support for HearingAidService");
                 supported = true;
             }
+            
+            /* Savitech Patch - A2DP_Sink_ON_OFF_switch
+             * 	check a2dp sink persisted variable to toggle A2DP sink profile
+             * */
+            if (supported == true && config.mClass == A2dpSinkService.class) {
+            	if (isBluetoothPersistedA2DPSinkOn(ctx)) {
+            		Log.d(TAG, "A2DP Sink UI Switch State: On!");
+            		supported = true;
+            	} else {
+            		Log.d(TAG, "A2DP Sink UI Switch State: Off!");
+            		supported = false;
+            	}
+            }
 
             if (supported && !isProfileDisabled(ctx, config.mMask)) {
                 Log.v(TAG, "Adding " + config.mClass.getSimpleName());
diff --git a/packages/apps/Settings/res/xml/development_settings.xml b/packages/apps/Settings/res/xml/development_settings.xml
index 7cf52fa6..fee8bad6 100755
--- a/packages/apps/Settings/res/xml/development_settings.xml
+++ b/packages/apps/Settings/res/xml/development_settings.xml
@@ -323,6 +323,36 @@
             android:dialogTitle="@string/bluetooth_select_a2dp_codec_ldac_playback_quality_dialog_title"
             android:entries="@array/bluetooth_a2dp_codec_ldac_playback_quality_titles"
             android:entryValues="@array/bluetooth_a2dp_codec_ldac_playback_quality_values" />
+        
+        <!-- Savitech Patch - START -->
+        <ListPreference
+            android:key="bluetooth_enable_a2dp_codec_lhdc_ar_effect"
+            android:title="@string/bluetooth_enable_a2dp_codec_lhdc_ar_effect"
+            android:dialogTitle="@string/bluetooth_enable_a2dp_codec_lhdc_ar_effect_dialog_title"
+            android:entries="@array/bluetooth_enable_a2dp_codec_lhdc_ar_effect_titles"
+            android:entryValues="@array/bluetooth_enable_a2dp_codec_lhdc_ar_effect_values" />
+    
+        <ListPreference
+            android:key="bluetooth_select_a2dp_lhdc_playback_quality"
+            android:title="@string/bluetooth_select_a2dp_codec_lhdc_playback_quality"
+            android:dialogTitle="@string/bluetooth_select_a2dp_codec_lhdc_playback_quality_dialog_title"
+            android:entries="@array/bluetooth_a2dp_codec_lhdc_playback_quality_titles"
+            android:entryValues="@array/bluetooth_a2dp_codec_lhdc_playback_quality_values" />
+                
+        <ListPreference
+            android:key="bluetooth_select_a2dp_codec_lhdc_latency"
+            android:title="@string/bluetooth_select_a2dp_codec_lhdc_latency"
+            android:dialogTitle="@string/bluetooth_select_a2dp_codec_lhdc_latency_dialog_title"
+            android:entries="@array/bluetooth_a2dp_codec_lhdc_latency_titles"
+            android:entryValues="@array/bluetooth_a2dp_codec_lhdc_latency_values" />
+
+        <ListPreference
+            android:key="bluetooth_enable_a2dp_codec_lhdc_lossless"
+            android:title="@string/bluetooth_enable_a2dp_codec_lhdc_lossless"
+            android:dialogTitle="@string/bluetooth_enable_a2dp_codec_lhdc_lossless_dialog_title"
+            android:entries="@array/bluetooth_enable_a2dp_codec_lhdc_lossless_titles"
+            android:entryValues="@array/bluetooth_enable_a2dp_codec_lhdc_lossless_values" />
+        <!-- Savitech Patch - END -->
 
         <ListPreference
             android:key="bluetooth_max_connected_audio_devices"
diff --git a/packages/apps/Settings/src/com/android/settings/development/AbstractBluetoothA2dpPreferenceController.java b/packages/apps/Settings/src/com/android/settings/development/AbstractBluetoothA2dpPreferenceController.java
index 0f429c72..3947d2a7 100755
--- a/packages/apps/Settings/src/com/android/settings/development/AbstractBluetoothA2dpPreferenceController.java
+++ b/packages/apps/Settings/src/com/android/settings/development/AbstractBluetoothA2dpPreferenceController.java
@@ -34,6 +34,8 @@ import com.android.settingslib.core.lifecycle.LifecycleObserver;
 import com.android.settingslib.core.lifecycle.events.OnDestroy;
 import com.android.settingslib.development.DeveloperOptionsPreferenceController;
 
+import android.util.Log;
+
 public abstract class AbstractBluetoothA2dpPreferenceController extends
         DeveloperOptionsPreferenceController implements Preference.OnPreferenceChangeListener,
         PreferenceControllerMixin, BluetoothServiceConnectionListener, LifecycleObserver,
@@ -178,8 +180,64 @@ public abstract class AbstractBluetoothA2dpPreferenceController extends
     @VisibleForTesting
     void setCodecConfigPreference(BluetoothDevice device,
             BluetoothCodecConfig config) {
+
         mBluetoothA2dp.setCodecConfigPreference(device, config);
     }
+    
+    /************************************************
+     * Savitech Patch - LHDC Extended API Start
+     ***********************************************/
+    @VisibleForTesting
+    int getLhdcCodecExtendAPIVer(BluetoothDevice device,
+    		byte[] exApiVer) {
+        
+        return mBluetoothA2dp.getLhdcCodecExtendAPIVer(device, exApiVer);        
+    }
+    
+    @VisibleForTesting
+    int setLhdcCodecExtendAPIConfigAR(BluetoothDevice device,
+    		byte[] codecConfig) {
+        
+        return mBluetoothA2dp.setLhdcCodecExtendAPIConfigAR(device, codecConfig);        
+    }
+    
+    @VisibleForTesting
+    int getLhdcCodecExtendAPIConfigAR(BluetoothDevice device,
+    		byte[] codecConfig) {
+        
+        return mBluetoothA2dp.getLhdcCodecExtendAPIConfigAR(device, codecConfig);        
+    }
+    
+    @VisibleForTesting
+    int setLhdcCodecExtendAPIConfigMeta(BluetoothDevice device,
+    		byte[] codecConfig) {
+        
+        return mBluetoothA2dp.setLhdcCodecExtendAPIConfigMeta(device, codecConfig);        
+    }
+    
+    @VisibleForTesting
+    int getLhdcCodecExtendAPIConfigMeta(BluetoothDevice device,
+    		byte[] codecConfig) {
+        
+        return mBluetoothA2dp.getLhdcCodecExtendAPIConfigMeta(device, codecConfig);        
+    }    
+    
+    @VisibleForTesting
+    int getLhdcCodecExtendAPIConfigA2dpCodecSpecific(BluetoothDevice device,
+    		byte[] codecConfig) {
+        
+        return mBluetoothA2dp.getLhdcCodecExtendAPIConfigA2dpCodecSpecific(device, codecConfig);        
+    }
+    
+    @VisibleForTesting
+    void setLhdcCodecExtendAPIDataGyro2D(BluetoothDevice device,
+    		byte[] codecData) {
+        
+        mBluetoothA2dp.setLhdcCodecExtendAPIDataGyro2D(device, codecData);        
+    }
+    /************************************************
+     * Savitech Patch - LHDC Extended API End
+     ***********************************************/
 
     @VisibleForTesting
     BluetoothCodecConfig getCodecConfig(BluetoothDevice device) {
@@ -190,5 +248,6 @@ public abstract class AbstractBluetoothA2dpPreferenceController extends
             }
         }
         return null;
-    }
+    }   
+
 }
diff --git a/packages/apps/Settings/src/com/android/settings/development/BluetoothAudioCodecPreferenceController.java b/packages/apps/Settings/src/com/android/settings/development/BluetoothAudioCodecPreferenceController.java
index b5c40a37..660eb362 100755
--- a/packages/apps/Settings/src/com/android/settings/development/BluetoothAudioCodecPreferenceController.java
+++ b/packages/apps/Settings/src/com/android/settings/development/BluetoothAudioCodecPreferenceController.java
@@ -82,6 +82,18 @@ public class BluetoothAudioCodecPreferenceController extends
                     case 5:
                         codecTypeValue = BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC;
                         break;
+                    case 6:	//Savitech Patch
+                        codecTypeValue = BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3;
+                        break;
+                    case 7:
+                        codecTypeValue = BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2;
+                        break;
+                    case 8:
+                        codecTypeValue = BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV1;
+                        break;
+                    case 9:
+                        codecTypeValue = BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5;
+                        break;
                     default:
                         break;
                 }
@@ -106,14 +118,30 @@ public class BluetoothAudioCodecPreferenceController extends
                 codecTypeValue = BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC;
                 codecPriorityValue = BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST;
                 break;
-            case 6:
+            case 6:	//Savitech Patch
+                codecTypeValue = BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3;
+                codecPriorityValue = BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST;
+                break;
+            case 7:
+                codecTypeValue = BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2;
+                codecPriorityValue = BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST;
+                break;
+            case 8:
+                codecTypeValue = BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV1;
+                codecPriorityValue = BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST;
+                break;
+            case 9:
+                codecTypeValue = BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5;
+                codecPriorityValue = BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST;
+                break;
+            case 10:
                 synchronized (mBluetoothA2dpConfigStore) {
                     if (mBluetoothA2dp != null) {
                         mBluetoothA2dp.enableOptionalCodecs(null); // Use current active device
                     }
                 }
                 return;
-            case 7:
+            case 11:
                 synchronized (mBluetoothA2dpConfigStore) {
                     if (mBluetoothA2dp != null) {
                         mBluetoothA2dp.disableOptionalCodecs(null); // Use current active device
@@ -147,6 +175,18 @@ public class BluetoothAudioCodecPreferenceController extends
             case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC:
                 index = 5;
                 break;
+            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3:
+                index = 6;	//Savitech Patch
+                break;
+            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2:
+                index = 7;
+                break;
+            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV1:
+                index = 8;
+                break;
+            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5:
+                index = 9;
+                break;
             case BluetoothCodecConfig.SOURCE_CODEC_TYPE_INVALID:
             default:
                 break;
diff --git a/packages/apps/Settings/src/com/android/settings/development/BluetoothAudioSampleRatePreferenceController.java b/packages/apps/Settings/src/com/android/settings/development/BluetoothAudioSampleRatePreferenceController.java
index 35b449e6..6941403c 100755
--- a/packages/apps/Settings/src/com/android/settings/development/BluetoothAudioSampleRatePreferenceController.java
+++ b/packages/apps/Settings/src/com/android/settings/development/BluetoothAudioSampleRatePreferenceController.java
@@ -76,6 +76,12 @@ public class BluetoothAudioSampleRatePreferenceController extends
             case 4:
                 sampleRateValue = BluetoothCodecConfig.SAMPLE_RATE_96000;
                 break;
+            case 5:	// Savitech Patch
+                sampleRateValue = BluetoothCodecConfig.SAMPLE_RATE_176400;
+                break;
+            case 6: // Savitech Patch
+                sampleRateValue = BluetoothCodecConfig.SAMPLE_RATE_192000;
+                break;
             default:
                 break;
         }
@@ -99,8 +105,12 @@ public class BluetoothAudioSampleRatePreferenceController extends
             case BluetoothCodecConfig.SAMPLE_RATE_96000:
                 index = 4;
                 break;
-            case BluetoothCodecConfig.SAMPLE_RATE_176400:
-            case BluetoothCodecConfig.SAMPLE_RATE_192000:
+            case BluetoothCodecConfig.SAMPLE_RATE_176400:	// Savitech Patch
+                index = 5;
+                break;
+            case BluetoothCodecConfig.SAMPLE_RATE_192000:	// Savitech Patch
+                index = 6;
+                break;
             case BluetoothCodecConfig.SAMPLE_RATE_NONE:
             default:
                 break;
diff --git a/packages/apps/Settings/src/com/android/settings/development/BluetoothLHDCAudioArEffectPreferenceController.java b/packages/apps/Settings/src/com/android/settings/development/BluetoothLHDCAudioArEffectPreferenceController.java
new file mode 100755
index 00000000..8170c1cd
--- /dev/null
+++ b/packages/apps/Settings/src/com/android/settings/development/BluetoothLHDCAudioArEffectPreferenceController.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.development;
+
+import android.bluetooth.BluetoothCodecConfig;
+import android.content.Context;
+
+import com.android.settings.R;
+import com.android.settingslib.core.lifecycle.Lifecycle;
+import android.util.Log;
+
+/* 
+ * Savitech Patch: LHDC AR Effect UI Preference Controller 
+ */
+public class BluetoothLHDCAudioArEffectPreferenceController extends
+        AbstractBluetoothA2dpPreferenceController {
+
+    private static final int DEFAULT_INDEX = 0;
+    private static final String BLUETOOTH_SELECT_A2DP_LHDC_AR_EFFECT_KEY =
+            "bluetooth_enable_a2dp_codec_lhdc_ar_effect";
+
+    private static final int LHDC_FEATURE_MASK = 0xFF000000;
+    private static final int LHDC_FEATURE_TAG = 0x4C000000;
+	private static final int LHDC_AR_FEATURE = 0x02;
+
+    public BluetoothLHDCAudioArEffectPreferenceController(Context context, Lifecycle lifecycle,
+            BluetoothA2dpConfigStore store) {
+        super(context, lifecycle, store);
+    }
+
+    @Override
+    public String getPreferenceKey() {
+        return BLUETOOTH_SELECT_A2DP_LHDC_AR_EFFECT_KEY;
+    }
+
+    @Override
+    protected String[] getListValues() {
+        return mContext.getResources().getStringArray(
+                R.array.bluetooth_enable_a2dp_codec_lhdc_ar_effect_values);
+    }
+
+    @Override
+    protected String[] getListSummaries() {
+        return mContext.getResources().getStringArray(
+                R.array.bluetooth_enable_a2dp_codec_lhdc_ar_effect_summaries);
+    }
+
+    @Override
+    protected int getDefaultIndex() {
+        return DEFAULT_INDEX;
+    }
+
+    @Override
+    protected void writeConfigurationValues(Object newValue) {
+        final int index = mPreference.findIndexOfValue(newValue.toString());
+        
+        int codecSpecific3Value = 0; // default
+        codecSpecific3Value |= LHDC_FEATURE_TAG;
+        
+        if (index != 0) {
+            codecSpecific3Value |= LHDC_AR_FEATURE;
+        }else{
+	        codecSpecific3Value &= ~LHDC_AR_FEATURE;
+        }
+        mBluetoothA2dpConfigStore.setCodecSpecific3Value(codecSpecific3Value);
+    }
+
+    @Override
+    protected int getCurrentA2dpSettingIndex(BluetoothCodecConfig config) {
+    	int ret = 0;
+        int index = (int)config.getCodecSpecific3();
+        Log.i("LHDC_UI_AR", "get index = " + index);
+        
+        int tmp = index & LHDC_FEATURE_MASK;
+        if (tmp == LHDC_FEATURE_TAG)
+        {
+	        if ((index & LHDC_AR_FEATURE) != 0) {
+		    	Log.i("LHDC_UI_AR", "return AR ON");
+	            ret = 1;
+	        } else {
+				Log.i("LHDC_UI_AR", "return AR OFF");
+	            ret = 0;
+	        }
+        }
+        else
+        {
+			Log.i("LHDC_UI_AR", "tag not matched, return AR OFF");
+            ret = 0;
+        }
+        return ret;
+    }
+}
diff --git a/packages/apps/Settings/src/com/android/settings/development/BluetoothLHDCAudioLatencyPreferenceController.java b/packages/apps/Settings/src/com/android/settings/development/BluetoothLHDCAudioLatencyPreferenceController.java
new file mode 100755
index 00000000..bba7fa8a
--- /dev/null
+++ b/packages/apps/Settings/src/com/android/settings/development/BluetoothLHDCAudioLatencyPreferenceController.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.development;
+
+import android.bluetooth.BluetoothCodecConfig;
+import android.content.Context;
+
+import com.android.settings.R;
+import com.android.settingslib.core.lifecycle.Lifecycle;
+
+/* 
+ * Savitech Patch: LHDC Audio Latency UI Preference Controller 
+ */
+public class BluetoothLHDCAudioLatencyPreferenceController extends
+        AbstractBluetoothA2dpPreferenceController {
+
+    private static final int DEFAULT_INDEX = 0;
+    private static final String BLUETOOTH_SELECT_A2DP_LHDC_LATENCY_KEY =
+            "bluetooth_select_a2dp_codec_lhdc_latency";
+
+    public BluetoothLHDCAudioLatencyPreferenceController(Context context, Lifecycle lifecycle,
+            BluetoothA2dpConfigStore store) {
+        super(context, lifecycle, store);
+    }
+
+    @Override
+    public String getPreferenceKey() {
+        return BLUETOOTH_SELECT_A2DP_LHDC_LATENCY_KEY;
+    }
+
+    @Override
+    protected String[] getListValues() {
+        return mContext.getResources().getStringArray(
+                R.array.bluetooth_a2dp_codec_lhdc_latency_values);
+    }
+
+    @Override
+    protected String[] getListSummaries() {
+        return mContext.getResources().getStringArray(
+                R.array.bluetooth_a2dp_codec_lhdc_latency_summaries);
+    }
+
+    @Override
+    protected int getDefaultIndex() {
+        return DEFAULT_INDEX;
+    }
+
+    @Override
+    protected void writeConfigurationValues(Object newValue) {
+        final int index = mPreference.findIndexOfValue(newValue.toString());
+        int codecSpecific2Value = 0; // default
+        if (index <= 1) {
+            codecSpecific2Value = 0xC000 | index;
+        }else{
+	        codecSpecific2Value = 0xC000 | DEFAULT_INDEX;
+        }
+        mBluetoothA2dpConfigStore.setCodecSpecific2Value(codecSpecific2Value);
+    }
+
+    @Override
+    protected int getCurrentA2dpSettingIndex(BluetoothCodecConfig config) {
+        int index = (int)config.getCodecSpecific2();
+        int tmp = index & 0xC000;
+        if (tmp == 0xC000) {
+            index &= 0x1;
+        } else {
+            index = DEFAULT_INDEX;
+        }
+        return index;
+    }
+}
diff --git a/packages/apps/Settings/src/com/android/settings/development/BluetoothLHDCAudioLosslessPreferenceController.java b/packages/apps/Settings/src/com/android/settings/development/BluetoothLHDCAudioLosslessPreferenceController.java
new file mode 100755
index 00000000..6e0a3687
--- /dev/null
+++ b/packages/apps/Settings/src/com/android/settings/development/BluetoothLHDCAudioLosslessPreferenceController.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.development;
+
+import android.bluetooth.BluetoothCodecConfig;
+import android.content.Context;
+
+import com.android.settings.R;
+import com.android.settingslib.core.lifecycle.Lifecycle;
+import android.util.Log;
+
+/**
+ * Switch preference controller for LHDC Lossless ON/OFF
+ */
+public class BluetoothLHDCAudioLosslessPreferenceController extends
+        AbstractBluetoothA2dpPreferenceController {
+
+    private static final int DEFAULT_INDEX = 0;
+    private static final String BLUETOOTH_SELECT_A2DP_LHDC_LOSSLESS_KEY =
+            "bluetooth_enable_a2dp_codec_lhdc_lossless";
+
+    private static final int LHDC_FEATURE_MASK = 0xFF000000;
+    private static final int LHDC_FEATURE_TAG = 0x4C000000;
+    private static final int LHDC_LOSSLESS_FEATURE = 0x80;
+
+    public BluetoothLHDCAudioLosslessPreferenceController(Context context, Lifecycle lifecycle,
+            BluetoothA2dpConfigStore store) {
+        super(context, lifecycle, store);
+    }
+
+    @Override
+    public String getPreferenceKey() {
+        return BLUETOOTH_SELECT_A2DP_LHDC_LOSSLESS_KEY;
+    }
+
+    @Override
+    protected String[] getListValues() {
+        return mContext.getResources().getStringArray(
+                R.array.bluetooth_enable_a2dp_codec_lhdc_lossless_values);
+    }
+
+    @Override
+    protected String[] getListSummaries() {
+        return mContext.getResources().getStringArray(
+                R.array.bluetooth_enable_a2dp_codec_lhdc_lossless_summaries);
+    }
+
+    @Override
+    protected int getDefaultIndex() {
+        return DEFAULT_INDEX;
+    }
+
+    @Override
+    protected void writeConfigurationValues(Object newValue) {
+        final int index = mPreference.findIndexOfValue(newValue.toString());
+        
+        int codecSpecific3Value = 0; // default
+        codecSpecific3Value |= LHDC_FEATURE_TAG;
+        
+        if (index != 0) {
+            codecSpecific3Value |= LHDC_LOSSLESS_FEATURE;
+        }else{
+	        codecSpecific3Value &= ~LHDC_LOSSLESS_FEATURE;
+        }
+        mBluetoothA2dpConfigStore.setCodecSpecific3Value(codecSpecific3Value);
+    }
+
+    @Override
+    protected int getCurrentA2dpSettingIndex(BluetoothCodecConfig config) {
+        int ret = 0;
+        int index = (int)config.getCodecSpecific3();
+        int tmp = index & LHDC_FEATURE_MASK;
+        if (tmp == LHDC_FEATURE_TAG) {
+            if ((index & LHDC_LOSSLESS_FEATURE) != 0) {
+                ret = 1;
+            } else {
+                ret = 0;
+            }
+        } else {
+            ret = 0;
+        }
+        return ret;
+    }
+}
diff --git a/packages/apps/Settings/src/com/android/settings/development/BluetoothLHDCAudioQualityPreferenceController.java b/packages/apps/Settings/src/com/android/settings/development/BluetoothLHDCAudioQualityPreferenceController.java
new file mode 100755
index 00000000..cba56bd7
--- /dev/null
+++ b/packages/apps/Settings/src/com/android/settings/development/BluetoothLHDCAudioQualityPreferenceController.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.development;
+
+import android.bluetooth.BluetoothCodecConfig;
+import android.content.Context;
+
+import com.android.settings.R;
+import com.android.settingslib.core.lifecycle.Lifecycle;
+
+/* 
+ * Savitech Patch: LHDC Audio Quality UI Preference Controller 
+ */
+public class BluetoothLHDCAudioQualityPreferenceController extends
+        AbstractBluetoothA2dpPreferenceController {
+
+    private static final int DEFAULT_INDEX = 5;
+    private static final int DEFAULT_MAX_INDEX = 9;
+    
+    private static final String BLUETOOTH_SELECT_A2DP_LHDC_PLAYBACK_QUALITY_KEY =
+            "bluetooth_select_a2dp_lhdc_playback_quality";
+
+    public BluetoothLHDCAudioQualityPreferenceController(Context context, Lifecycle lifecycle,
+            BluetoothA2dpConfigStore store) {
+        super(context, lifecycle, store);
+    }
+
+    @Override
+    public String getPreferenceKey() {
+        return BLUETOOTH_SELECT_A2DP_LHDC_PLAYBACK_QUALITY_KEY;
+    }
+
+    @Override
+    protected String[] getListValues() {
+        return mContext.getResources().getStringArray(
+                R.array.bluetooth_a2dp_codec_lhdc_playback_quality_values);
+    }
+
+    @Override
+    protected String[] getListSummaries() {
+        return mContext.getResources().getStringArray(
+                R.array.bluetooth_a2dp_codec_lhdc_playback_quality_summaries);
+    }
+
+    @Override
+    protected int getDefaultIndex() {
+        return DEFAULT_INDEX;
+    }
+
+    @Override
+    protected void writeConfigurationValues(Object newValue) {
+        int index = mPreference.findIndexOfValue(newValue.toString());
+        int codecSpecific1Value = 0; // default
+        if (index <= DEFAULT_MAX_INDEX) {
+            codecSpecific1Value = 0x8000 | index;
+        }else{
+            codecSpecific1Value = 0x8000 | DEFAULT_INDEX;
+        }
+        mBluetoothA2dpConfigStore.setCodecSpecific1Value(codecSpecific1Value);
+    }
+
+    @Override
+    protected int getCurrentA2dpSettingIndex(BluetoothCodecConfig config) {
+        int index = (int) config.getCodecSpecific1();
+        
+        int tmp = index & 0xC000;
+        if (tmp == 0x8000) {
+           index &= 0xff;
+        } else {
+           index = DEFAULT_INDEX;
+        }
+
+        return index;
+    }
+}
diff --git a/packages/apps/Settings/src/com/android/settings/development/DevelopmentSettingsDashboardFragment.java b/packages/apps/Settings/src/com/android/settings/development/DevelopmentSettingsDashboardFragment.java
index f384d857..9590a8fb 100755
--- a/packages/apps/Settings/src/com/android/settings/development/DevelopmentSettingsDashboardFragment.java
+++ b/packages/apps/Settings/src/com/android/settings/development/DevelopmentSettingsDashboardFragment.java
@@ -449,6 +449,15 @@ public class DevelopmentSettingsDashboardFragment extends RestrictedDashboardFra
                 bluetoothA2dpConfigStore));
         controllers.add(new BluetoothAudioQualityPreferenceController(context, lifecycle,
                 bluetoothA2dpConfigStore));
+        // Savitech Patch
+        controllers.add(new BluetoothLHDCAudioArEffectPreferenceController(context, lifecycle,
+                bluetoothA2dpConfigStore));
+        controllers.add(new BluetoothLHDCAudioQualityPreferenceController(context, lifecycle,
+                bluetoothA2dpConfigStore));
+        controllers.add(new BluetoothLHDCAudioLatencyPreferenceController(context, lifecycle,
+                bluetoothA2dpConfigStore));
+        controllers.add(new BluetoothLHDCAudioLosslessPreferenceController(context, lifecycle,
+                bluetoothA2dpConfigStore));
         controllers.add(new BluetoothMaxConnectedAudioDevicesPreferenceController(context));
         controllers.add(new ShowTapsPreferenceController(context));
         controllers.add(new PointerLocationPreferenceController(context));
diff --git a/system/bt/audio_hal_interface/a2dp_encoding.cc b/system/bt/audio_hal_interface/a2dp_encoding.cc
index fc611284..570349d7 100755
--- a/system/bt/audio_hal_interface/a2dp_encoding.cc
+++ b/system/bt/audio_hal_interface/a2dp_encoding.cc
@@ -529,6 +529,12 @@ bool a2dp_get_selected_hal_codec_config(CodecConfiguration* codec_config) {
       codec_config->config.ldacConfig(ldac_config);
       break;
     }
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+	  case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3:
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+    case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5:
+      // Savitech Patch
+      [[fallthrough]];
     case BTAV_A2DP_CODEC_INDEX_MAX:
       [[fallthrough]];
     default:
diff --git a/system/bt/binder/android/bluetooth/IBluetoothA2dp.aidl b/system/bt/binder/android/bluetooth/IBluetoothA2dp.aidl
index 6606a1b5..4de83964 100755
--- a/system/bt/binder/android/bluetooth/IBluetoothA2dp.aidl
+++ b/system/bt/binder/android/bluetooth/IBluetoothA2dp.aidl
@@ -47,4 +47,17 @@ interface IBluetoothA2dp {
     int supportsOptionalCodecs(in BluetoothDevice device);
     int getOptionalCodecsEnabled(in BluetoothDevice device);
     oneway void setOptionalCodecsEnabled(in BluetoothDevice device, int value);
+    
+    // Savitech Patch LHDC Extended API - Start
+    int getLhdcCodecExtendAPIVer(in BluetoothDevice device, inout byte[] exApiVer);
+    int setLhdcCodecExtendAPIConfigAR(in BluetoothDevice device, in byte[] codecConfig);
+    int getLhdcCodecExtendAPIConfigAR(in BluetoothDevice device, inout byte[] codecConfig);
+    int setLhdcCodecExtendAPIConfigMeta(in BluetoothDevice device, in byte[] codecConfig);
+    int getLhdcCodecExtendAPIConfigMeta(in BluetoothDevice device, inout byte[] codecConfig);
+    // Savitech Patch LHDC Extended API - End
+    
+    int getLhdcCodecExtendAPIConfigA2dpCodecSpecific(in BluetoothDevice device, inout byte[] codecConfig);
+        
+    //LHDC Extended Function: data-type APIs
+    oneway void setLhdcCodecExtendAPIDataGyro2D(in BluetoothDevice device, in byte[] codecData);    
 }
diff --git a/system/bt/btif/co/bta_av_co.cc b/system/bt/btif/co/bta_av_co.cc
index 9f17d4aa..036dede2 100755
--- a/system/bt/btif/co/bta_av_co.cc
+++ b/system/bt/btif/co/bta_av_co.cc
@@ -1,5 +1,4 @@
-/******************************************************************************
- *
+/****************************************************************************** *
  *  Copyright 2004-2012 Broadcom Corporation
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
@@ -422,7 +421,7 @@ class BtaAvCo {
   bool SetCodecUserConfig(const RawAddress& peer_address,
                           const btav_a2dp_codec_config_t& codec_user_config);
 
-  /**
+   /**
    * Set the codec audio configuration.
    *
    * @param codec_audio_config the codec audio configuration to set
@@ -960,7 +959,8 @@ tA2DP_STATUS BtaAvCo::ProcessSourceGetConfig(
   // Select the Source codec
   const BtaAvCoSep* p_sink = nullptr;
   if (p_peer->acceptor) {
-    UpdateAllSelectableSourceCodecs(p_peer);
+    // Savitech Patch
+    size_t updated_codecs = UpdateAllSelectableSourceCodecs(p_peer);
     if (p_peer->p_sink == nullptr) {
       // Update the selected codec
       p_peer->p_sink =
@@ -972,6 +972,14 @@ tA2DP_STATUS BtaAvCo::ProcessSourceGetConfig(
                        __func__, p_peer->addr.ToString().c_str());
       return A2DP_FAIL;
     }
+    /* Savitech Patch
+     * NOTE: Dispatch the event to make sure a callback with the most recent UPDATED codec info is generated.
+     */
+    if (updated_codecs > 0)
+    {
+      APPL_TRACE_DEBUG("%s: onCodecConfigChanged(updated_codecs:%d)", __func__, updated_codecs);
+  	  ReportSourceCodecState(p_peer);
+    }
   } else {
     p_sink = SelectSourceCodec(p_peer);
     if (p_sink == nullptr) {
@@ -1494,9 +1502,9 @@ bool BtaAvCo::SetCodecUserConfig(
   tA2DP_ENCODER_INIT_PEER_PARAMS peer_params;
   GetPeerEncoderParameters(p_peer->addr, &peer_params);
   if (!p_peer->GetCodecs()->setCodecUserConfig(
-          codec_user_config, &peer_params, p_sink->codec_caps,
-          result_codec_config, &restart_input, &restart_output,
-          &config_updated)) {
+      codec_user_config, &peer_params, p_sink->codec_caps,
+      result_codec_config, &restart_input, &restart_output,
+      &config_updated)) {
     success = false;
     goto done;
   }
@@ -1525,8 +1533,6 @@ bool BtaAvCo::SetCodecUserConfig(
     }
 
     p_peer->acceptor = false;
-    APPL_TRACE_DEBUG("%s: call BTA_AvReconfig(0x%x)", __func__,
-                     p_peer->BtaAvHandle());
     BTA_AvReconfig(p_peer->BtaAvHandle(), true, p_sink->sep_info_idx,
                    p_peer->codec_config, num_protect, bta_av_co_cp_scmst);
   }
@@ -1594,7 +1600,7 @@ bool BtaAvCo::SetCodecAudioConfig(
     } else {
       p_peer->acceptor = false;
       APPL_TRACE_DEBUG("%s: call BTA_AvReconfig(0x%x)", __func__,
-                       p_peer->BtaAvHandle());
+          p_peer->BtaAvHandle());
       BTA_AvReconfig(p_peer->BtaAvHandle(), true, p_sink->sep_info_idx,
                      p_peer->codec_config, num_protect, bta_av_co_cp_scmst);
     }
@@ -2173,6 +2179,142 @@ bool bta_av_co_set_codec_user_config(
   return bta_av_co_cb.SetCodecUserConfig(peer_address, codec_user_config);
 }
 
+/************************************************
+ * Savitech Patch - LHDC Extended API Start
+ ***********************************************/
+// LHDC Extended API: get target API version
+int bta_av_co_get_codec_LHDC_user_ApiVer(
+    const RawAddress& peer_address,
+    const char *version, const int clen) {
+
+  int success = BT_STATUS_SUCCESS;
+  A2dpCodecConfig* peerCodec = NULL;
+
+  BtaAvCoPeer* p_peer = bta_av_co_cb.FindPeer(peer_address);
+  if (p_peer == nullptr) {
+    APPL_TRACE_ERROR("%s: cannot find peer %s to configure", __func__,
+        peer_address.ToString().c_str());
+    success = BT_STATUS_NOT_READY;
+    goto done;
+  }
+
+  peerCodec = p_peer->GetCodecs()->getCurrentCodecConfig();
+  if (peerCodec) {
+    APPL_TRACE_DEBUG("%s: peerCodec name=%s, codecIndex=%d", __func__,
+        peerCodec->name().c_str(), peerCodec->codecIndex());
+    success = p_peer->GetCodecs()->getLHDCCodecUserApiVer(peerCodec, version, clen);
+    goto done;
+  } else {
+    APPL_TRACE_WARNING("%s: Fail to get current codec of peer!", __func__);
+    success = BT_STATUS_NOT_READY;
+    goto done;
+  }
+
+done:
+  return success;
+}
+
+// LHDC extended API: get user config
+int bta_av_co_get_codec_LHDC_user_config(
+    const RawAddress& peer_address,
+    const char *config, const int clen) {
+
+  int success = BT_STATUS_SUCCESS;
+  A2dpCodecConfig* peerCodec = NULL;
+
+  BtaAvCoPeer* p_peer = bta_av_co_cb.FindPeer(peer_address);
+  if (p_peer == nullptr) {
+    APPL_TRACE_ERROR("%s: cannot find peer %s to configure", __func__,
+        peer_address.ToString().c_str());
+    success = BT_STATUS_NOT_READY;
+    goto done;
+  }
+
+  peerCodec = p_peer->GetCodecs()->getCurrentCodecConfig();
+  if (peerCodec) {
+    APPL_TRACE_DEBUG("%s: peerCodec name=%s, codecIndex=%d", __func__,
+        peerCodec->name().c_str(), peerCodec->codecIndex());
+    success = p_peer->GetCodecs()->getLHDCCodecUserConfig(peerCodec, config, clen);
+    goto done;
+  } else {
+    APPL_TRACE_WARNING("%s: Fail to get current codec of peer!", __func__);
+    success = BT_STATUS_NOT_READY;
+    goto done;
+  }
+
+done:
+  return success;
+}
+
+// LHDC extended API: set user config
+int bta_av_co_set_codec_LHDC_user_config(
+    const RawAddress& peer_address,
+    const char *config, const int clen) {
+
+  int success = BT_STATUS_SUCCESS;
+  A2dpCodecConfig* peerCodec = NULL;
+
+  BtaAvCoPeer* p_peer = bta_av_co_cb.FindPeer(peer_address);
+  if (p_peer == nullptr) {
+    APPL_TRACE_ERROR("%s: cannot find peer %s to configure", __func__,
+        peer_address.ToString().c_str());
+    success = BT_STATUS_NOT_READY;
+    goto done;
+  }
+
+  peerCodec = p_peer->GetCodecs()->getCurrentCodecConfig();
+  if (peerCodec) {
+    APPL_TRACE_DEBUG("%s: peerCodec name=%s, codecIndex=%d", __func__,
+        peerCodec->name().c_str(), peerCodec->codecIndex());
+    success = p_peer->GetCodecs()->setLHDCCodecUserConfig(peerCodec, config, clen);
+    goto done;
+  } else {
+    APPL_TRACE_WARNING("%s: Fail to get current codec of peer!", __func__);
+    success = BT_STATUS_NOT_READY;
+    goto done;
+  }
+
+done:
+  return success;
+}
+
+// LHDC extended API: set user data
+bool bta_av_co_set_codec_LHDC_user_data(
+    const RawAddress& peer_address,
+    const char *data, const int clen) {
+
+  bool success = true;
+  A2dpCodecConfig* peerCodec = NULL;
+
+  BtaAvCoPeer* p_peer = bta_av_co_cb.FindPeer(peer_address);
+  if (p_peer == nullptr) {
+    APPL_TRACE_ERROR("%s: cannot find peer %s to configure", __func__,
+        peer_address.ToString().c_str());
+    success = false;
+    goto done;
+  }
+
+  peerCodec = p_peer->GetCodecs()->getCurrentCodecConfig();
+  if (peerCodec) {
+    APPL_TRACE_DEBUG("%s: peerCodec: name=%s, codecIndex=%d", __func__,
+        peerCodec->name().c_str(), peerCodec->codecIndex());
+    if (!p_peer->GetCodecs()->setLHDCCodecUserData(peerCodec, data, clen)) {
+      success = false;
+      goto done;
+    }
+  } else {
+    APPL_TRACE_WARNING("%s: Fail to get current codec of peer!", __func__);
+    success = false;
+    goto done;
+  }
+
+done:
+  return success;
+}
+/************************************************
+ * Savitech Patch - LHDC Extended API End
+ ***********************************************/
+
 bool bta_av_co_set_codec_audio_config(
     const btav_a2dp_codec_config_t& codec_audio_config) {
   return bta_av_co_cb.SetCodecAudioConfig(codec_audio_config);
diff --git a/system/bt/btif/include/btif_a2dp_source.h b/system/bt/btif/include/btif_a2dp_source.h
index 0649012b..9131ad3a 100755
--- a/system/bt/btif/include/btif_a2dp_source.h
+++ b/system/bt/btif/include/btif_a2dp_source.h
@@ -91,6 +91,24 @@ void btif_a2dp_source_encoder_user_config_update_req(
     const RawAddress& peer_addr,
     const btav_a2dp_codec_config_t& codec_user_config);
 
+
+// Savitech Patch - LHDC Extended API - Start
+int btif_a2dp_source_encoder_LHDC_user_ApiVer_retrieve_req(
+    const RawAddress& peer_addr,
+    const char *config, const int clen);
+
+int btif_a2dp_source_encoder_LHDC_user_config_retrieve_req(
+    const RawAddress& peer_addr,
+    const char *config, const int clen);
+
+int btif_a2dp_source_encoder_LHDC_user_config_update_req(
+    const RawAddress& peer_addr,
+    const char *config, const int clen);
+
+void btif_a2dp_source_encoder_LHDC_user_data_update_req(
+		uint16_t event, char* p_param);
+// Savitech Patch - LHDC Extended API - End
+
 // Process a request to update the A2DP audio encoding with new audio
 // configuration feeding parameters stored in |codec_audio_config|.
 // The fields that are used are: |codec_audio_config.sample_rate|,
diff --git a/system/bt/btif/include/btif_av_co.h b/system/bt/btif/include/btif_av_co.h
index 93d6d7ed..3c46df64 100755
--- a/system/bt/btif/include/btif_av_co.h
+++ b/system/bt/btif/include/btif_av_co.h
@@ -85,4 +85,22 @@ A2dpCodecConfig* bta_av_get_a2dp_peer_current_codec(
 // information.
 void btif_a2dp_codec_debug_dump(int fd);
 
+// Savitech Patch - LHDC Extended API - Start
+int bta_av_co_get_codec_LHDC_user_ApiVer(
+    const RawAddress& peer_addr,
+    const char *config, const int clen);
+
+int bta_av_co_get_codec_LHDC_user_config(
+    const RawAddress& peer_addr,
+    const char *config, const int clen);
+
+int bta_av_co_set_codec_LHDC_user_config(
+    const RawAddress& peer_addr,
+    const char *config, const int clen);
+
+bool bta_av_co_set_codec_LHDC_user_data(
+    const RawAddress& peer_addr,
+    const char *config, const int clen);
+// Savitech Patch - LHDC Extended API - End
+
 #endif  // BTIF_AV_CO_H
diff --git a/system/bt/btif/src/btif_a2dp_sink.cc b/system/bt/btif/src/btif_a2dp_sink.cc
index bb1bc49c..902844b5 100755
--- a/system/bt/btif/src/btif_a2dp_sink.cc
+++ b/system/bt/btif/src/btif_a2dp_sink.cc
@@ -87,7 +87,8 @@ class BtifA2dpSinkControlBlock {
         decode_alarm(nullptr),
         sample_rate(0),
         channel_count(0),
-        rx_focus_state(BTIF_A2DP_SINK_FOCUS_NOT_GRANTED),
+        //rx_focus_state(BTIF_A2DP_SINK_FOCUS_NOT_GRANTED),
+        rx_focus_state(BTIF_A2DP_SINK_FOCUS_GRANTED),   //Savitech Patch - A2DP_Sink_Enable
         audio_track(nullptr),
         decoder_interface(nullptr) {}
 
@@ -102,7 +103,8 @@ class BtifA2dpSinkControlBlock {
     alarm_free(decode_alarm);
     decode_alarm = nullptr;
     rx_flush = false;
-    rx_focus_state = BTIF_A2DP_SINK_FOCUS_NOT_GRANTED;
+    //rx_focus_state = BTIF_A2DP_SINK_FOCUS_NOT_GRANTED;
+    rx_focus_state = BTIF_A2DP_SINK_FOCUS_GRANTED;  //Savitech Patch - A2DP_Sink_Enable
     sample_rate = 0;
     channel_count = 0;
     decoder_interface = nullptr;
diff --git a/system/bt/btif/src/btif_a2dp_source.cc b/system/bt/btif/src/btif_a2dp_source.cc
index 9951ce1c..d9e85eaa 100755
--- a/system/bt/btif/src/btif_a2dp_source.cc
+++ b/system/bt/btif/src/btif_a2dp_source.cc
@@ -247,6 +247,25 @@ static void btif_a2dp_source_setup_codec_delayed(
 static void btif_a2dp_source_encoder_user_config_update_event(
     const RawAddress& peer_address,
     const btav_a2dp_codec_config_t& codec_user_config);
+
+// Savitech Patch - LHDC Extended API Start
+static int btif_a2dp_source_encoder_LHDC_user_ApiVer_retrieve_event(
+    const RawAddress& peer_address,
+    const char *version, const int clen);
+
+static int btif_a2dp_source_encoder_LHDC_user_config_retrieve_event(
+    const RawAddress& peer_address,
+    const char *config, const int clen);
+
+static int btif_a2dp_source_encoder_LHDC_user_config_update_event(
+    const RawAddress& peer_address,
+    const char *config, const int clen);
+
+static void btif_a2dp_source_encoder_LHDC_user_data_update_event(
+    const RawAddress& peer_address,
+    const char *data, const int clen);
+// Savitech Patch - LHDC Extended API End
+
 static void btif_a2dp_source_audio_feeding_update_event(
     const btav_a2dp_codec_config_t& codec_audio_config);
 static bool btif_a2dp_source_audio_tx_flush_req(void);
@@ -638,6 +657,76 @@ static void btif_a2dp_source_encoder_user_config_update_event(
   }
 }
 
+// Savitech Patch - LHDC extended API: get version
+int btif_a2dp_source_encoder_LHDC_user_ApiVer_retrieve_req(
+    const RawAddress& peer_address,
+    const char *version, const int clen) {
+
+  return btif_a2dp_source_encoder_LHDC_user_ApiVer_retrieve_event(peer_address, version, clen);
+}
+static int btif_a2dp_source_encoder_LHDC_user_ApiVer_retrieve_event(
+    const RawAddress& peer_address,
+    const char *version, const int clen) {
+
+  return bta_av_co_get_codec_LHDC_user_ApiVer(peer_address, version, clen);
+}
+
+// Savitech Patch - LHDC extended API: get config
+int btif_a2dp_source_encoder_LHDC_user_config_retrieve_req(
+    const RawAddress& peer_address,
+    const char *config, const int clen) {
+
+  return btif_a2dp_source_encoder_LHDC_user_config_retrieve_event(peer_address, config, clen);
+}
+static int btif_a2dp_source_encoder_LHDC_user_config_retrieve_event(
+    const RawAddress& peer_address,
+    const char *config, const int clen) {
+
+  return bta_av_co_get_codec_LHDC_user_config(peer_address, config, clen);
+}
+
+// Savitech Patch - LHDC extended API: set config
+int btif_a2dp_source_encoder_LHDC_user_config_update_req(
+    const RawAddress& peer_address,
+    const char *config, const int clen) {
+
+  return btif_a2dp_source_encoder_LHDC_user_config_update_event(peer_address, config, clen);
+}
+static int btif_a2dp_source_encoder_LHDC_user_config_update_event(
+    const RawAddress& peer_address,
+    const char *config, const int clen) {
+
+  return bta_av_co_set_codec_LHDC_user_config(peer_address, config, clen);
+}
+
+// Savitech Patch - LHDC extended API: set user data
+void btif_a2dp_source_encoder_LHDC_user_data_update_req(
+		uint16_t event, char* p_param){
+	/*
+    const RawAddress& peer_address,
+    const char *data, const int clen)
+	 */
+	btif_av_codec_lhdc_api_data_t *pData;
+	pData = (btif_av_codec_lhdc_api_data_t *) p_param;
+
+    RawAddress peer_address;
+    memcpy(&peer_address, &(pData->bd_addr), sizeof(RawAddress) );
+    char *data = pData->pData;
+	int clen = pData->clen;
+
+  btif_a2dp_source_thread.DoInThread(
+      FROM_HERE, base::Bind(&btif_a2dp_source_encoder_LHDC_user_data_update_event,
+          peer_address, data, clen));
+}
+static void btif_a2dp_source_encoder_LHDC_user_data_update_event(
+    const RawAddress& peer_address,
+    const char *data, const int clen) {
+
+  if (!bta_av_co_set_codec_LHDC_user_data(peer_address, data, clen)) {
+    LOG_ERROR(LOG_TAG, "%s: cannot update codec user configuration", __func__);
+  }
+}
+
 void btif_a2dp_source_feeding_update_req(
     const btav_a2dp_codec_config_t& codec_audio_config) {
   LOG_INFO(LOG_TAG, "%s: state=%s", __func__,
@@ -874,10 +963,25 @@ static uint32_t btif_a2dp_source_read_callback(uint8_t* p_buf, uint32_t len) {
   uint16_t event;
   uint32_t bytes_read = 0;
 
-  if (bluetooth::audio::a2dp::is_hal_2_0_enabled()) {
-    bytes_read = bluetooth::audio::a2dp::read(p_buf, len);
-  } else if (a2dp_uipc != nullptr) {
-    bytes_read = UIPC_Read(*a2dp_uipc, UIPC_CH_ID_AV_AUDIO, &event, p_buf, len);
+  uint32_t bytes_offset = 0;
+  uint32_t len_read = len;
+  uint32_t timeout_cnt = 0;
+
+  // Savitech Patch - LHDC low latency mode
+  while (true) {
+      if (bluetooth::audio::a2dp::is_hal_2_0_enabled()) {
+        bytes_read = bluetooth::audio::a2dp::read(p_buf + bytes_offset, len_read);
+      } else if (a2dp_uipc != nullptr) {
+        bytes_read = UIPC_Read(*a2dp_uipc, UIPC_CH_ID_AV_AUDIO, &event, p_buf + bytes_offset, len_read);
+      }
+      bytes_offset += bytes_read;
+      len_read -= bytes_read;
+      timeout_cnt++;
+      if (len_read <= 0 || timeout_cnt >= 5) {
+          bytes_read = bytes_offset;
+          break;
+      }
+      usleep(1000);
   }
 
   if (bytes_read < len) {
diff --git a/system/bt/btif/src/btif_av.cc b/system/bt/btif/src/btif_av.cc
index 24e32ec1..d0498e2f 100755
--- a/system/bt/btif/src/btif_av.cc
+++ b/system/bt/btif/src/btif_av.cc
@@ -17,6 +17,7 @@
  ******************************************************************************/
 
 #define LOG_TAG "btif_av"
+#define SAVITECH_A2DP_SINK  // Savitech Patch - A2DP_Sink_Enable
 
 #include "btif_av.h"
 
@@ -493,24 +494,28 @@ class BtifAvSource {
       const RawAddress& peer_address,
       const std::vector<btav_a2dp_codec_config_t>& codec_preferences,
       std::promise<void> peer_ready_promise) {
-    // Restart the session if the codec for the active peer is updated
-    bool restart_session =
-        ((active_peer_ == peer_address) && !active_peer_.IsEmpty());
-    if (restart_session) {
-      btif_a2dp_source_end_session(active_peer_);
-    }
 
-    for (auto cp : codec_preferences) {
-      BTIF_TRACE_DEBUG("%s: codec_preference=%s", __func__,
-                       cp.ToString().c_str());
-      btif_a2dp_source_encoder_user_config_update_req(peer_address, cp);
-    }
-    if (restart_session) {
-      btif_a2dp_source_start_session(active_peer_,
-                                     std::move(peer_ready_promise));
-    } else {
-      peer_ready_promise.set_value();
-    }
+    for (auto cp : codec_preferences)
+    {
+        // Restart the session if the codec for the active peer is updated
+        bool restart_session =
+            ((active_peer_ == peer_address) && !active_peer_.IsEmpty());
+
+        if (restart_session) {
+          btif_a2dp_source_end_session(active_peer_);
+        }
+
+        BTIF_TRACE_WARNING("%s: codec_preference=%s", __func__,
+            cp.ToString().c_str());
+        btif_a2dp_source_encoder_user_config_update_req(peer_address, cp);
+
+        if (restart_session) {
+          btif_a2dp_source_start_session(active_peer_, std::move(peer_ready_promise));
+        }
+        else {
+          peer_ready_promise.set_value();
+        }
+    }   /* end for */
   }
 
   const std::map<RawAddress, BtifAvPeer*>& Peers() const { return peers_; }
@@ -690,6 +695,62 @@ static void btif_av_sink_initiate_av_open_timer_timeout(void* data);
 static void bta_av_sink_media_callback(tBTA_AV_EVT event,
                                        tBTA_AV_MEDIA* p_data);
 
+static BtifAvPeer* btif_av_source_find_peer(const RawAddress& peer_address);
+static BtifAvPeer* btif_av_sink_find_peer(const RawAddress& peer_address);
+
+static BtifAvPeer* btif_av_find_active_peer() {
+#ifdef SAVITECH_A2DP_SINK
+  BtifAvPeer* activePeerIsSink = NULL;
+  BtifAvPeer* activePeerIsSrc = NULL;
+
+  if (btif_av_source.Enabled()) {
+    BTIF_TRACE_VERBOSE("%s: SRC Find -> ActivePeer:%s (%p)",
+    		__func__,
+			btif_av_source.ActivePeer().ToString().c_str(),
+			btif_av_source_find_peer(btif_av_source.ActivePeer()));
+    activePeerIsSink = btif_av_source_find_peer(btif_av_source.ActivePeer());
+  }
+  if (btif_av_sink.Enabled()) {
+	BTIF_TRACE_VERBOSE("%s: Sink Find -> ActivePeer:%s (%p)",
+    		__func__,
+			btif_av_sink.ActivePeer().ToString().c_str(),
+			btif_av_sink_find_peer(btif_av_sink.ActivePeer()));
+    activePeerIsSrc = btif_av_sink_find_peer(btif_av_sink.ActivePeer());
+  }
+
+  if( activePeerIsSrc != NULL && activePeerIsSink != NULL) {
+	//should not happened here
+	BTIF_TRACE_WARNING("%s: WARNING! Have both Src/Sink ActivePeers! (use default: SRC)", __func__);
+	return activePeerIsSrc;
+  }
+  if( activePeerIsSink != NULL) {
+	//AVDT_TSEP_SNK(1)
+	BTIF_TRACE_VERBOSE("%s: activePeerIsSink:%s Sep:%d", __func__,
+			  activePeerIsSink->PeerAddress().ToString().c_str(), activePeerIsSink->PeerSep());
+	return activePeerIsSink;
+  }
+  if( activePeerIsSrc != NULL) {
+	//AVDT_TSEP_SRC(0)
+	BTIF_TRACE_VERBOSE("%s: activePeerIsSrc:%s Sep:%d", __func__,
+			  activePeerIsSrc->PeerAddress().ToString().c_str(), activePeerIsSrc->PeerSep());
+	return activePeerIsSrc;
+  }
+  BTIF_TRACE_VERBOSE("%s: no any active peer found, RET nullptr", __func__);
+  return nullptr;
+#else
+  if (btif_av_source.Enabled())
+  {
+    return btif_av_source_find_peer(btif_av_source.ActivePeer());
+  }
+
+  if (btif_av_sink.Enabled())
+  {
+    return btif_av_sink_find_peer(btif_av_sink.ActivePeer());
+  }
+
+  return nullptr;
+#endif
+}
 static BtifAvPeer* btif_av_source_find_peer(const RawAddress& peer_address) {
   return btif_av_source.FindPeer(peer_address);
 }
@@ -697,16 +758,23 @@ static BtifAvPeer* btif_av_sink_find_peer(const RawAddress& peer_address) {
   return btif_av_sink.FindPeer(peer_address);
 }
 static BtifAvPeer* btif_av_find_peer(const RawAddress& peer_address) {
+#ifdef SAVITECH_A2DP_SINK
+  BtifAvPeer* avPeer = NULL;
+  avPeer = btif_av_find_active_peer();
+  if(avPeer) {
+	if(avPeer->PeerSep()==AVDT_TSEP_SRC) {
+	  return btif_av_sink_find_peer(peer_address);
+	}
+	if(avPeer->PeerSep()==AVDT_TSEP_SNK) {
+	  return btif_av_source_find_peer(peer_address);
+	}
+  }
+  return nullptr;
+#else
   if (btif_av_source.Enabled()) return btif_av_source_find_peer(peer_address);
   if (btif_av_sink.Enabled()) return btif_av_sink_find_peer(peer_address);
   return nullptr;
-}
-static BtifAvPeer* btif_av_find_active_peer() {
-  if (btif_av_source.Enabled())
-    return btif_av_source_find_peer(btif_av_source.ActivePeer());
-  if (btif_av_sink.Enabled())
-    return btif_av_sink_find_peer(btif_av_sink.ActivePeer());
-  return nullptr;
+#endif
 }
 
 /*****************************************************************************
@@ -1443,6 +1511,34 @@ bool BtifAvStateMachine::StateIdle::ProcessEvent(uint32_t event, void* p_data) {
 
       bool can_connect = true;
       // Check whether connection is allowed
+#ifdef SAVITECH_A2DP_SINK
+      if (peer_.IsSink()) {
+        can_connect = btif_av_source.AllowedToConnect(peer_.PeerAddress());
+        if (!can_connect) {
+          src_disconnect_sink(peer_.PeerAddress());
+        } else {
+          alarm_set_on_mloop(
+                peer_.AvOpenOnRcTimer(), BtifAvPeer::kTimeoutAvOpenOnRcMs,
+                btif_av_source_initiate_av_open_timer_timeout, &peer_);
+        }
+      } else if (peer_.IsSource()) {
+        can_connect = btif_av_sink.AllowedToConnect(peer_.PeerAddress());
+        if (!can_connect) {
+          sink_disconnect_src(peer_.PeerAddress());
+        } else {
+          alarm_set_on_mloop(peer_.AvOpenOnRcTimer(),
+                               BtifAvPeer::kTimeoutAvOpenOnRcMs,
+                               btif_av_sink_initiate_av_open_timer_timeout, &peer_);
+        }
+      }
+      if (!can_connect) {
+        BTIF_TRACE_ERROR(
+            "%s: Cannot connect to peer %s: too many connected "
+            "peers",
+            __PRETTY_FUNCTION__, peer_.PeerAddress().ToString().c_str());
+        break;
+      }
+#else
       if (peer_.IsSink()) {
         can_connect = btif_av_source.AllowedToConnect(peer_.PeerAddress());
         if (!can_connect) src_disconnect_sink(peer_.PeerAddress());
@@ -1466,6 +1562,7 @@ bool BtifAvStateMachine::StateIdle::ProcessEvent(uint32_t event, void* p_data) {
                            BtifAvPeer::kTimeoutAvOpenOnRcMs,
                            btif_av_sink_initiate_av_open_timer_timeout, &peer_);
       }
+#endif
       if (event == BTA_AV_RC_OPEN_EVT) {
         btif_rc_handler(event, (tBTA_AV*)p_data);
       }
@@ -2292,6 +2389,37 @@ static void btif_report_connection_state(const RawAddress& peer_address,
   LOG_INFO(LOG_TAG, "%s: peer_address=%s state=%d", __func__,
            peer_address.ToString().c_str(), state);
 
+#ifdef SAVITECH_A2DP_SINK
+	BtifAvPeer* activePeer = NULL;
+	activePeer = btif_av_find_active_peer();
+	if(activePeer)
+	{
+		if(activePeer->PeerSep()==AVDT_TSEP_SRC)
+		{
+			LOG_INFO(LOG_TAG, "%s: ImSink -> connection_state_cb..", __func__);
+			do_in_jni_thread(FROM_HERE,
+					base::Bind(btif_av_sink.Callbacks()->connection_state_cb, peer_address, state));
+		}
+		if(activePeer->PeerSep()==AVDT_TSEP_SNK)
+		{
+			LOG_INFO(LOG_TAG, "%s: ImSRC -> connection_state_cb..", __func__);
+			do_in_jni_thread(FROM_HERE,
+					base::Bind(btif_av_source.Callbacks()->connection_state_cb, peer_address, state));
+		}
+	}
+	else
+	{
+	    if (btif_av_source.Enabled()) {
+	    	LOG_INFO(LOG_TAG, "%s: no active peer, source->connection_state_cb..", __func__);
+	    	do_in_jni_thread(FROM_HERE,
+	    			base::Bind(btif_av_source.Callbacks()->connection_state_cb, peer_address, state));
+	    } else if (btif_av_sink.Enabled()) {
+	    	LOG_INFO(LOG_TAG, "%s: no active peer, sink->connection_state_cb..", __func__);
+	    	do_in_jni_thread(FROM_HERE,
+	    			base::Bind(btif_av_sink.Callbacks()->connection_state_cb, peer_address, state));
+	    }
+	}
+#else
   if (btif_av_source.Enabled()) {
     do_in_jni_thread(FROM_HERE,
                      base::Bind(btif_av_source.Callbacks()->connection_state_cb,
@@ -2301,6 +2429,7 @@ static void btif_report_connection_state(const RawAddress& peer_address,
                      base::Bind(btif_av_sink.Callbacks()->connection_state_cb,
                                 peer_address, state));
   }
+#endif
 }
 
 /**
@@ -2317,6 +2446,41 @@ static void btif_report_audio_state(const RawAddress& peer_address,
   LOG_INFO(LOG_TAG, "%s: peer_address=%s state=%d", __func__,
            peer_address.ToString().c_str(), state);
 
+#ifdef SAVITECH_A2DP_SINK
+	BtifAvPeer* avPeer = NULL;
+	avPeer = btif_av_find_active_peer();
+	if(avPeer)
+	{
+		if(avPeer->PeerSep()==AVDT_TSEP_SRC)
+		{
+			LOG_INFO(LOG_TAG, "%s: ImSink -> audio_state_cb..", __func__);
+		    do_in_jni_thread(FROM_HERE,
+		    		base::Bind(btif_av_sink.Callbacks()->audio_state_cb,
+		    				peer_address, state));
+		}
+		if(avPeer->PeerSep()==AVDT_TSEP_SNK)
+		{
+			LOG_INFO(LOG_TAG, "%s: ImSRC -> audio_state_cb..", __func__);
+		    do_in_jni_thread(FROM_HERE,
+		    		base::Bind(btif_av_source.Callbacks()->audio_state_cb,
+		    				peer_address, state));
+		}
+	}
+	else
+	{
+	    if (btif_av_source.Enabled()) {
+	    	LOG_INFO(LOG_TAG, "%s: no active peer, source->audio_state_cb..", __func__);
+	        do_in_jni_thread(FROM_HERE,
+	                         base::Bind(btif_av_source.Callbacks()->audio_state_cb,
+	                                    peer_address, state));
+	    } else if (btif_av_sink.Enabled()) {
+	    	LOG_INFO(LOG_TAG, "%s: no active peer, sink->audio_state_cb..", __func__);
+	        do_in_jni_thread(FROM_HERE,
+	                         base::Bind(btif_av_sink.Callbacks()->audio_state_cb,
+	                                    peer_address, state));
+	    }
+	}
+#else
   if (btif_av_source.Enabled()) {
     do_in_jni_thread(FROM_HERE,
                      base::Bind(btif_av_source.Callbacks()->audio_state_cb,
@@ -2326,6 +2490,7 @@ static void btif_report_audio_state(const RawAddress& peer_address,
                      base::Bind(btif_av_sink.Callbacks()->audio_state_cb,
                                 peer_address, state));
   }
+#endif
 }
 
 void btif_av_report_source_codec_state(
@@ -2819,6 +2984,88 @@ static bt_status_t codec_config_src(
   return status;
 }
 
+// Savitech Patch - LHDC Extended API Start
+static int lhdc_getApiVer_src(
+    const RawAddress& peer_address,
+    char* version, int clen) {
+
+  int status = BT_STATUS_NOT_READY;
+
+  if (!btif_av_source.Enabled()) {
+    LOG(WARNING) << __func__ << ": BTIF AV Source is not enabled";
+    return BT_STATUS_NOT_READY;
+  }
+
+  status = btif_a2dp_source_encoder_LHDC_user_ApiVer_retrieve_req(peer_address, version, clen);
+
+  if (status != BT_STATUS_SUCCESS) {
+    LOG(WARNING) << __func__ << ": BTIF AV Source fails to config LHDC codec";
+  }
+
+  return status;
+}
+
+static int lhdc_getApiCfg_src(
+    const RawAddress& peer_address,
+    char* config, int clen) {
+
+  int status = BT_STATUS_NOT_READY;
+
+  if (!btif_av_source.Enabled()) {
+    LOG(WARNING) << __func__ << ": BTIF AV Source is not enabled";
+    return BT_STATUS_NOT_READY;
+  }
+
+  status = btif_a2dp_source_encoder_LHDC_user_config_retrieve_req(peer_address, config, clen);
+
+  if (status != BT_STATUS_SUCCESS) {
+    LOG(WARNING) << __func__ << ": BTIF AV Source fails to config LHDC codec";
+  }
+
+  return status;
+}
+
+static int lhdc_setApiCfg_src(
+    const RawAddress& peer_address,
+    char* config, int clen) {
+
+  int status = BT_STATUS_NOT_READY;
+
+  if (!btif_av_source.Enabled()) {
+    LOG(WARNING) << __func__ << ": BTIF AV Source is not enabled";
+    return BT_STATUS_NOT_READY;
+  }
+
+  status = btif_a2dp_source_encoder_LHDC_user_config_update_req(peer_address, config, clen);
+
+  if (status != BT_STATUS_SUCCESS) {
+    LOG(WARNING) << __func__ << ": BTIF AV Source fails to config LHDC codec";
+  }
+
+  return status;
+}
+
+static void lhdc_setApiData_src(
+    const RawAddress& peer_address,
+    char* data, int clen) {
+
+  if (!btif_av_source.Enabled()) {
+    LOG(WARNING) << __func__ << ": BTIF AV Source is not enabled";
+    return;
+  }
+
+  btif_av_codec_lhdc_api_data_t codec_data;
+  memcpy(&codec_data.bd_addr, (uint8_t *)&peer_address, sizeof(RawAddress));
+  codec_data.clen = clen;
+  codec_data.pData = data;
+
+  btif_transfer_context(btif_a2dp_source_encoder_LHDC_user_data_update_req, 0,
+                          (char *)&codec_data, sizeof(codec_data), NULL);
+
+  return;
+}
+// Savitech Patch - LHDC Extended API End
+
 static void cleanup_src(void) {
   BTIF_TRACE_EVENT("%s", __func__);
   do_in_main_thread(FROM_HERE, base::Bind(&BtifAvSource::Cleanup,
@@ -2840,6 +3087,11 @@ static const btav_source_interface_t bt_av_src_interface = {
     src_set_active_sink,
     codec_config_src,
     cleanup_src,
+    // Savitech Patch
+    lhdc_getApiVer_src,
+    lhdc_getApiCfg_src,
+    lhdc_setApiCfg_src,
+    lhdc_setApiData_src,
 };
 
 static const btav_sink_interface_t bt_av_sink_interface = {
@@ -3126,11 +3378,26 @@ void btif_av_acl_disconnected(const RawAddress& peer_address) {
   LOG_INFO(LOG_TAG, "%s: Peer %s : ACL Disconnected", __func__,
            peer_address.ToString().c_str());
 
+#ifdef SAVITECH_A2DP_SINK
+  BtifAvPeer* avPeer = NULL;
+  avPeer = btif_av_find_active_peer();
+  if(avPeer) {
+	if(avPeer->PeerSep()==AVDT_TSEP_SRC) {
+	  LOG_INFO(LOG_TAG, "%s: peer SRC", __func__);
+      btif_av_sink_dispatch_sm_event(peer_address, BTIF_AV_ACL_DISCONNECTED);
+	}
+	if(avPeer->PeerSep()==AVDT_TSEP_SNK) {
+	  LOG_INFO(LOG_TAG, "%s: Peer Sink", __func__);
+	  btif_av_source_dispatch_sm_event(peer_address, BTIF_AV_ACL_DISCONNECTED);
+	}
+  }
+#else
   if (btif_av_source.Enabled()) {
     btif_av_source_dispatch_sm_event(peer_address, BTIF_AV_ACL_DISCONNECTED);
   } else if (btif_av_sink.Enabled()) {
     btif_av_sink_dispatch_sm_event(peer_address, BTIF_AV_ACL_DISCONNECTED);
   }
+#endif
 }
 
 static void btif_debug_av_peer_dump(int fd, const BtifAvPeer& peer) {
diff --git a/system/bt/include/hardware/bt_av.h b/system/bt/include/hardware/bt_av.h
index d38beaa6..dc398d4d 100755
--- a/system/bt/include/hardware/bt_av.h
+++ b/system/bt/include/hardware/bt_av.h
@@ -54,6 +54,12 @@ typedef enum {
   BTAV_A2DP_CODEC_INDEX_SOURCE_APTX,
   BTAV_A2DP_CODEC_INDEX_SOURCE_APTX_HD,
   BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC,
+  // Savitech Patch - START
+  BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3,
+  BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2,
+  BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1,
+  BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5,
+  // Savitech Patch - END
 
   BTAV_A2DP_CODEC_INDEX_SOURCE_MAX,
 
@@ -63,6 +69,10 @@ typedef enum {
   BTAV_A2DP_CODEC_INDEX_SINK_SBC = BTAV_A2DP_CODEC_INDEX_SINK_MIN,
   BTAV_A2DP_CODEC_INDEX_SINK_AAC,
   BTAV_A2DP_CODEC_INDEX_SINK_LDAC,
+  // Savitech Patch - START
+  BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3,
+  BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5,
+  // Savitech Patch - END
 
   BTAV_A2DP_CODEC_INDEX_SINK_MAX,
 
@@ -149,6 +159,19 @@ typedef struct {
       case BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC:
         codec_name_str = "LDAC";
         break;
+      // Savitech Patch
+      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+        codec_name_str = "LHDC V3";
+        break;
+      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+        codec_name_str = "LHDC V2";
+        break;
+      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1:
+        codec_name_str = "LHDC V1";
+        break;
+      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+        codec_name_str = "LHDC V5";
+        break;
       case BTAV_A2DP_CODEC_INDEX_SINK_SBC:
         codec_name_str = "SBC (Sink)";
         break;
@@ -158,6 +181,12 @@ typedef struct {
       case BTAV_A2DP_CODEC_INDEX_SINK_LDAC:
         codec_name_str = "LDAC (Sink)";
         break;
+      case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3:
+        codec_name_str = "LHDC V3 (Sink)";
+        break;
+      case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5:
+        codec_name_str = "LHDC V5 (Sink)";
+        break;
       case BTAV_A2DP_CODEC_INDEX_MAX:
         codec_name_str = "Unknown(CODEC_INDEX_MAX)";
         break;
@@ -237,6 +266,15 @@ typedef struct {
   }
 } btav_a2dp_codec_config_t;
 
+/** Savitech Patch - LHDC Extended API
+ *  Structure for LHDC Extended API data
+ */
+typedef struct {
+	RawAddress bd_addr;
+	int clen;
+	char* pData;
+} btif_av_codec_lhdc_api_data_t;
+
 /** Callback for connection state change.
  *  state will have one of the values from btav_connection_state_t
  */
@@ -327,6 +365,19 @@ typedef struct {
   /** Closes the interface. */
   void (*cleanup)(void);
 
+  // Savitech Patch - LHDC Extended API
+  int (*getApiVer_lhdc)(   /* mapping to lhdc_getApiVer_src */
+      const RawAddress& bd_addr, char* version, int clen);
+
+  int (*getApiCfg_lhdc)(   /* mapping to lhdc_getApiCfg_src */
+      const RawAddress& bd_addr, char* config, int clen);
+
+  int (*setApiCfg_lhdc)(   /* mapping to lhdc_setApiCfg_src */
+      const RawAddress& bd_addr, char* config, int clen);
+
+  void (*setAPiData_lhdc)( /* mapping to lhdc_setApiData_src */
+      const RawAddress& bd_addr, char* data, int clen);
+
 } btav_source_interface_t;
 
 /** Represents the standard BT-AV A2DP Sink interface.
diff --git a/system/bt/internal_include/bt_target.h b/system/bt/internal_include/bt_target.h
index 67a67c56..a9b34873 100755
--- a/system/bt/internal_include/bt_target.h
+++ b/system/bt/internal_include/bt_target.h
@@ -76,7 +76,8 @@
 #endif
 
 #ifndef BTA_AV_SINK_INCLUDED
-#define BTA_AV_SINK_INCLUDED FALSE
+//#define BTA_AV_SINK_INCLUDED FALSE
+#define BTA_AV_SINK_INCLUDED TRUE   // Savitech Patch - A2DP_Sink_Enable
 #endif
 
 #ifndef BTA_DISABLE_DELAY
@@ -999,7 +1000,7 @@
 
 /* Number of simultaneous stream endpoints. */
 #ifndef AVDT_NUM_SEPS
-#define AVDT_NUM_SEPS 6
+#define AVDT_NUM_SEPS 14		//Savitech Patch - see BTAV_A2DP_CODEC_INDEX_MAX
 #endif
 
 /* Number of transport channels setup by AVDT for all media streams */
diff --git a/system/bt/main/Android.bp b/system/bt/main/Android.bp
index f787e9e6..9a2b788b 100755
--- a/system/bt/main/Android.bp
+++ b/system/bt/main/Android.bp
@@ -94,6 +94,10 @@ cc_library_shared {
         "bt_stack.conf",
         "libldacBT_enc",
         "libldacBT_abr",
+        "liblhdcBT_enc",
+        "liblhdcBT_dec",
+        "liblhdcv5BT_enc",
+        "liblhdcv5BT_dec",
     ],
     cflags: [
         "-DBUILDCFG",
diff --git a/system/bt/stack/Android.bp b/system/bt/stack/Android.bp
index f7f5a453..5df7d095 100755
--- a/system/bt/stack/Android.bp
+++ b/system/bt/stack/Android.bp
@@ -34,6 +34,14 @@ cc_library_static {
         "external/aac/libSYS/include",
         "external/libldac/inc",
         "external/libldac/abr/inc",
+        "external/liblhdc/inc",
+        "external/liblhdc/include",
+        "external/liblhdcdec/inc",
+        "external/liblhdcdec/include",
+        "external/liblhdcv5/inc",
+        "external/liblhdcv5/include",
+        "external/liblhdcv5dec/inc",
+        "external/liblhdcv5dec/include",
         "system/bt",
         "system/bt/btcore/include",
         "system/bt/vnd/include",
@@ -66,6 +74,17 @@ cc_library_static {
         "a2dp/a2dp_vendor_ldac_abr.cc",
         "a2dp/a2dp_vendor_ldac_decoder.cc",
         "a2dp/a2dp_vendor_ldac_encoder.cc",
+        "a2dp/a2dp_vendor_lhdcv1.cc",
+        "a2dp/a2dp_vendor_lhdcv1_encoder.cc",
+        "a2dp/a2dp_vendor_lhdcv2.cc",
+        "a2dp/a2dp_vendor_lhdcv2_encoder.cc",
+        "a2dp/a2dp_vendor_lhdcv3.cc",
+        "a2dp/a2dp_vendor_lhdcv3_encoder.cc",
+        "a2dp/a2dp_vendor_lhdcv3_dec.cc",
+        "a2dp/a2dp_vendor_lhdcv3_decoder.cc",
+        "a2dp/a2dp_vendor_lhdcv5.cc",
+        "a2dp/a2dp_vendor_lhdcv5_encoder.cc",
+        "a2dp/a2dp_vendor_lhdcv5_decoder.cc",
         "avct/avct_api.cc",
         "avct/avct_bcb_act.cc",
         "avct/avct_ccb.cc",
@@ -182,6 +201,10 @@ cc_library_static {
     required: [
         "libldacBT_enc",
         "libldacBT_abr",
+        "liblhdcBT_enc",
+        "liblhdcBT_dec",
+        "liblhdcv5BT_enc",
+        "liblhdcv5BT_dec",
     ],
 }
 
diff --git a/system/bt/stack/a2dp/a2dp_codec_config.cc b/system/bt/stack/a2dp/a2dp_codec_config.cc
index edf7e0c4..dfffa14e 100755
--- a/system/bt/stack/a2dp/a2dp_codec_config.cc
+++ b/system/bt/stack/a2dp/a2dp_codec_config.cc
@@ -31,6 +31,11 @@
 #include "a2dp_vendor_aptx.h"
 #include "a2dp_vendor_aptx_hd.h"
 #include "a2dp_vendor_ldac.h"
+#include "a2dp_vendor_lhdcv1.h"
+#include "a2dp_vendor_lhdcv2.h"
+#include "a2dp_vendor_lhdcv3.h"
+#include "a2dp_vendor_lhdcv3_dec.h"
+#include "a2dp_vendor_lhdcv5.h"
 #include "bta/av/bta_av_int.h"
 #include "osi/include/log.h"
 #include "osi/include/properties.h"
@@ -134,6 +139,25 @@ A2dpCodecConfig* A2dpCodecConfig::createCodec(
     case BTAV_A2DP_CODEC_INDEX_SINK_LDAC:
       codec_config = new A2dpCodecConfigLdacSink(codec_priority);
       break;
+    // Savitech Patch
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+      codec_config = new A2dpCodecConfigLhdcV3(codec_priority);
+      break;
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+      codec_config = new A2dpCodecConfigLhdcV2(codec_priority);
+      break;
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1:
+      codec_config = new A2dpCodecConfigLhdcV1(codec_priority);
+      break;
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+      codec_config = new A2dpCodecConfigLhdcV5Source(codec_priority);
+      break;
+    case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3:
+      codec_config = new A2dpCodecConfigLhdcV3Sink(codec_priority);
+      break;
+    case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5:
+      codec_config = new A2dpCodecConfigLhdcV5Sink(codec_priority);
+      break;
     case BTAV_A2DP_CODEC_INDEX_MAX:
       break;
   }
@@ -364,8 +388,9 @@ bool A2dpCodecConfig::setCodecUserConfig(
   //
   btav_a2dp_codec_config_t new_codec_config = getCodecConfig();
   if ((saved_codec_config.sample_rate != new_codec_config.sample_rate) ||
-      (saved_codec_config.bits_per_sample !=
-       new_codec_config.bits_per_sample) ||
+      (saved_codec_config.bits_per_sample != new_codec_config.bits_per_sample) ||
+      (saved_codec_config.codec_specific_3 != new_codec_config.codec_specific_3) || // Savitech Patch
+      (saved_codec_config.codec_specific_1 != new_codec_config.codec_specific_1) ||
       (saved_codec_config.channel_mode != new_codec_config.channel_mode)) {
     *p_restart_input = true;
   }
@@ -588,7 +613,19 @@ bool A2dpCodecs::init() {
       } else if (strcmp(tok, "ldac") == 0) {
         LOG_INFO(LOG_TAG, "%s: LDAC offload supported", __func__);
         offload_codec_support[BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC] = true;
-      }
+      } else if (strcmp(tok, "lhdcv3") == 0) {  // Savitech Patch
+          LOG_INFO(LOG_TAG, "%s: LHDCV3 offload supported", __func__);
+          offload_codec_support[BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3] = false;
+      } else if (strcmp(tok, "lhdcv2") == 0) {
+          LOG_INFO(LOG_TAG, "%s: LHDCV2 offload supported", __func__);
+          offload_codec_support[BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2] = false;
+      } else if (strcmp(tok, "lhdcv1") == 0) {
+          LOG_INFO(LOG_TAG, "%s: LHDCV1 offload supported", __func__);
+          offload_codec_support[BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1] = false;
+      } else if (strcmp(tok, "lhdcv5") == 0) {
+        LOG_INFO(LOG_TAG, "%s: LHDCV5 offload supported", __func__);
+        offload_codec_support[BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5] = false;
+    }
       tok = strtok_r(NULL, "-", &tmp_token);
     };
   }
@@ -717,6 +754,368 @@ bool A2dpCodecs::setSinkCodecConfig(const uint8_t* p_peer_codec_info,
   return true;
 }
 
+/***********************************************
+ * Savitech Patch - LHDC Extended API Start
+ ***********************************************/
+static bool swapInt64toByteArray(unsigned char *byteArray, int64_t integer64)
+{
+	bool ret = false;
+	if (!byteArray) {
+	  APPL_TRACE_ERROR("%s: null ptr", __func__);
+	  return ret;
+	}
+	
+	byteArray[7] = ((integer64 & 0x00000000000000FF) >> 0);
+	byteArray[6] = ((integer64 & 0x000000000000FF00) >> 8);
+	byteArray[5] = ((integer64 & 0x0000000000FF0000) >> 16);
+	byteArray[4] = ((integer64 & 0x00000000FF000000) >> 24);
+	byteArray[3] = ((integer64 & 0x000000FF00000000) >> 32);
+	byteArray[2] = ((integer64 & 0x0000FF0000000000) >> 40);
+	byteArray[1] = ((integer64 & 0x00FF000000000000) >> 48);
+	byteArray[0] = ((integer64 & 0xFF00000000000000) >> 56);
+
+	ret = true;
+	return ret;
+}
+
+static bool getLHDCA2DPSpecficV2(btav_a2dp_codec_config_t *a2dpCfg, unsigned char *pucConfig, const int clen)
+{
+  if (clen < (int)LHDC_EXTEND_FUNC_CONFIG_TOTAL_FIXED_SIZE_V2 ) {
+    APPL_TRACE_ERROR("%s: payload size too small! clen=%d ",__func__, clen);
+    return false;
+  }
+
+  /* copy specifics into buffer */
+  if ( !(
+      swapInt64toByteArray(&pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V2], a2dpCfg->codec_specific_1) &&
+      swapInt64toByteArray(&pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V2], a2dpCfg->codec_specific_2) &&
+      swapInt64toByteArray(&pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V2], a2dpCfg->codec_specific_3) &&
+      swapInt64toByteArray(&pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V2], a2dpCfg->codec_specific_4)
+      )) {
+    APPL_TRACE_ERROR("%s: fail to copy specifics to buffer!",  __func__);
+    return false;
+  }
+
+  /* fill capability metadata fields */
+  APPL_TRACE_WARNING("%s: total %d metadata of capabilities",  __func__, (LHDC_EXTEND_FUNC_CONFIG_CAPMETA_SIZE_V2>>1) );
+
+  if( A2DP_VendorGetSrcCapVectorLhdcv3(&pucConfig[LHDC_EXTEND_FUNC_A2DP_CAPMETA_HEAD_V2]) ) {
+    APPL_TRACE_WARNING("%s: Get metadata of capabilities success!", __func__);
+  } else {
+    APPL_TRACE_ERROR("%s: fail to get capability fields!",  __func__);
+    return false;
+  }
+
+#if 0   //debug print
+  APPL_TRACE_WARNING("%s:(spec):: SP1[%02X %02X %02X %02X %02X %02X %02X %02X]; SP2[%02X %02X %02X %02X %02X %02X %02X %02X]",
+      __func__,
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V2], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V2+1],
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V2+2], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V2+3],
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V2+4], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V2+5],
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V2+6], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V2+7],
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V2], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V2+1],
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V2+2], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V2+3],
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V2+4], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V2+5],
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V2+6], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V2+7]);
+
+  APPL_TRACE_WARNING("%s:(spec):: SP3[%02X %02X %02X %02X %02X %02X %02X %02X]; SP4[%02X %02X %02X %02X %02X %02X %02X %02X]",
+      __func__,
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V2], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V2+1],
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V2+2], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V2+3],
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V2+4], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V2+5],
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V2+6], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V2+7],
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V2], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V2+1],
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V2+2], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V2+3],
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V2+4], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V2+5],
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V2+6], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V2+7]);
+
+  for(int i=0, j=0; i<(LHDC_EXTEND_FUNC_CONFIG_CAPMETA_SIZE_V2>>1); i++)
+  {
+    APPL_TRACE_WARNING("%s:(capMeta):: Cap%d[0x%02X 0x%02X]", __func__,
+        i,
+        pucConfig[LHDC_EXTEND_FUNC_A2DP_CAPMETA_HEAD_V2 + j],
+        pucConfig[LHDC_EXTEND_FUNC_A2DP_CAPMETA_HEAD_V2 + (j+1)]);
+    j+=2;
+  }
+#endif
+
+  return true;
+}
+
+static bool getLHDCA2DPSpecficV1(btav_a2dp_codec_config_t *a2dpCfg, unsigned char *pucConfig, const int clen)
+{
+  if (clen < (int)LHDC_EXTEND_FUNC_CONFIG_TOTAL_FIXED_SIZE_V1 )
+  {
+    APPL_TRACE_ERROR("%s: payload size too small! clen=%d ",__func__, clen);
+    return false;
+  }
+
+  /* copy specifics into buffer */
+  if( !(
+      swapInt64toByteArray(&pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V1], a2dpCfg->codec_specific_1) &&
+      swapInt64toByteArray(&pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V1], a2dpCfg->codec_specific_2) &&
+      swapInt64toByteArray(&pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V1], a2dpCfg->codec_specific_3) &&
+      swapInt64toByteArray(&pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V1], a2dpCfg->codec_specific_4)
+      ))
+  {
+    APPL_TRACE_ERROR("%s: fail to copy specifics to buffer!",  __func__);
+    return false;
+  }
+
+#if 0   //debug print
+  APPL_TRACE_WARNING("%s:(spec):: SP1[%02X %02X %02X %02X %02X %02X %02X %02X]; SP2[%02X %02X %02X %02X %02X %02X %02X %02X]",
+      __func__,
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V1], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V1+1],
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V1+2], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V1+3],
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V1+4], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V1+5],
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V1+6], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V1+7],
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V1], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V1+1],
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V1+2], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V1+3],
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V1+4], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V1+5],
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V1+6], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V1+7]);
+
+  APPL_TRACE_WARNING("%s:(spec):: SP3[%02X %02X %02X %02X %02X %02X %02X %02X]; SP4[%02X %02X %02X %02X %02X %02X %02X %02X]",
+      __func__,
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V1], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V1+1],
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V1+2], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V1+3],
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V1+4], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V1+5],
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V1+6], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V1+7],
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V1], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V1+1],
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V1+2], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V1+3],
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V1+4], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V1+5],
+      pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V1+6], pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V1+7]);
+#endif
+
+  return true;
+}
+
+int A2dpCodecs::getLHDCCodecUserConfig(
+    A2dpCodecConfig* peerCodec,
+    const char* codecConfig, const int clen) {
+
+  int result = BT_STATUS_FAIL;
+
+  if (peerCodec == nullptr || codecConfig == nullptr) {
+    APPL_TRACE_ERROR("A2dpCodecs::%s: null input(peerCodec:%p codecConfig:%p)", __func__, peerCodec, codecConfig);
+    return BT_STATUS_FAIL;
+  }
+  btav_a2dp_codec_index_t peerCodecIndex = peerCodec->codecIndex();
+  APPL_TRACE_WARNING("A2dpCodecs::%s: CodecIndex=%d, clen=%d", __func__, peerCodecIndex , clen);
+
+  switch(peerCodecIndex)
+  {
+  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+    result = peerCodec->getLhdcExtendAPIConfig(peerCodec, codecConfig, clen);
+    break;
+
+  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+    if( codecConfig[LHDC_EXTEND_FUNC_CONFIG_API_CODE_HEAD] == LHDC_EXTEND_FUNC_CODE_A2DP_TYPE_MASK ){
+        /* **************************************
+         * LHDC A2DP related APIs:
+         * **************************************/
+        unsigned char *pucConfig = (unsigned char *) codecConfig;
+        unsigned int exFuncVer = 0;
+        unsigned int exFuncCode = 0;
+
+        if (pucConfig == NULL)
+        {
+            APPL_TRACE_ERROR("%s: User Config error!(%p)",  __func__, codecConfig);
+            goto Fail;
+        }
+
+        /* check required buffer size for generic header */
+        if (clen < (int)(LHDC_EXTEND_FUNC_CONFIG_API_VERSION_SIZE + LHDC_EXTEND_FUNC_CONFIG_API_CODE_SIZE))
+        {
+             // Buffer is too small for generic header size
+            APPL_TRACE_ERROR("%s: buffer is too small for command clen=%d",  __func__, clen);
+            goto Fail;
+        }
+
+        if(current_codec_config_ == NULL)
+        {
+            APPL_TRACE_ERROR("%s: Can not get current a2dp codec config!",  __func__);
+            goto Fail;
+        }
+
+        A2dpCodecConfig *a2dp_codec_config = current_codec_config_;
+        btav_a2dp_codec_config_t codec_config_tmp;
+
+        exFuncVer = (((unsigned int) pucConfig[3]) & ((unsigned int)0xff)) |
+                   ((((unsigned int) pucConfig[2]) & ((unsigned int)0xff)) << 8)  |
+                   ((((unsigned int) pucConfig[1]) & ((unsigned int)0xff)) << 16) |
+                   ((((unsigned int) pucConfig[0]) & ((unsigned int)0xff)) << 24);
+        exFuncCode = (((unsigned int) pucConfig[7]) & ((unsigned int)0xff)) |
+                    ((((unsigned int) pucConfig[6]) & ((unsigned int)0xff)) << 8)  |
+                    ((((unsigned int) pucConfig[5]) & ((unsigned int)0xff)) << 16) |
+                    ((((unsigned int) pucConfig[4]) & ((unsigned int)0xff)) << 24);
+
+        switch (exFuncCode)
+        {
+          case EXTEND_FUNC_CODE_GET_SPECIFIC:
+            /* **************************************
+             * API::Get A2DP Specifics
+             * **************************************/
+            APPL_TRACE_WARNING("%s: target cfg = 0x%02X",__func__, pucConfig[LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD]);
+            switch(pucConfig[LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD])
+            {
+              case LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_FINAL_CFG:
+                codec_config_tmp = a2dp_codec_config->getCodecConfig();
+                break;
+              case LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_FINAL_CAP:
+                codec_config_tmp = a2dp_codec_config->getCodecCapability();
+                break;
+              case LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_LOCAL_CAP:
+                codec_config_tmp = a2dp_codec_config->getCodecLocalCapability();
+                break;
+              case LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_SELECTABLE_CAP:
+                codec_config_tmp = a2dp_codec_config->getCodecSelectableCapability();
+                break;
+              case LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_USER_CFG:
+                codec_config_tmp = a2dp_codec_config->getCodecUserConfig();
+                break;
+              case LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_AUDIO_CFG:
+                codec_config_tmp = a2dp_codec_config->getCodecAudioConfig();
+                break;
+              default:
+                APPL_TRACE_ERROR("%s: target a2dp config not found!",  __func__);
+                goto Fail;
+            }
+            APPL_TRACE_WARNING("%s: Cfg(int64):: SP1=%lld(0x%016llX); SP2=%lld(0x%016llX); SP3=%lld(0x%016llX); SP4=%lld(0x%016llX)",__func__,
+                  codec_config_tmp.codec_specific_1,codec_config_tmp.codec_specific_1,
+                  codec_config_tmp.codec_specific_2, codec_config_tmp.codec_specific_2,
+                  codec_config_tmp.codec_specific_3, codec_config_tmp.codec_specific_3,
+                  codec_config_tmp.codec_specific_4, codec_config_tmp.codec_specific_4);
+
+            switch (exFuncVer)
+            {
+              case EXTEND_FUNC_VER_GET_SPECIFIC_V1:
+                if( !getLHDCA2DPSpecficV1(&codec_config_tmp, pucConfig, clen) )
+                  goto Fail;
+                break;
+              case EXTEND_FUNC_VER_GET_SPECIFIC_V2:
+                if( !getLHDCA2DPSpecficV2(&codec_config_tmp, pucConfig, clen) )
+                  goto Fail;
+                break;
+              default:
+                APPL_TRACE_WARNING("%s: Invalid Ex. Function Version!(0x%X)",  __func__, exFuncVer);
+                goto Fail;
+            }
+            result = BT_STATUS_SUCCESS;
+            break;
+
+        default:
+          APPL_TRACE_WARNING("%s: Invalid Ex. Function Code!(0x%X)",  __func__, exFuncCode);
+          goto Fail;
+        } // switch (exFuncCode)
+    }
+    else if( codecConfig[LHDC_EXTEND_FUNC_CONFIG_API_CODE_HEAD] == LHDC_EXTEND_FUNC_CODE_LIB_TYPE_MASK ){
+    	result = A2dpCodecConfigLhdcV3::getEncoderExtendFuncUserConfig(codecConfig, clen);
+    }
+    break;
+  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1:
+  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+  default:
+    APPL_TRACE_WARNING("%s: feature not support!", __func__);
+    goto Fail;
+  }
+
+Fail:
+  return result;
+}
+
+int A2dpCodecs::setLHDCCodecUserConfig(
+    A2dpCodecConfig* peerCodec,
+    const char* codecConfig, const int clen) {
+
+  int result = BT_STATUS_FAIL;
+
+  if (peerCodec == nullptr || codecConfig == nullptr) {
+    APPL_TRACE_ERROR("A2dpCodecs::%s: null input(peerCodec:%p version:%p)", __func__, peerCodec, codecConfig);
+    return BT_STATUS_FAIL;
+  }
+  btav_a2dp_codec_index_t peerCodecIndex = peerCodec->codecIndex();
+  APPL_TRACE_WARNING("A2dpCodecs::%s: CodecIndex=%d, clen=%d", __func__, peerCodecIndex , clen);
+
+  switch(peerCodecIndex)
+  {
+  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+    result = peerCodec->setLhdcExtendAPIConfig(peerCodec, codecConfig, clen);
+    break;
+  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+    result = A2dpCodecConfigLhdcV3::setEncoderExtendFuncUserConfig(codecConfig, clen);
+    break;
+  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1:
+  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+  default:
+    APPL_TRACE_WARNING("%s: peer codecIndex(%d) not support the feature!", __func__, peerCodecIndex);
+    return result;
+  }
+
+  return result;
+}
+
+bool A2dpCodecs::setLHDCCodecUserData(
+    A2dpCodecConfig* peerCodec,
+    const char* codecData, const int clen) {
+
+  if (peerCodec == nullptr || codecData == nullptr) {
+    APPL_TRACE_ERROR("A2dpCodecs::%s: null input(peerCodec:%p version:%p)", __func__, peerCodec, codecData);
+    return false;
+  }
+  btav_a2dp_codec_index_t peerCodecIndex = peerCodec->codecIndex();
+  APPL_TRACE_API("A2dpCodecs::%s: CodecIndex=%d, clen=%d", __func__, peerCodecIndex , clen);
+
+  switch(peerCodecIndex)
+  {
+  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+    peerCodec->setLhdcExtendAPIData(peerCodec, codecData, clen);
+    break;
+  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+    A2dpCodecConfigLhdcV3::setEncoderExtendFuncUserData(codecData, clen);
+    break;
+  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1:
+  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+  default:
+    APPL_TRACE_WARNING("%s: peer codecIndex(%d) not support the feature!", __func__, peerCodecIndex);
+    return false;
+  }
+
+  return true;
+}
+
+int A2dpCodecs::getLHDCCodecUserApiVer(
+    A2dpCodecConfig* peerCodec,
+    const char* version, const int clen) {
+  int result = BT_STATUS_FAIL;
+
+  if (peerCodec == nullptr || version == nullptr) {
+    APPL_TRACE_ERROR("A2dpCodecs::%s: null input(peerCodec:%p version:%p)", __func__, peerCodec, version);
+    return BT_STATUS_FAIL;
+  }
+  btav_a2dp_codec_index_t peerCodecIndex = peerCodec->codecIndex();
+  APPL_TRACE_API("A2dpCodecs::%s: CodecIndex=%d, clen=%d", __func__, peerCodecIndex , clen);
+
+  switch(peerCodecIndex) {
+  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+    result = peerCodec->getLhdcExtendAPIVersion(peerCodec, version, clen);
+    break;
+  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+    result = A2dpCodecConfigLhdcV3::getEncoderExtendFuncUserApiVer(version, clen);
+    break;
+  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1:
+  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+  default:
+    APPL_TRACE_WARNING("%s: peer codecIndex(%d) not support the feature!", __func__, peerCodecIndex);
+    return result;
+  }
+
+  return result;
+}
+/***********************************************
+ * Savitech Patch - LHDC Extended API End
+ ***********************************************/
+
+
 bool A2dpCodecs::setCodecUserConfig(
     const btav_a2dp_codec_config_t& codec_user_config,
     const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
diff --git a/system/bt/stack/a2dp/a2dp_vendor.cc b/system/bt/stack/a2dp/a2dp_vendor.cc
index bcea13d1..101d663f 100755
--- a/system/bt/stack/a2dp/a2dp_vendor.cc
+++ b/system/bt/stack/a2dp/a2dp_vendor.cc
@@ -24,6 +24,11 @@
 #include "a2dp_vendor_aptx.h"
 #include "a2dp_vendor_aptx_hd.h"
 #include "a2dp_vendor_ldac.h"
+#include "a2dp_vendor_lhdcv3.h"
+#include "a2dp_vendor_lhdcv2.h"
+#include "a2dp_vendor_lhdcv1.h"
+#include "a2dp_vendor_lhdcv3_dec.h"
+#include "a2dp_vendor_lhdcv5.h"
 #include "bt_target.h"
 #include "osi/include/log.h"
 #include "osi/include/osi.h"
@@ -49,6 +54,26 @@ bool A2DP_IsVendorSourceCodecValid(const uint8_t* p_codec_info) {
     return A2DP_IsVendorSourceCodecValidLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_IsVendorSourceCodecValidLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV2
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_IsVendorSourceCodecValidLhdcV2(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV1
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
+    return A2DP_IsVendorSourceCodecValidLhdcV1(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_IsVendorSourceCodecValidLhdcV5(p_codec_info);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return false;
@@ -66,6 +91,17 @@ bool A2DP_IsVendorSinkCodecValid(const uint8_t* p_codec_info) {
     return A2DP_IsVendorSinkCodecValidLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_IsVendorSinkCodecValidLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_IsVendorSinkCodecValidLhdcV5(p_codec_info);
+  }
+
+
   return false;
 }
 
@@ -80,7 +116,16 @@ bool A2DP_IsVendorPeerSourceCodecValid(const uint8_t* p_codec_info) {
   if (vendor_id == A2DP_LDAC_VENDOR_ID && codec_id == A2DP_LDAC_CODEC_ID) {
     return A2DP_IsVendorPeerSourceCodecValidLdac(p_codec_info);
   }
+  
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_IsVendorPeerSourceCodecValidLhdcV3(p_codec_info);
+  }
 
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_IsVendorPeerSourceCodecValidLhdcV5(p_codec_info);
+  }
   return false;
 }
 
@@ -105,6 +150,26 @@ bool A2DP_IsVendorPeerSinkCodecValid(const uint8_t* p_codec_info) {
     return A2DP_IsVendorPeerSinkCodecValidLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_IsVendorPeerSinkCodecValidLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV2
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_IsVendorPeerSinkCodecValidLhdcV2(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV1
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
+    return A2DP_IsVendorPeerSinkCodecValidLhdcV1(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_IsVendorPeerSinkCodecValidLhdcV5(p_codec_info);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return false;
@@ -121,6 +186,14 @@ bool A2DP_IsVendorSinkCodecSupported(const uint8_t* p_codec_info) {
   if (vendor_id == A2DP_LDAC_VENDOR_ID && codec_id == A2DP_LDAC_CODEC_ID) {
     return A2DP_IsVendorSinkCodecSupportedLdac(p_codec_info);
   }
+  // Check for Savitech LHDCV3
+  else if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+	  return A2DP_IsVendorSinkCodecSupportedLhdcV3(p_codec_info);
+  }
+  // Check for Savitech LHDCV5
+  else if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+	  return A2DP_IsVendorSinkCodecSupportedLhdcV5(p_codec_info);
+  }
 
   return false;
 }
@@ -137,6 +210,16 @@ bool A2DP_IsVendorPeerSourceCodecSupported(const uint8_t* p_codec_info) {
     return A2DP_IsPeerSourceCodecSupportedLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_IsPeerSourceCodecSupportedLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_IsPeerSourceCodecSupportedLhdcV5(p_codec_info);
+  }
+
   return false;
 }
 
@@ -183,6 +266,30 @@ bool A2DP_VendorUsesRtpHeader(bool content_protection_enabled,
                                         p_codec_info);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorUsesRtpHeaderLhdcV3(content_protection_enabled,
+                                          p_codec_info);
+  }
+
+  // Check for Savitech LHDCV2
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_VendorUsesRtpHeaderLhdcV2(content_protection_enabled,
+                                          p_codec_info);
+  }
+
+  // Check for Savitech LHDCV1
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
+    return A2DP_VendorUsesRtpHeaderLhdcV1(content_protection_enabled,
+                                          p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorUsesRtpHeaderLhdcV5(content_protection_enabled,
+                                          p_codec_info);
+  }
+
   // Add checks based on <content_protection_enabled, vendor_id, codec_id>
 
   return true;
@@ -209,6 +316,26 @@ const char* A2DP_VendorCodecName(const uint8_t* p_codec_info) {
     return A2DP_VendorCodecNameLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorCodecNameLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV2
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_VendorCodecNameLhdcV2(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV1
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
+    return A2DP_VendorCodecNameLhdcV1(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorCodecNameLhdcV5(p_codec_info);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return "UNKNOWN VENDOR CODEC";
@@ -248,6 +375,26 @@ bool A2DP_VendorCodecTypeEquals(const uint8_t* p_codec_info_a,
     return A2DP_VendorCodecTypeEqualsLdac(p_codec_info_a, p_codec_info_b);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorCodecTypeEqualsLhdcV3(p_codec_info_a, p_codec_info_b);
+  }
+
+  // Check for Savitech LHDCV2
+  if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_VendorCodecTypeEqualsLhdcV2(p_codec_info_a, p_codec_info_b);
+  }
+
+  // Check for Savitech LHDCV1
+  if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV1_CODEC_ID) {
+    return A2DP_VendorCodecTypeEqualsLhdcV1(p_codec_info_a, p_codec_info_b);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorCodecTypeEqualsLhdcV5(p_codec_info_a, p_codec_info_b);
+  }
+
   // OPTIONAL: Add extra vendor-specific checks based on the
   // vendor-specific data stored in "p_codec_info_a" and "p_codec_info_b".
 
@@ -288,6 +435,26 @@ bool A2DP_VendorCodecEquals(const uint8_t* p_codec_info_a,
     return A2DP_VendorCodecEqualsLdac(p_codec_info_a, p_codec_info_b);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorCodecEqualsLhdcV3(p_codec_info_a, p_codec_info_b);
+  }
+
+  // Check for Savitech LHDCV2
+  if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_VendorCodecEqualsLhdcV2(p_codec_info_a, p_codec_info_b);
+  }
+
+  // Check for Savitech LHDCV1
+  if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV1_CODEC_ID) {
+    return A2DP_VendorCodecEqualsLhdcV1(p_codec_info_a, p_codec_info_b);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorCodecEqualsLhdcV5(p_codec_info_a, p_codec_info_b);
+  }
+
   // Add extra vendor-specific checks based on the
   // vendor-specific data stored in "p_codec_info_a" and "p_codec_info_b".
 
@@ -315,6 +482,16 @@ int A2DP_VendorGetBitRate(const uint8_t* p_codec_info) {
     return A2DP_VendorGetBitRateLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorGetBitRateLhdcV3(p_codec_info);
+  }
+  
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorGetBitRateLhdcV5(p_codec_info);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return -1;
@@ -341,6 +518,26 @@ int A2DP_VendorGetTrackSampleRate(const uint8_t* p_codec_info) {
     return A2DP_VendorGetTrackSampleRateLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorGetTrackSampleRateLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV2
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_VendorGetTrackSampleRateLhdcV2(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV1
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
+    return A2DP_VendorGetTrackSampleRateLhdcV1(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorGetTrackSampleRateLhdcV5(p_codec_info);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return -1;
@@ -367,6 +564,26 @@ int A2DP_VendorGetTrackBitsPerSample(const uint8_t* p_codec_info) {
     return A2DP_VendorGetTrackBitsPerSampleLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorGetTrackBitsPerSampleLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV2
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_VendorGetTrackBitsPerSampleLhdcV2(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV1
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
+    return A2DP_VendorGetTrackBitsPerSampleLhdcV1(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorGetTrackBitsPerSampleLhdcV5(p_codec_info);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return -1;
@@ -393,6 +610,26 @@ int A2DP_VendorGetTrackChannelCount(const uint8_t* p_codec_info) {
     return A2DP_VendorGetTrackChannelCountLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorGetTrackChannelCountLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV2
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_VendorGetTrackChannelCountLhdcV2(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV1
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
+    return A2DP_VendorGetTrackChannelCountLhdcV1(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorGetTrackChannelCountLhdcV5(p_codec_info);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return -1;
@@ -410,6 +647,16 @@ int A2DP_VendorGetSinkTrackChannelType(const uint8_t* p_codec_info) {
     return A2DP_VendorGetSinkTrackChannelTypeLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDC V3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorGetSinkTrackChannelTypeLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDC V5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorGetSinkTrackChannelTypeLhdcV5(p_codec_info);
+  }
+
   return -1;
 }
 
@@ -437,6 +684,26 @@ bool A2DP_VendorGetPacketTimestamp(const uint8_t* p_codec_info,
     return A2DP_VendorGetPacketTimestampLdac(p_codec_info, p_data, p_timestamp);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorGetPacketTimestampLhdcV3(p_codec_info, p_data, p_timestamp);
+  }
+
+  // Check for Savitech LHDCV2
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_VendorGetPacketTimestampLhdcV2(p_codec_info, p_data, p_timestamp);
+  }
+
+  // Check for Savitech LHDCV1
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
+    return A2DP_VendorGetPacketTimestampLhdcV1(p_codec_info, p_data, p_timestamp);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorGetPacketTimestampLhdcV5(p_codec_info, p_data, p_timestamp);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return false;
@@ -467,6 +734,30 @@ bool A2DP_VendorBuildCodecHeader(const uint8_t* p_codec_info, BT_HDR* p_buf,
                                            frames_per_packet);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorBuildCodecHeaderLhdcV3(p_codec_info, p_buf,
+                                               frames_per_packet);
+  }
+
+  // Check for Savitech LHDCV2
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_VendorBuildCodecHeaderLhdcV2(p_codec_info, p_buf,
+                                               frames_per_packet);
+  }
+
+  // Check for Savitech LHDCV1
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
+    return A2DP_VendorBuildCodecHeaderLhdcV1(p_codec_info, p_buf,
+                                               frames_per_packet);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorBuildCodecHeaderLhdcV5(p_codec_info, p_buf,
+                                               frames_per_packet);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return false;
@@ -494,6 +785,26 @@ const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterface(
     return A2DP_VendorGetEncoderInterfaceLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorGetEncoderInterfaceLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV2
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_VendorGetEncoderInterfaceLhdcV2(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV1
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
+    return A2DP_VendorGetEncoderInterfaceLhdcV1(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorGetEncoderInterfaceLhdcV5(p_codec_info);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return NULL;
@@ -512,6 +823,16 @@ const tA2DP_DECODER_INTERFACE* A2DP_VendorGetDecoderInterface(
     return A2DP_VendorGetDecoderInterfaceLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorGetDecoderInterfaceLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorGetDecoderInterfaceLhdcV5(p_codec_info);
+  }
+  
   return NULL;
 }
 
@@ -536,6 +857,26 @@ bool A2DP_VendorAdjustCodec(uint8_t* p_codec_info) {
     return A2DP_VendorAdjustCodecLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorAdjustCodecLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV2
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_VendorAdjustCodecLhdcV2(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV1
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
+    return A2DP_VendorAdjustCodecLhdcV1(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorAdjustCodecLhdcV5(p_codec_info);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return false;
@@ -563,6 +904,26 @@ btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndex(
     return A2DP_VendorSourceCodecIndexLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorSourceCodecIndexLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV2
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_VendorSourceCodecIndexLhdcV2(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV1
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
+    return A2DP_VendorSourceCodecIndexLhdcV1(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorSourceCodecIndexLhdcV5(p_codec_info);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return BTAV_A2DP_CODEC_INDEX_MAX;
@@ -580,6 +941,16 @@ btav_a2dp_codec_index_t A2DP_VendorSinkCodecIndex(const uint8_t* p_codec_info) {
     return A2DP_VendorSinkCodecIndexLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDC V3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorSinkCodecIndexLhdcV3(p_codec_info);
+  }
+  
+  // Check for Savitech LHDC V5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorSinkCodecIndexLhdcV5(p_codec_info);
+  }
+
   return BTAV_A2DP_CODEC_INDEX_MAX;
 }
 
@@ -599,6 +970,21 @@ const char* A2DP_VendorCodecIndexStr(btav_a2dp_codec_index_t codec_index) {
       return A2DP_VendorCodecIndexStrLdac();
     case BTAV_A2DP_CODEC_INDEX_SINK_LDAC:
       return A2DP_VendorCodecIndexStrLdacSink();
+    // Savitech Patch - START
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+      return A2DP_VendorCodecIndexStrLhdcV3();
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+      return A2DP_VendorCodecIndexStrLhdcV2();
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1:
+      return A2DP_VendorCodecIndexStrLhdcV1();
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+      return A2DP_VendorCodecIndexStrLhdcV5();
+    case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3:
+      return A2DP_VendorCodecIndexStrLhdcV3Sink();
+    case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5:
+      return A2DP_VendorCodecIndexStrLhdcV5Sink();
+    // Savitech Patch - END
+
     // Add a switch statement for each vendor-specific codec
     case BTAV_A2DP_CODEC_INDEX_MAX:
       break;
@@ -624,6 +1010,21 @@ bool A2DP_VendorInitCodecConfig(btav_a2dp_codec_index_t codec_index,
       return A2DP_VendorInitCodecConfigLdac(p_cfg);
     case BTAV_A2DP_CODEC_INDEX_SINK_LDAC:
       return A2DP_VendorInitCodecConfigLdacSink(p_cfg);
+    // Savitech Patch - START
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+      return A2DP_VendorInitCodecConfigLhdcV3(p_cfg);
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+      return A2DP_VendorInitCodecConfigLhdcV2(p_cfg);
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1:
+      return A2DP_VendorInitCodecConfigLhdcV1(p_cfg);
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+      return A2DP_VendorInitCodecConfigLhdcV5(p_cfg);
+    case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3:
+      return A2DP_VendorInitCodecConfigLhdcV3Sink(p_cfg);
+    case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5:
+      return A2DP_VendorInitCodecConfigLhdcV5Sink(p_cfg);
+    // Savitech Patch - END
+
     // Add a switch statement for each vendor-specific codec
     case BTAV_A2DP_CODEC_INDEX_MAX:
       break;
@@ -653,6 +1054,26 @@ std::string A2DP_VendorCodecInfoString(const uint8_t* p_codec_info) {
     return A2DP_VendorCodecInfoStringLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorCodecInfoStringLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV2
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_VendorCodecInfoStringLhdcV2(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV1
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
+    return A2DP_VendorCodecInfoStringLhdcV1(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorCodecInfoStringLhdcV5(p_codec_info);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return "Unsupported codec vendor_id: " + loghex(vendor_id) +
diff --git a/system/bt/stack/a2dp/a2dp_vendor_lhdcv1.cc b/system/bt/stack/a2dp/a2dp_vendor_lhdcv1.cc
new file mode 100755
index 00000000..d18adfcf
--- /dev/null
+++ b/system/bt/stack/a2dp/a2dp_vendor_lhdcv1.cc
@@ -0,0 +1,1220 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/******************************************************************************
+ *
+ *  Utility functions to help build and parse the LHDC Codec Information
+ *  Element and Media Payload.
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "a2dp_vendor_lhdcv1"
+
+#include "bt_target.h"
+
+#include "a2dp_vendor_lhdcv1.h"
+
+#include <string.h>
+
+#include <base/logging.h>
+#include "a2dp_vendor.h"
+#include "a2dp_vendor_lhdcv1_encoder.h"
+#include "bt_utils.h"
+#include "osi/include/log.h"
+#include "osi/include/osi.h"
+
+// data type for the LHDC Codec Information Element */
+// NOTE: bits_per_sample is needed only for LHDC encoder initialization.
+typedef struct {
+  uint32_t vendorId;
+  uint16_t codecId;    /* Codec ID for LHDC */
+  uint8_t sampleRate;  /* Sampling Frequency */
+  uint8_t channelMode; /* STEREO/DUAL/MONO */
+  btav_a2dp_codec_bits_per_sample_t bits_per_sample;
+  bool isChannelSeparation;
+} tA2DP_LHDC_CIE;
+
+/* LHDC Source codec capabilities */
+static const tA2DP_LHDC_CIE a2dp_lhdcV1_caps = {
+    A2DP_LHDC_VENDOR_ID,  // vendorId
+    A2DP_LHDCV1_CODEC_ID,   // codecId
+    // sampleRate
+    //(A2DP_LHDCV1_SAMPLING_FREQ_48000),
+    (A2DP_LHDC_SAMPLING_FREQ_44100 | A2DP_LHDC_SAMPLING_FREQ_48000 | A2DP_LHDC_SAMPLING_FREQ_88200 | A2DP_LHDC_SAMPLING_FREQ_96000),
+    // channelMode
+    (A2DP_LHDC_CHANNEL_MODE_STEREO),
+    // bits_per_sample
+    (BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16 | BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24),
+    //Channel Separation
+    true
+};
+    //(BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)};
+
+/* Default LHDC codec configuration */
+static const tA2DP_LHDC_CIE a2dp_lhdcV1_default_config = {
+    A2DP_LHDC_VENDOR_ID,                // vendorId
+    A2DP_LHDCV1_CODEC_ID,                 // codecId
+    A2DP_LHDC_SAMPLING_FREQ_96000,      // sampleRate
+    A2DP_LHDC_CHANNEL_MODE_STEREO,      // channelMode
+    BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24,  // bits_per_sample
+    false
+};
+
+static const tA2DP_ENCODER_INTERFACE a2dp_encoder_interface_lhdcv1 = {
+    a2dp_vendor_lhdcV1_encoder_init,
+    a2dp_vendor_lhdcV1_encoder_cleanup,
+    a2dp_vendor_lhdcV1_feeding_reset,
+    a2dp_vendor_lhdcV1_feeding_flush,
+    a2dp_vendor_lhdcV1_get_encoder_interval_ms,
+    a2dp_vendor_lhdcV1_send_frames,
+    a2dp_vendor_lhdcV1_set_transmit_queue_length};
+
+UNUSED_ATTR static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV1(
+    const tA2DP_LHDC_CIE* p_cap, const uint8_t* p_codec_info,
+    bool is_peer_codec_info);
+
+// Builds the LHDC Media Codec Capabilities byte sequence beginning from the
+// LOSC octet. |media_type| is the media type |AVDT_MEDIA_TYPE_*|.
+// |p_ie| is a pointer to the LHDC Codec Information Element information.
+// The result is stored in |p_result|. Returns A2DP_SUCCESS on success,
+// otherwise the corresponding A2DP error status code.
+static tA2DP_STATUS A2DP_BuildInfoLhdcV1(uint8_t media_type,
+                                       const tA2DP_LHDC_CIE* p_ie,
+                                       uint8_t* p_result) {
+
+  const uint8_t* tmpInfo = p_result;
+  if (p_ie == NULL || p_result == NULL) {
+    return A2DP_INVALID_PARAMS;
+  }
+
+  *p_result++ = A2DP_LHDCV1_CODEC_LEN;
+  *p_result++ = (media_type << 4);
+  *p_result++ = A2DP_MEDIA_CT_NON_A2DP;
+
+  // Vendor ID and Codec ID
+  *p_result++ = (uint8_t)(p_ie->vendorId & 0x000000FF);
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0x0000FF00) >> 8);
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0x00FF0000) >> 16);
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0xFF000000) >> 24);
+  *p_result++ = (uint8_t)(p_ie->codecId & 0x00FF);
+  *p_result++ = (uint8_t)((p_ie->codecId & 0xFF00) >> 8);
+
+  // Sampling Frequency & Bits per sample
+  uint8_t para = 0;
+
+  // sample rate bit0 ~ bit2
+  para = (uint8_t)(p_ie->sampleRate & A2DP_LHDC_SAMPLING_FREQ_MASK);
+
+  if(p_ie->bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24)
+      para |= A2DP_LHDC_BIT_FMT_24;
+  if(p_ie->bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)
+      para = para | A2DP_LHDC_BIT_FMT_16;
+
+  if (p_ie->isChannelSeparation == true) {
+      para |= A2DP_LHDCV1_CHANNEL_SEPARATION;   //Force supported Dual channels
+  }else {
+      para &= ~A2DP_LHDCV1_CHANNEL_SEPARATION;
+  }
+
+  *p_result = para;
+  if (*p_result == 0) return A2DP_INVALID_PARAMS;
+
+  LOG_DEBUG(LOG_TAG, "%s: Info build result = [0]:0x%x, [1]:0x%x, [2]:0x%x, [3]:0x%x, [4]:0x%x, [5]:0x%x, [6]:0x%x, [7]:0x%x, [8]:0x%x, [9]:0x%x",
+     __func__, tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3], tmpInfo[4], tmpInfo[5], tmpInfo[6], tmpInfo[7], tmpInfo[8], tmpInfo[9]);
+  return A2DP_SUCCESS;
+}
+
+// Parses the LHDC Media Codec Capabilities byte sequence beginning from the
+// LOSC octet. The result is stored in |p_ie|. The byte sequence to parse is
+// |p_codec_info|. If |is_capability| is true, the byte sequence is
+// codec capabilities, otherwise is codec configuration.
+// Returns A2DP_SUCCESS on success, otherwise the corresponding A2DP error
+// status code.
+static tA2DP_STATUS A2DP_ParseInfoLhdcV1(tA2DP_LHDC_CIE* p_ie,
+                                       const uint8_t* p_codec_info,
+                                       bool is_capability) {
+  uint8_t losc;
+  uint8_t media_type;
+  tA2DP_CODEC_TYPE codec_type;
+  const uint8_t* tmpInfo = p_codec_info;
+
+  //LOG_DEBUG(LOG_TAG, "%s: p_ie = %p, p_codec_info = %p", __func__, p_ie, p_codec_info);
+  if (p_ie == NULL || p_codec_info == NULL) return A2DP_INVALID_PARAMS;
+
+
+  LOG_DEBUG(LOG_TAG, "%s: Parses codec info for capbility = %s", __func__, (is_capability == 1 ? "true" : "false"));
+  LOG_DEBUG(LOG_TAG, "%s: Parses codec info = [0]:0x%x, [1]:0x%x, [2]:0x%x, [3]:0x%x, [4]:0x%x, [5]:0x%x, [6]:0x%x, [7]:0x%x, [8]:0x%x, [9]:0x%x",
+   __func__, tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3], tmpInfo[4], tmpInfo[5], tmpInfo[6], tmpInfo[7], tmpInfo[8], tmpInfo[9]);
+  // Check the codec capability length
+  losc = *p_codec_info++;
+    //LOG_DEBUG(LOG_TAG, "%s: losc = %d, A2DP_LHDCV1_CODEC_LEN = %d", __func__, losc, A2DP_LHDCV1_CODEC_LEN);
+  if (losc != A2DP_LHDCV1_CODEC_LEN) return A2DP_WRONG_CODEC;
+
+  media_type = (*p_codec_info++) >> 4;
+  codec_type = *p_codec_info++;
+    //LOG_DEBUG(LOG_TAG, "%s: media_type = %d, codec_type = %d", __func__, media_type, codec_type);
+  /* Check the Media Type and Media Codec Type */
+  if (media_type != AVDT_MEDIA_TYPE_AUDIO ||
+      codec_type != A2DP_MEDIA_CT_NON_A2DP) {
+    return A2DP_WRONG_CODEC;
+  }
+
+  // Check the Vendor ID and Codec ID */
+  p_ie->vendorId = (*p_codec_info & 0x000000FF) |
+                   (*(p_codec_info + 1) << 8 & 0x0000FF00) |
+                   (*(p_codec_info + 2) << 16 & 0x00FF0000) |
+                   (*(p_codec_info + 3) << 24 & 0xFF000000);
+  p_codec_info += 4;
+  p_ie->codecId =
+      (*p_codec_info & 0x00FF) | (*(p_codec_info + 1) << 8 & 0xFF00);
+  p_codec_info += 2;
+    //LOG_DEBUG(LOG_TAG, "%s: p_ie->vendorId = %d, p_ie->codecId = %d", __func__, p_ie->vendorId, p_ie->codecId);
+  if (p_ie->vendorId != A2DP_LHDC_VENDOR_ID ||
+      p_ie->codecId != A2DP_LHDCV1_CODEC_ID) {
+    return A2DP_WRONG_CODEC;
+  }
+
+  //LOG_DEBUG(LOG_TAG, "%s: *p_codec_info = 0x%x", __func__, *p_codec_info);
+
+  if (*p_codec_info & A2DP_LHDCV1_CHANNEL_SEPARATION){
+    p_ie->isChannelSeparation = true;
+  }else{
+    p_ie->isChannelSeparation = false;
+  }
+
+  p_ie->sampleRate = *p_codec_info & A2DP_LHDC_SAMPLING_FREQ_MASK;
+
+  p_ie->channelMode = A2DP_LHDC_CHANNEL_MODE_STEREO;
+
+  //p_ie->bits_per_sample = *p_codec_info & A2DP_LHDCV1_BIT_FMT_MASK;
+
+  LOG_DEBUG(LOG_TAG, "%s: *p_codec_info[0x%02x] & A2DP_LHDCV1_BIT_FMT_MASK[0x%02x] = 0x%02x", __func__, *p_codec_info, A2DP_LHDCV1_BIT_FMT_MASK, *p_codec_info & A2DP_LHDCV1_BIT_FMT_MASK);
+  
+  if ((*p_codec_info & A2DP_LHDC_BIT_FMT_MASK) == 0) {
+    return A2DP_WRONG_CODEC;
+  }
+
+  p_ie->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+  if (*p_codec_info & A2DP_LHDC_BIT_FMT_24)
+    p_ie->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+  if (*p_codec_info & A2DP_LHDC_BIT_FMT_16) {
+    p_ie->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+  }
+
+
+  /*
+  p_ie->sampleRate = *p_codec_info++ & A2DP_LHDC_SAMPLING_FREQ_MASK;
+  p_ie->channelMode = *p_codec_info++ & A2DP_LHDCV1_CHANNEL_MODE_MASK;
+
+*/
+
+//LOG_DEBUG(LOG_TAG, "%s: codec info = [0]:0x%x, [1]:0x%x, [2]:0x%x, [3]:0x%x, [4]:0x%x, [5]:0x%x, [6]:0x%x",
+ //__func__, tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3], tmpInfo[4], tmpInfo[5], tmpInfo[6]);
+
+  if (is_capability) return A2DP_SUCCESS;
+
+  if (A2DP_BitsSet(p_ie->sampleRate) != A2DP_SET_ONE_BIT)
+    return A2DP_BAD_SAMP_FREQ;
+  if (A2DP_BitsSet(p_ie->channelMode) != A2DP_SET_ONE_BIT)
+    return A2DP_BAD_CH_MODE;
+
+  return A2DP_SUCCESS;
+}
+
+// Build the LHDC Media Payload Header.
+// |p_dst| points to the location where the header should be written to.
+// If |frag| is true, the media payload frame is fragmented.
+// |start| is true for the first packet of a fragmented frame.
+// |last| is true for the last packet of a fragmented frame.
+// If |frag| is false, |num| is the number of number of frames in the packet,
+// otherwise is the number of remaining fragments (including this one).
+/*
+static void A2DP_BuildMediaPayloadHeaderLhdcV1(uint8_t* p, uint16_t num) {
+  if (p == NULL) return;
+  *p = ( uint8_t)( num & 0xff);
+}
+*/
+
+bool A2DP_IsVendorSourceCodecValidLhdcV1(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE cfg_cie;
+
+  /* Use a liberal check when parsing the codec info */
+  return (A2DP_ParseInfoLhdcV1(&cfg_cie, p_codec_info, false) == A2DP_SUCCESS) ||
+         (A2DP_ParseInfoLhdcV1(&cfg_cie, p_codec_info, true) == A2DP_SUCCESS);
+}
+
+bool A2DP_IsVendorPeerSinkCodecValidLhdcV1(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE cfg_cie;
+
+  /* Use a liberal check when parsing the codec info */
+  return (A2DP_ParseInfoLhdcV1(&cfg_cie, p_codec_info, false) == A2DP_SUCCESS) ||
+         (A2DP_ParseInfoLhdcV1(&cfg_cie, p_codec_info, true) == A2DP_SUCCESS);
+}
+
+// Checks whether A2DP LHDC codec configuration matches with a device's codec
+// capabilities. |p_cap| is the LHDC codec configuration. |p_codec_info| is
+// the device's codec capabilities.
+// If |is_capability| is true, the byte sequence is codec capabilities,
+// otherwise is codec configuration.
+// |p_codec_info| contains the codec capabilities for a peer device that
+// is acting as an A2DP source.
+// Returns A2DP_SUCCESS if the codec configuration matches with capabilities,
+// otherwise the corresponding A2DP error status code.
+static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV1(
+    const tA2DP_LHDC_CIE* p_cap, const uint8_t* p_codec_info,
+    bool is_capability) {
+  tA2DP_STATUS status;
+  tA2DP_LHDC_CIE cfg_cie;
+
+  /* parse configuration */
+  status = A2DP_ParseInfoLhdcV1(&cfg_cie, p_codec_info, is_capability);
+  if (status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: parsing failed %d", __func__, status);
+    return status;
+  }
+
+  /* verify that each parameter is in range */
+
+  LOG_DEBUG(LOG_TAG, "%s: FREQ peer: 0x%x, capability 0x%x", __func__,
+            cfg_cie.sampleRate, p_cap->sampleRate);
+  LOG_DEBUG(LOG_TAG, "%s: CH_MODE peer: 0x%x, capability 0x%x", __func__,
+            cfg_cie.channelMode, p_cap->channelMode);
+  LOG_DEBUG(LOG_TAG, "%s: BIT_FMT peer: 0x%x, capability 0x%x", __func__,
+            cfg_cie.bits_per_sample, p_cap->bits_per_sample);
+
+  /* sampling frequency */
+  if ((cfg_cie.sampleRate & p_cap->sampleRate) == 0) return A2DP_NS_SAMP_FREQ;
+
+  /* channel mode */
+  //if ((cfg_cie.channelMode & p_cap->channelMode) == 0) return A2DP_NS_CH_MODE;
+
+  /* channel mode */
+  if ((cfg_cie.bits_per_sample & p_cap->bits_per_sample) == 0) return A2DP_NS_CH_MODE;
+
+  return A2DP_SUCCESS;
+}
+
+bool A2DP_VendorUsesRtpHeaderLhdcV1(UNUSED_ATTR bool content_protection_enabled,
+                                  UNUSED_ATTR const uint8_t* p_codec_info) {
+  // TODO: Is this correct? The RTP header is always included?
+  return true;
+}
+
+const char* A2DP_VendorCodecNameLhdcV1(UNUSED_ATTR const uint8_t* p_codec_info) {
+  return "LHDC V1";
+}
+
+bool A2DP_VendorCodecTypeEqualsLhdcV1(const uint8_t* p_codec_info_a,
+                                    const uint8_t* p_codec_info_b) {
+  tA2DP_LHDC_CIE lhdcV1_cie_a;
+  tA2DP_LHDC_CIE lhdcV1_cie_b;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status =
+      A2DP_ParseInfoLhdcV1(&lhdcV1_cie_a, p_codec_info_a, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return false;
+  }
+  a2dp_status = A2DP_ParseInfoLhdcV1(&lhdcV1_cie_b, p_codec_info_b, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return false;
+  }
+
+  return true;
+}
+
+bool A2DP_VendorCodecEqualsLhdcV1(const uint8_t* p_codec_info_a,
+                                const uint8_t* p_codec_info_b) {
+  tA2DP_LHDC_CIE lhdcV1_cie_a;
+  tA2DP_LHDC_CIE lhdcV1_cie_b;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status =
+      A2DP_ParseInfoLhdcV1(&lhdcV1_cie_a, p_codec_info_a, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return false;
+  }
+  a2dp_status = A2DP_ParseInfoLhdcV1(&lhdcV1_cie_b, p_codec_info_b, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return false;
+  }
+
+  return (lhdcV1_cie_a.sampleRate == lhdcV1_cie_b.sampleRate) &&
+         (lhdcV1_cie_a.bits_per_sample == lhdcV1_cie_b.bits_per_sample);
+}
+
+
+int A2DP_VendorGetTrackSampleRateLhdcV1(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdcV1_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV1(&lhdcV1_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+  switch (lhdcV1_cie.sampleRate) {
+    case A2DP_LHDC_SAMPLING_FREQ_44100:
+      return 44100;
+    case A2DP_LHDC_SAMPLING_FREQ_48000:
+      return 48000;
+    case A2DP_LHDC_SAMPLING_FREQ_88200:
+      return 88200;
+    case A2DP_LHDC_SAMPLING_FREQ_96000:
+      return 96000;
+  }
+
+  return -1;
+}
+
+int A2DP_VendorGetTrackBitsPerSampleLhdcV1(const uint8_t* p_codec_info) {
+    tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV1(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+#if 0
+  return 32;
+#else
+  // TODO : Implement proc to care about bit per sample in A2DP_ParseInfoLdac()
+
+  switch (lhdc_cie.bits_per_sample) {
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+      return 16;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+      return 24;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
+      return 32;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+      return -1;
+  }
+#endif
+}
+
+int A2DP_VendorGetTrackChannelCountLhdcV1(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdcV1_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV1(&lhdcV1_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+  switch (lhdcV1_cie.channelMode) {
+    case A2DP_LHDC_CHANNEL_MODE_STEREO:
+      return 2;
+  }
+
+  return -1;
+}
+
+int A2DP_VendorGetChannelModeCodeLhdcV1(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdcV1_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV1(&lhdcV1_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+  switch (lhdcV1_cie.channelMode) {
+    case A2DP_LHDC_CHANNEL_MODE_STEREO:
+      return lhdcV1_cie.channelMode;
+    default:
+      break;
+  }
+
+  return -1;
+}
+
+bool A2DP_VendorGetPacketTimestampLhdcV1(UNUSED_ATTR const uint8_t* p_codec_info,
+                                       const uint8_t* p_data,
+                                       uint32_t* p_timestamp) {
+  // TODO: Is this function really codec-specific?
+  *p_timestamp = *(const uint32_t*)p_data;
+  return true;
+}
+
+bool A2DP_VendorGetChannelSeparation(const uint8_t* p_codec_info){
+  tA2DP_LHDC_CIE lhdcV1_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV1(&lhdcV1_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return false;
+  }
+
+  LOG_ERROR(LOG_TAG, "%s: isChannelSeparation =%d", __func__, lhdcV1_cie.isChannelSeparation);
+
+  return lhdcV1_cie.isChannelSeparation == 0 ? false : true;
+}
+
+bool A2DP_VendorBuildCodecHeaderLhdcV1(UNUSED_ATTR const uint8_t* p_codec_info,
+                                     BT_HDR* p_buf,
+                                     uint16_t frames_per_packet) {
+  uint8_t* p;
+
+  p_buf->offset -= A2DP_LHDC_MPL_HDR_LEN;
+  p = (uint8_t*)(p_buf + 1) + p_buf->offset;
+  p_buf->len += A2DP_LHDC_MPL_HDR_LEN;
+  p[0] = ( uint8_t)( frames_per_packet & 0xff);
+  p[1] = ( uint8_t)( ( frames_per_packet >> 8) & 0xff);
+  //A2DP_BuildMediaPayloadHeaderLhdcV1(p, frames_per_packet);
+  return true;
+}
+
+void A2DP_VendorDumpCodecInfoLhdcV1(const uint8_t* p_codec_info) {
+  tA2DP_STATUS a2dp_status;
+  tA2DP_LHDC_CIE lhdcV1_cie;
+
+  LOG_DEBUG(LOG_TAG, "%s", __func__);
+
+  a2dp_status = A2DP_ParseInfoLhdcV1(&lhdcV1_cie, p_codec_info, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: A2DP_ParseInfoLhdcV1 fail:%d", __func__, a2dp_status);
+    return;
+  }
+
+  LOG_DEBUG(LOG_TAG, "\tsamp_freq: 0x%x", lhdcV1_cie.sampleRate);
+  if (lhdcV1_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+    LOG_DEBUG(LOG_TAG, "\tsamp_freq: (44100)");
+  }
+  if (lhdcV1_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+    LOG_DEBUG(LOG_TAG, "\tsamp_freq: (48000)");
+  }
+  if (lhdcV1_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+    LOG_DEBUG(LOG_TAG, "\tsamp_freq: (88200)");
+  }
+  if (lhdcV1_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+    LOG_DEBUG(LOG_TAG, "\tsamp_freq: (96000)");
+  }
+
+  LOG_DEBUG(LOG_TAG, "\tch_mode: 0x%x", lhdcV1_cie.channelMode);
+  if (lhdcV1_cie.channelMode & A2DP_LHDC_CHANNEL_MODE_STEREO) {
+    LOG_DEBUG(LOG_TAG, "\tch_mode: (Stereo)");
+  }
+}
+
+std::string A2DP_VendorCodecInfoStringLhdcV1(const uint8_t* p_codec_info) {
+  std::stringstream res;
+  std::string field;
+  tA2DP_STATUS a2dp_status;
+  tA2DP_LHDC_CIE lhdcV1_cie;
+
+  a2dp_status = A2DP_ParseInfoLhdcV1(&lhdcV1_cie, p_codec_info, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    res << "A2DP_ParseInfoLhdc fail: " << loghex(a2dp_status);
+    return res.str();
+  }
+
+  res << "\tname: LHDCV1\n";
+
+  // Sample frequency
+  field.clear();
+  AppendField(&field, (lhdcV1_cie.sampleRate == 0), "NONE");
+  AppendField(&field, (lhdcV1_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100),
+              "44100");
+  AppendField(&field, (lhdcV1_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000),
+              "48000");
+  AppendField(&field, (lhdcV1_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200),
+              "88200");
+  AppendField(&field, (lhdcV1_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000),
+              "96000");
+  res << "\tsamp_freq: " << field << " (" << loghex(lhdcV1_cie.sampleRate)
+      << ")\n";
+
+  // Channel mode
+  /*
+  field.clear();
+  AppendField(&field, 0, "NONE");
+  AppendField(&field, 0,
+              "Mono");
+  AppendField(&field, 0,
+              "Dual");
+  AppendField(&field, 1,
+              "Stereo");
+  res << "\tch_mode: " << field << " (" << loghex(lhdcV1_cie.channelMode)
+      << ")\n";
+*/
+  return res.str();
+}
+
+const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterfaceLhdcV1(
+    const uint8_t* p_codec_info) {
+  if (!A2DP_IsVendorSourceCodecValidLhdcV1(p_codec_info)) return NULL;
+
+  return &a2dp_encoder_interface_lhdcv1;
+}
+
+bool A2DP_VendorAdjustCodecLhdcV1(uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE cfg_cie;
+
+  // Nothing to do: just verify the codec info is valid
+  if (A2DP_ParseInfoLhdcV1(&cfg_cie, p_codec_info, true) != A2DP_SUCCESS)
+    return false;
+
+  return true;
+}
+
+btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndexLhdcV1(
+    UNUSED_ATTR const uint8_t* p_codec_info) {
+  return BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1;
+}
+
+const char* A2DP_VendorCodecIndexStrLhdcV1(void) { return "LHDC V1"; }
+
+bool A2DP_VendorInitCodecConfigLhdcV1(AvdtpSepConfig* p_cfg) {
+  if (A2DP_BuildInfoLhdcV1(AVDT_MEDIA_TYPE_AUDIO, &a2dp_lhdcV1_caps,
+                         p_cfg->codec_info) != A2DP_SUCCESS) {
+    return false;
+  }
+
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+  /* Content protection info - support SCMS-T */
+  uint8_t* p = p_cfg->protect_info;
+  *p++ = AVDT_CP_LOSC;
+  UINT16_TO_STREAM(p, AVDT_CP_SCMS_T_ID);
+  p_cfg->num_protect = 1;
+#endif
+
+  return true;
+}
+
+UNUSED_ATTR static void build_codec_config(const tA2DP_LHDC_CIE& config_cie,
+                                           btav_a2dp_codec_config_t* result) {
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+
+  result->bits_per_sample = config_cie.bits_per_sample;
+
+  if (config_cie.channelMode &
+       (A2DP_LHDC_CHANNEL_MODE_STEREO)) {
+    result->channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  }
+}
+
+A2dpCodecConfigLhdcV1::A2dpCodecConfigLhdcV1(
+    btav_a2dp_codec_priority_t codec_priority)
+    : A2dpCodecConfig(BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1, "LHDC V1",
+                      codec_priority) {
+  // Compute the local capability
+  if (a2dp_lhdcV1_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+  }
+  if (a2dp_lhdcV1_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+  }
+  if (a2dp_lhdcV1_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+  }
+  if (a2dp_lhdcV1_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+  }
+  codec_local_capability_.bits_per_sample = a2dp_lhdcV1_caps.bits_per_sample;
+  if (a2dp_lhdcV1_caps.channelMode & A2DP_LHDC_CHANNEL_MODE_STEREO) {
+    codec_local_capability_.channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  }
+}
+
+A2dpCodecConfigLhdcV1::~A2dpCodecConfigLhdcV1() {}
+
+bool A2dpCodecConfigLhdcV1::init() {
+  if (!isValid()) return false;
+
+  // Load the encoder
+  if (!A2DP_VendorLoadEncoderLhdcV1()) {
+    LOG_ERROR(LOG_TAG, "%s: cannot load the encoder", __func__);
+    return false;
+  }
+
+  return true;
+}
+
+bool A2dpCodecConfigLhdcV1::useRtpHeaderMarkerBit() const { return false; }
+
+//
+// Selects the best sample rate from |sampleRate|.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_best_sample_rate(uint8_t sampleRate,
+                                    tA2DP_LHDC_CIE* p_result,
+                                    btav_a2dp_codec_config_t* p_codec_config) {
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+    return true;
+  }
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+    return true;
+  }
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    return true;
+  }
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    return true;
+  }
+  return false;
+}
+
+//
+// Selects the audio sample rate from |p_codec_audio_config|.
+// |sampleRate| contains the capability.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_audio_sample_rate(
+    const btav_a2dp_codec_config_t* p_codec_audio_config, uint8_t sampleRate,
+    tA2DP_LHDC_CIE* p_result, btav_a2dp_codec_config_t* p_codec_config) {
+  switch (p_codec_audio_config->sample_rate) {
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
+        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
+        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
+        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_24000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_16000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
+      break;
+  }
+  return false;
+}
+
+//
+// Selects the best bits per sample from |bits_per_sample|.
+// |bits_per_sample| contains the capability.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_best_bits_per_sample(
+    btav_a2dp_codec_bits_per_sample_t bits_per_sample, tA2DP_LHDC_CIE* p_result,
+    btav_a2dp_codec_config_t* p_codec_config) {
+  if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+    p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+    return true;
+  }
+  if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    return true;
+  }
+  return false;
+}
+
+//
+// Selects the audio bits per sample from |p_codec_audio_config|.
+// |bits_per_sample| contains the capability.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_audio_bits_per_sample(
+    const btav_a2dp_codec_config_t* p_codec_audio_config,
+    btav_a2dp_codec_bits_per_sample_t bits_per_sample, tA2DP_LHDC_CIE* p_result,
+    btav_a2dp_codec_config_t* p_codec_config) {
+  switch (p_codec_audio_config->bits_per_sample) {
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+        p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+        p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+        p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+        p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+      break;
+  }
+  return false;
+}
+
+
+
+bool A2dpCodecConfigLhdcV1::setCodecConfig(const uint8_t* p_peer_codec_info,
+                                         bool is_capability,
+                                         uint8_t* p_result_codec_config) {
+  std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
+  tA2DP_LHDC_CIE sink_info_cie;
+  tA2DP_LHDC_CIE result_config_cie;
+  uint8_t channelMode;
+  uint8_t sampleRate;
+  btav_a2dp_codec_bits_per_sample_t bits_per_sample;
+
+  // Save the internal state
+  btav_a2dp_codec_config_t saved_codec_config = codec_config_;
+  btav_a2dp_codec_config_t saved_codec_capability = codec_capability_;
+  btav_a2dp_codec_config_t saved_codec_selectable_capability =
+      codec_selectable_capability_;
+  btav_a2dp_codec_config_t saved_codec_user_config = codec_user_config_;
+  btav_a2dp_codec_config_t saved_codec_audio_config = codec_audio_config_;
+  uint8_t saved_ota_codec_config[AVDT_CODEC_SIZE];
+  uint8_t saved_ota_codec_peer_capability[AVDT_CODEC_SIZE];
+  uint8_t saved_ota_codec_peer_config[AVDT_CODEC_SIZE];
+  memcpy(saved_ota_codec_config, ota_codec_config_, sizeof(ota_codec_config_));
+  memcpy(saved_ota_codec_peer_capability, ota_codec_peer_capability_,
+         sizeof(ota_codec_peer_capability_));
+  memcpy(saved_ota_codec_peer_config, ota_codec_peer_config_,
+         sizeof(ota_codec_peer_config_));
+
+  tA2DP_STATUS status =
+      A2DP_ParseInfoLhdcV1(&sink_info_cie, p_peer_codec_info, is_capability);
+  if (status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: can't parse peer's Sink capabilities: error = %d",
+              __func__, status);
+    goto fail;
+  }
+
+    LOG_ERROR(LOG_TAG,
+              "%s",
+              __func__);
+
+  //
+  // Build the preferred configuration
+  //
+  memset(&result_config_cie, 0, sizeof(result_config_cie));
+  result_config_cie.vendorId = a2dp_lhdcV1_caps.vendorId;
+  result_config_cie.codecId = a2dp_lhdcV1_caps.codecId;
+
+  //
+  // Select the sample frequency
+  //
+  sampleRate = a2dp_lhdcV1_caps.sampleRate & sink_info_cie.sampleRate;
+  LOG_ERROR(LOG_TAG, "%s: samplrate = 0x%x", __func__, sampleRate);
+  codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+  switch (codec_user_config_.sample_rate) {
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
+        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+        codec_config_.sample_rate = codec_user_config_.sample_rate;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+        codec_config_.sample_rate = codec_user_config_.sample_rate;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
+        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+        codec_config_.sample_rate = codec_user_config_.sample_rate;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
+        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+        codec_config_.sample_rate = codec_user_config_.sample_rate;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_24000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_16000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
+      codec_capability_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+      codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+      break;
+  }
+
+  // Select the sample frequency if there is no user preference
+  do {
+    // Compute the selectable capability
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+      codec_selectable_capability_.sample_rate |=
+          BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    }
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+      codec_selectable_capability_.sample_rate |=
+          BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    }
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+      codec_selectable_capability_.sample_rate |=
+          BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+    }
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+      codec_selectable_capability_.sample_rate |=
+          BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+    }
+
+    if (codec_config_.sample_rate != BTAV_A2DP_CODEC_SAMPLE_RATE_NONE) break;
+
+    // Compute the common capability
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+
+    // No user preference - try the codec audio config
+    if (select_audio_sample_rate(&codec_audio_config_, sampleRate,
+                                 &result_config_cie, &codec_config_)) {
+      break;
+    }
+
+    // No user preference - try the default config
+    if (select_best_sample_rate(
+            a2dp_lhdcV1_default_config.sampleRate & sink_info_cie.sampleRate,
+            &result_config_cie, &codec_config_)) {
+      break;
+    }
+
+    // No user preference - use the best match
+    if (select_best_sample_rate(sampleRate, &result_config_cie,
+                                &codec_config_)) {
+      break;
+    }
+  } while (false);
+  if (codec_config_.sample_rate == BTAV_A2DP_CODEC_SAMPLE_RATE_NONE) {
+    LOG_ERROR(LOG_TAG,
+              "%s: cannot match sample frequency: source caps = 0x%x "
+              "sink info = 0x%x",
+              __func__, a2dp_lhdcV1_caps.sampleRate, sink_info_cie.sampleRate);
+    goto fail;
+  }
+
+  //
+  // Select the bits per sample
+  //
+  // NOTE: this information is NOT included in the LHDC A2DP codec description
+  // that is sent OTA.
+  bits_per_sample = a2dp_lhdcV1_caps.bits_per_sample & sink_info_cie.bits_per_sample;
+  LOG_ERROR(LOG_TAG, "%s: a2dp_lhdcV1_caps.bits_per_sample = 0x%02x, sink_info_cie.bits_per_sample = 0x%02x", __func__, a2dp_lhdcV1_caps.bits_per_sample, sink_info_cie.bits_per_sample);
+  LOG_ERROR(LOG_TAG, "%s: bits_per_sample = 0x%02x", __func__, bits_per_sample);
+  codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+  switch (codec_user_config_.bits_per_sample) {
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+        result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+        codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
+        codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
+      }
+      break;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+        result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+        codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
+        codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
+      }
+      break;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+      result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+      codec_capability_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+      codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+      break;
+  }
+
+  // Select the bits per sample if there is no user preference
+  do {
+    // Compute the selectable capability
+      // Compute the selectable capability
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)
+        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24)
+        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+
+    if (codec_config_.bits_per_sample != BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE) break;
+
+    // Compute the common capability
+    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)
+      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24)
+      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+
+    // No user preference - the the codec audio config
+    if (select_audio_bits_per_sample(&codec_audio_config_, bits_per_sample,
+                                     &result_config_cie, &codec_config_)) {
+      break;
+    }
+
+    // No user preference - try the default config
+    if (select_best_bits_per_sample(a2dp_lhdcV1_default_config.bits_per_sample & sink_info_cie.bits_per_sample,
+                                    &result_config_cie, &codec_config_)) {
+      break;
+    }
+
+    // No user preference - use the best match
+    if (select_best_bits_per_sample(bits_per_sample,
+                                    &result_config_cie, &codec_config_)) {
+      break;
+    }
+  } while (false);
+/*
+  // Select the bits per sample if there is no user preference
+  do {
+    // Compute the selectable capability
+    codec_selectable_capability_.bits_per_sample =
+        a2dp_lhdcV1_caps.bits_per_sample;
+
+    if (codec_config_.bits_per_sample != BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE)
+      break;
+
+    // Compute the common capability
+    codec_capability_.bits_per_sample = bits_per_sample;
+
+    // No user preference - the the codec audio config
+    if (select_audio_bits_per_sample(&codec_audio_config_,
+                                     a2dp_lhdcV1_caps.bits_per_sample,
+                                     &result_config_cie, &codec_config_)) {
+      break;
+    }
+
+    // No user preference - try the default config
+    if (select_best_bits_per_sample(a2dp_lhdcV1_default_config.bits_per_sample,
+                                    &result_config_cie, &codec_config_)) {
+      break;
+    }
+
+    // No user preference - use the best match
+    if (select_best_bits_per_sample(a2dp_lhdcV1_caps.bits_per_sample,
+                                    &result_config_cie, &codec_config_)) {
+      break;
+    }
+} while (false);*/
+  if (codec_config_.bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE) {
+    LOG_ERROR(LOG_TAG,
+              "%s: cannot match bits per sample: default = 0x%x "
+              "user preference = 0x%x",
+              __func__, a2dp_lhdcV1_default_config.bits_per_sample,
+              codec_user_config_.bits_per_sample);
+    goto fail;
+  }
+
+  //
+  // Select the channel mode
+  //
+  channelMode = a2dp_lhdcV1_caps.channelMode & sink_info_cie.channelMode;
+  LOG_ERROR(LOG_TAG, "%s: channelMode = 0x%x", __func__, channelMode);
+  codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
+  switch (codec_user_config_.channel_mode) {
+    case BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO:
+      if (channelMode & A2DP_LHDC_CHANNEL_MODE_STEREO) {
+        result_config_cie.channelMode = A2DP_LHDC_CHANNEL_MODE_STEREO;
+        codec_capability_.channel_mode = codec_user_config_.channel_mode;
+        codec_config_.channel_mode = codec_user_config_.channel_mode;
+        break;
+      }
+      break;
+    case BTAV_A2DP_CODEC_CHANNEL_MODE_MONO:
+    case BTAV_A2DP_CODEC_CHANNEL_MODE_NONE:
+      codec_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
+      codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
+      break;
+  }
+  codec_selectable_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  codec_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  if (codec_config_.channel_mode == BTAV_A2DP_CODEC_CHANNEL_MODE_NONE) {
+    LOG_ERROR(LOG_TAG,
+              "%s: cannot match channel mode: source caps = 0x%x "
+              "sink info = 0x%x",
+              __func__, a2dp_lhdcV1_caps.channelMode, sink_info_cie.channelMode);
+    goto fail;
+  }
+
+  if (int ret = A2DP_BuildInfoLhdcV1(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
+                         p_result_codec_config) != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG,"%s: A2DP_BuildInfoLhdcV1 fail(0x%x)", __func__, ret);
+    goto fail;
+  }
+
+  //
+  // Copy the codec-specific fields if they are not zero
+  //
+  if (codec_user_config_.codec_specific_1 != 0)
+    codec_config_.codec_specific_1 = codec_user_config_.codec_specific_1;
+  if (codec_user_config_.codec_specific_2 != 0)
+    codec_config_.codec_specific_2 = codec_user_config_.codec_specific_2;
+  if (codec_user_config_.codec_specific_3 != 0)
+    codec_config_.codec_specific_3 = codec_user_config_.codec_specific_3;
+  if (codec_user_config_.codec_specific_4 != 0)
+    codec_config_.codec_specific_4 = codec_user_config_.codec_specific_4;
+
+
+  result_config_cie.isChannelSeparation = sink_info_cie.isChannelSeparation;
+  LOG_ERROR(LOG_TAG,"%s: isChannelSeparation = %d", __func__, result_config_cie.isChannelSeparation);
+
+  // Create a local copy of the peer codec capability, and the
+  // result codec config.
+    LOG_ERROR(LOG_TAG,"%s: is_capability = %d", __func__, is_capability);
+  if (is_capability) {
+    status = A2DP_BuildInfoLhdcV1(AVDT_MEDIA_TYPE_AUDIO, &sink_info_cie,
+                                ota_codec_peer_capability_);
+  } else {
+    status = A2DP_BuildInfoLhdcV1(AVDT_MEDIA_TYPE_AUDIO, &sink_info_cie,
+                                ota_codec_peer_config_);
+  }
+  CHECK(status == A2DP_SUCCESS);
+
+  status = A2DP_BuildInfoLhdcV1(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
+                              ota_codec_config_);
+  CHECK(status == A2DP_SUCCESS);
+  return true;
+
+fail:
+  // Restore the internal state
+  codec_config_ = saved_codec_config;
+  codec_capability_ = saved_codec_capability;
+  codec_selectable_capability_ = saved_codec_selectable_capability;
+  codec_user_config_ = saved_codec_user_config;
+  codec_audio_config_ = saved_codec_audio_config;
+  memcpy(ota_codec_config_, saved_ota_codec_config, sizeof(ota_codec_config_));
+  memcpy(ota_codec_peer_capability_, saved_ota_codec_peer_capability,
+         sizeof(ota_codec_peer_capability_));
+  memcpy(ota_codec_peer_config_, saved_ota_codec_peer_config,
+         sizeof(ota_codec_peer_config_));
+  return false;
+}
+
+bool A2dpCodecConfigLhdcV1::setPeerCodecCapabilities(
+                                                   const uint8_t* p_peer_codec_capabilities) {
+    std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
+    tA2DP_LHDC_CIE peer_info_cie;
+    uint8_t sampleRate;
+    uint8_t bits_per_sample;
+
+    // Save the internal state
+    btav_a2dp_codec_config_t saved_codec_selectable_capability =
+    codec_selectable_capability_;
+    uint8_t saved_ota_codec_peer_capability[AVDT_CODEC_SIZE];
+    memcpy(saved_ota_codec_peer_capability, ota_codec_peer_capability_,
+           sizeof(ota_codec_peer_capability_));
+
+    tA2DP_STATUS status =
+    A2DP_ParseInfoLhdcV1(&peer_info_cie, p_peer_codec_capabilities, true);
+    if (status != A2DP_SUCCESS) {
+        LOG_ERROR(LOG_TAG, "%s: can't parse peer's capabilities: error = %d",
+                  __func__, status);
+        goto fail;
+    }
+
+
+    codec_selectable_capability_.codec_specific_3 = 0;
+
+    // Compute the selectable capability - bits per sample
+    //codec_selectable_capability_.bits_per_sample =
+    //a2dp_lhdcV1_caps.bits_per_sample;
+    bits_per_sample = peer_info_cie.bits_per_sample & peer_info_cie.bits_per_sample;
+    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    }
+    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+    }
+
+
+    // Compute the selectable capability - sample rate
+    sampleRate = a2dp_lhdcV1_caps.sampleRate & peer_info_cie.sampleRate;
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+        codec_selectable_capability_.sample_rate |=
+        BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    }
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+        codec_selectable_capability_.sample_rate |=
+        BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    }
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+        codec_selectable_capability_.sample_rate |=
+        BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+    }
+
+
+    // Compute the selectable capability - channel mode
+    codec_selectable_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+
+    status = A2DP_BuildInfoLhdcV1(AVDT_MEDIA_TYPE_AUDIO, &peer_info_cie,
+                                ota_codec_peer_capability_);
+    CHECK(status == A2DP_SUCCESS);
+    return true;
+
+fail:
+    // Restore the internal state
+    codec_selectable_capability_ = saved_codec_selectable_capability;
+    memcpy(ota_codec_peer_capability_, saved_ota_codec_peer_capability,
+           sizeof(ota_codec_peer_capability_));
+    return false;
+}
diff --git a/system/bt/stack/a2dp/a2dp_vendor_lhdcv1_encoder.cc b/system/bt/stack/a2dp/a2dp_vendor_lhdcv1_encoder.cc
new file mode 100755
index 00000000..aaa5aeea
--- /dev/null
+++ b/system/bt/stack/a2dp/a2dp_vendor_lhdcv1_encoder.cc
@@ -0,0 +1,873 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "a2dp_vendor_lhdcv1_encoder"
+#define ATRACE_TAG ATRACE_TAG_AUDIO
+
+#include "a2dp_vendor_lhdcv1_encoder.h"
+
+#ifndef OS_GENERIC
+#include <cutils/trace.h>
+#endif
+#include <dlfcn.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <lhdcBT.h>
+
+#include "a2dp_vendor.h"
+#include "a2dp_vendor_lhdcv1.h"
+#include "bt_common.h"
+#include "common/time_util.h"
+#include "osi/include/log.h"
+#include "osi/include/osi.h"
+
+//
+// Encoder for LHDC Source Codec
+//
+
+//
+// The LHDC encoder shared library, and the functions to use
+//
+static const char* LHDC_ENCODER_LIB_NAME = "liblhdcBT_enc.so";
+static void* lhdcV1_encoder_lib_handle = NULL;
+
+static const char* LHDC_GET_HANDLE_NAME = "lhdcBT_get_handle";
+typedef HANDLE_LHDC_BT (*tLHDC_GET_HANDLE)(int version);
+
+static const char* LHDC_FREE_HANDLE_NAME = "lhdcBT_free_handle";
+typedef void (*tLHDC_FREE_HANDLE)(HANDLE_LHDC_BT hLhdcParam);
+
+static const char* LHDC_GET_BITRATE_NAME = "lhdcBT_get_bitrate";
+typedef int (*tLHDC_GET_BITRATE)(HANDLE_LHDC_BT hLhdcParam);
+static const char* LHDC_SET_BITRATE_NAME = "lhdcBT_set_bitrate";
+typedef int (*tLHDC_SET_BITRATE)(HANDLE_LHDC_BT hLhdcParam, int index);
+
+//static const char* LHDC_GET_SAMPLING_FREQ_NAME = "lhdcBT_get_sampling_freq";
+//typedef int (*tLHDC_GET_SAMPLING_FREQ)(HANDLE_LHDC_BT hLhdcParam);
+
+static const char* LHDC_INIT_HANDLE_ENCODE_NAME = "lhdcBT_init_encoder";
+typedef int (*tLHDC_INIT_HANDLE_ENCODE)(HANDLE_LHDC_BT hLhdcParam,int sampling_freq, int bitPerSample, int bitrate_inx, int dualChannels, int need_padding, int mtu_size, int interval);
+
+static const char* LHDC_AUTO_ADJUST_BITRATE_NAME = "lhdcBT_adjust_bitrate";
+typedef int (*tLHDC_AUTO_ADJUST_BITRATE)(HANDLE_LHDC_BT hLhdcParam, size_t queueLength);
+
+
+static const char* LHDC_ENCODE_NAME = "lhdcBT_encode";
+typedef int (*tLHDC_ENCODE)(HANDLE_LHDC_BT hLhdcParam, void* p_pcm, unsigned char* p_stream);
+
+//static const char* LHDC_GET_ERROR_CODE_NAME = "lhdcBT_get_error_code";
+//typedef int (*tLHDC_GET_ERROR_CODE)(HANDLE_LHDC_BT hLhdcParam);
+
+static tLHDC_GET_HANDLE lhdcV1_get_handle_func;
+static tLHDC_FREE_HANDLE lhdcV1_free_handle_func;
+//static tLHDC_CLOSE_HANDLE lhdcV1_close_handle_func;
+//static tLHDC_GET_VERSION lhdcV1_get_version_func;
+static tLHDC_GET_BITRATE lhdcV1_get_bitrate_func;
+static tLHDC_SET_BITRATE lhdcV1_set_bitrate_func;
+//static tLHDC_GET_SAMPLING_FREQ lhdcV1_get_sampling_freq_func;
+static tLHDC_INIT_HANDLE_ENCODE lhdcV1_init_handle_encode_func;
+static tLHDC_ENCODE lhdcV1_encode_func;
+static tLHDC_AUTO_ADJUST_BITRATE lhdcV1_auto_adjust_bitrate_func;
+//static tLHDC_GET_ERROR_CODE lhdcV1_get_error_code_func;
+//static tLHDC_SET_LIMIT_BITRATE_ENABLED lhdcV1_set_limit_bitrate_enabled;
+
+// A2DP LHDC encoder interval in milliseconds
+#define A2DP_LHDCV1_ENCODER_INTERVAL_MS 20
+#define A2DP_LHDCV1_SAMPLES_PER_FRAME 512
+
+// offset
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+#define A2DP_LHDCV1_OFFSET (AVDT_MEDIA_OFFSET + A2DP_LHDC_MPL_HDR_LEN + 1)
+#else
+#define A2DP_LHDCV1_OFFSET (AVDT_MEDIA_OFFSET + A2DP_LHDC_MPL_HDR_LEN)
+#endif
+
+//#define A2DP_LHDCV1_OFFSET (AVDT_MEDIA_OFFSET + 0)
+
+typedef struct {
+  uint32_t sample_rate;
+  uint8_t channel_mode;
+  uint8_t bits_per_sample;
+  int quality_mode_index;
+  int latency_mode_index;
+  int pcm_wlength;
+  LHDCBT_SMPL_FMT_T pcm_fmt;
+  bool isChannelSeparation;
+} tA2DP_LHDC_ENCODER_PARAMS;
+
+typedef struct {
+  uint32_t counter;
+  uint32_t bytes_per_tick; /* pcm bytes read each media task tick */
+  uint64_t last_frame_us;
+} tA2DP_LHDC_FEEDING_STATE;
+
+typedef struct {
+  uint64_t session_start_us;
+
+  size_t media_read_total_expected_packets;
+  size_t media_read_total_expected_reads_count;
+  size_t media_read_total_expected_read_bytes;
+
+  size_t media_read_total_dropped_packets;
+  size_t media_read_total_actual_reads_count;
+  size_t media_read_total_actual_read_bytes;
+} a2dp_lhdcV1_encoder_stats_t;
+
+typedef struct {
+  a2dp_source_read_callback_t read_callback;
+  a2dp_source_enqueue_callback_t enqueue_callback;
+  uint16_t TxAaMtuSize;
+  size_t TxQueueLength;
+
+  bool use_SCMS_T;
+  bool is_peer_edr;          // True if the peer device supports EDR
+  bool peer_supports_3mbps;  // True if the peer device supports 3Mbps EDR
+  uint16_t peer_mtu;         // MTU of the A2DP peer
+  uint32_t timestamp;        // Timestamp for the A2DP frames
+
+  HANDLE_LHDC_BT lhdcV1_handle;
+  bool has_lhdcV1_handle;  // True if lhdcV1_handle is valid
+/*
+  HANDLE_LHDC_ABR lhdcV1_abr_handle;
+  bool has_lhdcV1_abr_handle;
+  int last_lhdcV1_abr_eqmid;
+  size_t lhdcV1_abr_adjustments;
+*/
+  tA2DP_FEEDING_PARAMS feeding_params;
+  tA2DP_LHDC_ENCODER_PARAMS lhdcV1_encoder_params;
+  tA2DP_LHDC_FEEDING_STATE lhdcV1_feeding_state;
+
+  a2dp_lhdcV1_encoder_stats_t stats;
+  uint32_t buf_seq;
+} tA2DP_LHDC_ENCODER_CB;
+
+//static bool lhdcV1_abr_loaded = false;
+
+//FILE  *RecFile = NULL;
+
+static tA2DP_LHDC_ENCODER_CB a2dp_lhdcV1_encoder_cb;
+
+static void a2dp_vendor_lhdcV1_encoder_update(uint16_t peer_mtu,
+                                            A2dpCodecConfig* a2dp_codec_config,
+                                            bool* p_restart_input,
+                                            bool* p_restart_output,
+                                            bool* p_config_updated);
+static void a2dp_lhdcV1_get_num_frame_iteration(uint8_t* num_of_iterations,
+                                              uint8_t* num_of_frames,
+                                              uint64_t timestamp_us);
+static void a2dp_lhdcV1_encode_frames(uint8_t nb_frame);
+static bool a2dp_lhdcV1_read_feeding(uint8_t* read_buffer);
+static std::string quality_mode_index_to_name(int quality_mode_index);
+static std::string latency_mode_index_to_name(int latency_mode_index);
+
+static void* load_func(const char* func_name) {
+  void* func_ptr = dlsym(lhdcV1_encoder_lib_handle, func_name);
+  if (func_ptr == NULL) {
+    LOG_ERROR(LOG_TAG,
+              "%s: cannot find function '%s' in the encoder library: %s",
+              __func__, func_name, dlerror());
+    A2DP_VendorUnloadEncoderLhdcV1();
+    return NULL;
+  }
+  return func_ptr;
+}
+
+bool A2DP_VendorLoadEncoderLhdcV1(void) {
+  if (lhdcV1_encoder_lib_handle != NULL) return true;  // Already loaded
+
+  // Initialize the control block
+  memset(&a2dp_lhdcV1_encoder_cb, 0, sizeof(a2dp_lhdcV1_encoder_cb));
+
+  // Open the encoder library
+  lhdcV1_encoder_lib_handle = dlopen(LHDC_ENCODER_LIB_NAME, RTLD_NOW);
+  if (lhdcV1_encoder_lib_handle == NULL) {
+    LOG_ERROR(LOG_TAG, "%s: cannot open LHDC encoder library %s: %s", __func__,
+              LHDC_ENCODER_LIB_NAME, dlerror());
+    return false;
+  }
+
+  // Load all functions
+  lhdcV1_get_handle_func = (tLHDC_GET_HANDLE)load_func(LHDC_GET_HANDLE_NAME);
+  if (lhdcV1_get_handle_func == NULL) return false;
+  lhdcV1_free_handle_func = (tLHDC_FREE_HANDLE)load_func(LHDC_FREE_HANDLE_NAME);
+  if (lhdcV1_free_handle_func == NULL) return false;
+  //lhdcV1_close_handle_func = (tLHDC_CLOSE_HANDLE)load_func(LHDC_CLOSE_HANDLE_NAME);
+  //if (lhdcV1_close_handle_func == NULL) return false;
+  //lhdcV1_get_version_func = (tLHDC_GET_VERSION)load_func(LHDC_GET_VERSION_NAME);
+  //if (lhdcV1_get_version_func == NULL) return false;
+  lhdcV1_get_bitrate_func = (tLHDC_GET_BITRATE)load_func(LHDC_GET_BITRATE_NAME);
+  if (lhdcV1_get_bitrate_func == NULL) return false;
+  lhdcV1_set_bitrate_func = (tLHDC_SET_BITRATE)load_func(LHDC_SET_BITRATE_NAME);
+  if (lhdcV1_set_bitrate_func == NULL) return false;
+  //lhdcV1_get_sampling_freq_func = (tLHDC_GET_SAMPLING_FREQ)load_func(LHDC_GET_SAMPLING_FREQ_NAME);
+  //if (lhdcV1_get_sampling_freq_func == NULL) return false;
+  lhdcV1_init_handle_encode_func =
+      (tLHDC_INIT_HANDLE_ENCODE)load_func(LHDC_INIT_HANDLE_ENCODE_NAME);
+  if (lhdcV1_init_handle_encode_func == NULL) return false;
+  lhdcV1_encode_func = (tLHDC_ENCODE)load_func(LHDC_ENCODE_NAME);
+  if (lhdcV1_encode_func == NULL) return false;
+  lhdcV1_auto_adjust_bitrate_func = (tLHDC_AUTO_ADJUST_BITRATE)load_func(LHDC_AUTO_ADJUST_BITRATE_NAME);
+  if (lhdcV1_auto_adjust_bitrate_func == NULL) return false;
+  //lhdcV1_alter_eqmid_priority_func = (tLHDC_ALTER_EQMID_PRIORITY)load_func(LHDC_ALTER_EQMID_PRIORITY_NAME);
+  //if (lhdcV1_alter_eqmid_priority_func == NULL) return false;
+  //lhdcV1_get_eqmid_func = (tLHDC_GET_EQMID)load_func(LHDC_GET_EQMID_NAME);
+  //if (lhdcV1_get_eqmid_func == NULL) return false;
+  //lhdcV1_get_error_code_func = (tLHDC_GET_ERROR_CODE)load_func(LHDC_GET_ERROR_CODE_NAME);
+  //if (lhdcV1_get_error_code_func == NULL) return false;
+
+
+  //lhdcV1_set_limit_bitrate_enabled = (tLHDC_SET_LIMIT_BITRATE_ENABLED)load_func(LHDC_SET_LIMIT_BITRATE_ENABLED_NAME);
+  //if (lhdcV1_set_limit_bitrate_enabled == NULL) return false;
+
+
+/*
+  if (!A2DP_VendorLoadLhdcAbr()) {
+    LOG_WARN(LOG_TAG, "%s: cannot load the LHDC ABR library", __func__);
+    lhdcV1_abr_loaded = false;
+  } else {
+    lhdcV1_abr_loaded = true;
+  }
+  */
+  return true;
+}
+
+void A2DP_VendorUnloadEncoderLhdcV1(void) {
+  // Cleanup any LHDC-related state
+
+    LOG_DEBUG(LOG_TAG, "%s: a2dp_lhdcV1_encoder_cb.has_lhdcV1_handle = %d, lhdcV1_free_handle_func = %p",
+              __func__, a2dp_lhdcV1_encoder_cb.has_lhdcV1_handle, lhdcV1_free_handle_func);
+  if (a2dp_lhdcV1_encoder_cb.has_lhdcV1_handle && lhdcV1_free_handle_func != NULL)
+    lhdcV1_free_handle_func(a2dp_lhdcV1_encoder_cb.lhdcV1_handle);
+  memset(&a2dp_lhdcV1_encoder_cb, 0, sizeof(a2dp_lhdcV1_encoder_cb));
+
+  lhdcV1_get_handle_func = NULL;
+  lhdcV1_free_handle_func = NULL;
+  lhdcV1_get_bitrate_func = NULL;
+  lhdcV1_set_bitrate_func = NULL;
+  //lhdcV1_get_sampling_freq_func = NULL;
+  lhdcV1_init_handle_encode_func = NULL;
+  lhdcV1_encode_func = NULL;
+  lhdcV1_auto_adjust_bitrate_func = NULL;
+  //lhdcV1_get_error_code_func = NULL;
+  //lhdcV1_set_limit_bitrate_enabled = NULL;
+
+  if (lhdcV1_encoder_lib_handle != NULL) {
+    dlclose(lhdcV1_encoder_lib_handle);
+    lhdcV1_encoder_lib_handle = NULL;
+  }
+}
+
+void a2dp_vendor_lhdcV1_encoder_init(
+    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+    A2dpCodecConfig* a2dp_codec_config,
+    a2dp_source_read_callback_t read_callback,
+    a2dp_source_enqueue_callback_t enqueue_callback) {
+  if (a2dp_lhdcV1_encoder_cb.has_lhdcV1_handle)
+    lhdcV1_free_handle_func(a2dp_lhdcV1_encoder_cb.lhdcV1_handle);
+
+  memset(&a2dp_lhdcV1_encoder_cb, 0, sizeof(a2dp_lhdcV1_encoder_cb));
+
+  a2dp_lhdcV1_encoder_cb.stats.session_start_us = bluetooth::common::time_get_os_boottime_us();
+
+  a2dp_lhdcV1_encoder_cb.read_callback = read_callback;
+  a2dp_lhdcV1_encoder_cb.enqueue_callback = enqueue_callback;
+  a2dp_lhdcV1_encoder_cb.is_peer_edr = p_peer_params->is_peer_edr;
+  a2dp_lhdcV1_encoder_cb.peer_supports_3mbps = p_peer_params->peer_supports_3mbps;
+  a2dp_lhdcV1_encoder_cb.peer_mtu = p_peer_params->peer_mtu;
+  a2dp_lhdcV1_encoder_cb.timestamp = 0;
+
+
+  a2dp_lhdcV1_encoder_cb.use_SCMS_T = false;  // TODO: should be a parameter
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+  a2dp_lhdcV1_encoder_cb.use_SCMS_T = true;
+#endif
+
+  // NOTE: Ignore the restart_input / restart_output flags - this initization
+  // happens when the connection is (re)started.
+  bool restart_input = false;
+  bool restart_output = false;
+  bool config_updated = false;
+  a2dp_vendor_lhdcV1_encoder_update(a2dp_lhdcV1_encoder_cb.peer_mtu,
+                                  a2dp_codec_config, &restart_input,
+                                  &restart_output, &config_updated);
+}
+
+bool A2dpCodecConfigLhdcV1::updateEncoderUserConfig(
+    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params, bool* p_restart_input,
+    bool* p_restart_output, bool* p_config_updated) {
+  a2dp_lhdcV1_encoder_cb.is_peer_edr = p_peer_params->is_peer_edr;
+  a2dp_lhdcV1_encoder_cb.peer_supports_3mbps = p_peer_params->peer_supports_3mbps;
+  a2dp_lhdcV1_encoder_cb.peer_mtu = p_peer_params->peer_mtu;
+  a2dp_lhdcV1_encoder_cb.timestamp = 0;
+
+  if (a2dp_lhdcV1_encoder_cb.peer_mtu == 0) {
+    LOG_ERROR(LOG_TAG,
+              "%s: Cannot update the codec encoder for %s: "
+              "invalid peer MTU",
+              __func__, name().c_str());
+    return false;
+  }
+
+  a2dp_vendor_lhdcV1_encoder_update(a2dp_lhdcV1_encoder_cb.peer_mtu, this,
+                                  p_restart_input, p_restart_output,
+                                  p_config_updated);
+  return true;
+}
+
+// Update the A2DP LHDC encoder.
+// |peer_mtu| is the peer MTU.
+// |a2dp_codec_config| is the A2DP codec to use for the update.
+static void a2dp_vendor_lhdcV1_encoder_update(uint16_t peer_mtu,
+                                            A2dpCodecConfig* a2dp_codec_config,
+                                            bool* p_restart_input,
+                                            bool* p_restart_output,
+                                            bool* p_config_updated) {
+  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params =
+      &a2dp_lhdcV1_encoder_cb.lhdcV1_encoder_params;
+  uint8_t codec_info[AVDT_CODEC_SIZE];
+
+  *p_restart_input = false;
+  *p_restart_output = false;
+  *p_config_updated = false;
+
+  //Example for limit bit rate
+  //lhdcV1_set_limit_bitrate_enabled(a2dp_lhdcV1_encoder_cb.lhdcV1_handle, 0);
+
+
+  if (!a2dp_codec_config->copyOutOtaCodecConfig(codec_info)) {
+    LOG_ERROR(LOG_TAG,
+              "%s: Cannot update the codec encoder for %s: "
+              "invalid codec config",
+              __func__, a2dp_codec_config->name().c_str());
+    return;
+  }
+
+  if (!a2dp_lhdcV1_encoder_cb.has_lhdcV1_handle) {
+      a2dp_lhdcV1_encoder_cb.lhdcV1_handle = lhdcV1_get_handle_func(0);
+      if (a2dp_lhdcV1_encoder_cb.lhdcV1_handle == NULL) {
+          LOG_ERROR(LOG_TAG, "%s: Cannot get LHDC encoder handle", __func__);
+          return;  // TODO: Return an error?
+      }
+      a2dp_lhdcV1_encoder_cb.has_lhdcV1_handle = true;
+  }
+  const uint8_t* p_codec_info = codec_info;
+  btav_a2dp_codec_config_t codec_config = a2dp_codec_config->getCodecConfig();
+  //btav_a2dp_codec_config_t codec_config_user = a2dp_codec_config->getCodecUserConfig();
+
+  // The feeding parameters
+  tA2DP_FEEDING_PARAMS* p_feeding_params = &a2dp_lhdcV1_encoder_cb.feeding_params;
+  p_feeding_params->sample_rate =
+      A2DP_VendorGetTrackSampleRateLhdcV1(p_codec_info);
+  p_feeding_params->bits_per_sample =
+      a2dp_codec_config->getAudioBitsPerSample();
+  p_feeding_params->channel_count =
+      A2DP_VendorGetTrackChannelCountLhdcV1(p_codec_info);
+  LOG_DEBUG(LOG_TAG, "%s: sample_rate=%u bits_per_sample=%u channel_count=%u",
+            __func__, p_feeding_params->sample_rate,
+            p_feeding_params->bits_per_sample, p_feeding_params->channel_count);
+
+  // The codec parameters
+  p_encoder_params->sample_rate =
+      a2dp_lhdcV1_encoder_cb.feeding_params.sample_rate;
+  p_encoder_params->channel_mode =
+      A2DP_VendorGetChannelModeCodeLhdcV1(p_codec_info);
+
+  uint16_t mtu_size =
+      BT_DEFAULT_BUFFER_SIZE - A2DP_LHDCV1_OFFSET - sizeof(BT_HDR);
+  if (mtu_size < peer_mtu) {
+    a2dp_lhdcV1_encoder_cb.TxAaMtuSize = mtu_size;
+  } else {
+    a2dp_lhdcV1_encoder_cb.TxAaMtuSize = peer_mtu;
+  }
+
+  //get separation feature.
+  p_encoder_params->isChannelSeparation = A2DP_VendorGetChannelSeparation(p_codec_info);
+  // Set the quality mode index
+  //int old_quality_mode_index = p_encoder_params->quality_mode_index;
+  LOG_DEBUG(LOG_TAG, "%s:codec_config.codec_specific_1 = %d, codec_config.codec_specific_2 = %d", __func__, (int32_t)codec_config.codec_specific_1, (int32_t)codec_config.codec_specific_2);
+  if ((codec_config.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) == A2DP_LHDC_QUALITY_MAGIC_NUM) {
+      //int newValue = codec_config.codec_specific_1 & 0xff;
+      int newValue = codec_config.codec_specific_1 & 0xff;
+
+      // adjust non-supported quality modes and wrap to internal library used index
+      if (newValue == A2DP_LHDC_QUALITY_ABR) {
+        newValue = LHDCBT_QUALITY_AUTO; //9->8
+      } else if (newValue == A2DP_LHDC_QUALITY_HIGH1) {
+        // High1(1000K) does not supported, downgrade to High(900K)
+        newValue = LHDCBT_QUALITY_HIGH; //8->7
+        codec_config.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_HIGH;
+        //codec_config_user.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_HIGH;
+      }
+
+      if (newValue != p_encoder_params->quality_mode_index) {
+
+        p_encoder_params->quality_mode_index = newValue;
+        LOG_DEBUG(LOG_TAG, "%s: setting internal quality mode to %s(%d)", __func__,
+                  quality_mode_index_to_name(p_encoder_params->quality_mode_index)
+                      .c_str(), p_encoder_params->quality_mode_index);
+      }
+  }else {
+      p_encoder_params->quality_mode_index = LHDCBT_QUALITY_LOW;
+      codec_config.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
+      //codec_config_user.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
+  }
+  if (p_encoder_params->isChannelSeparation && p_encoder_params->quality_mode_index >= LHDCBT_QUALITY_HIGH) {
+      /* code */
+      LOG_DEBUG(LOG_TAG, "%s: Channel separation enabled, Max bit rate = LHDCBT_QUALITY_MID", __func__);
+      p_encoder_params->quality_mode_index = LHDCBT_QUALITY_MID;
+  }
+
+  //p_encoder_params->latency_mode_index = 1;
+  if ((codec_config.codec_specific_2 & A2DP_LHDC_VENDOR_CMD_MASK) == A2DP_LHDC_LATENCY_MAGIC_NUM) {
+      int newValue = codec_config.codec_specific_2 & 0xff;
+      if (newValue != p_encoder_params->latency_mode_index) {
+          /* code */
+          p_encoder_params->latency_mode_index = newValue;
+          LOG_DEBUG(LOG_TAG, "%s: setting latency value to %s(%d)", __func__,
+                    latency_mode_index_to_name(p_encoder_params->latency_mode_index).c_str(),
+                    p_encoder_params->latency_mode_index);
+      }
+  }else {
+      p_encoder_params->latency_mode_index = A2DP_LHDC_LATENCY_MID;
+  }
+
+  p_encoder_params->pcm_wlength =
+      a2dp_lhdcV1_encoder_cb.feeding_params.bits_per_sample >> 3;
+  // Set the Audio format from pcm_wlength
+  p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S16;
+  if (p_encoder_params->pcm_wlength == 2)
+    p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S16;
+  else if (p_encoder_params->pcm_wlength == 3)
+    p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S24;
+
+  LOG_DEBUG(LOG_TAG, "%s: MTU=%d, peer_mtu=%d", __func__,
+            a2dp_lhdcV1_encoder_cb.TxAaMtuSize, peer_mtu);
+  LOG_DEBUG(LOG_TAG,
+            "%s: sample_rate: %d channel_mode: %d "
+            "quality_mode_index: %d pcm_wlength: %d pcm_fmt: %d",
+            __func__, p_encoder_params->sample_rate,
+            p_encoder_params->channel_mode,
+            p_encoder_params->quality_mode_index, p_encoder_params->pcm_wlength,
+            p_encoder_params->pcm_fmt);
+/*
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdcV1_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN - 1);
+#else
+    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdcV1_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN);
+#endif
+*/
+  // Initialize the encoder.
+  // NOTE: MTU in the initialization must include the AVDT media header size.
+  int result = lhdcV1_init_handle_encode_func(
+      a2dp_lhdcV1_encoder_cb.lhdcV1_handle,
+      p_encoder_params->sample_rate,
+      p_encoder_params->pcm_fmt,
+      p_encoder_params->quality_mode_index,
+      p_encoder_params->isChannelSeparation == true ? 1 : 0,
+      0 /* This parameter alaways is 0 in A2DP */,
+      0,
+      a2dp_vendor_lhdcV1_get_encoder_interval_ms()
+  );
+  lhdcV1_set_bitrate_func(a2dp_lhdcV1_encoder_cb.lhdcV1_handle, p_encoder_params->quality_mode_index);
+
+#if defined(RecFile)
+  if (RecFile == NULL) {
+      /* code */
+      RecFile = fopen("/sdcard/Download/lhdc.raw","wb");
+  }
+#endif
+  if (result != 0) {
+    LOG_ERROR(LOG_TAG, "%s: error initializing the LHDC encoder: %d", __func__,
+              result);
+  }
+}
+
+void a2dp_vendor_lhdcV1_encoder_cleanup(void) {
+  if (a2dp_lhdcV1_encoder_cb.has_lhdcV1_handle)
+    lhdcV1_free_handle_func(a2dp_lhdcV1_encoder_cb.lhdcV1_handle);
+  memset(&a2dp_lhdcV1_encoder_cb, 0, sizeof(a2dp_lhdcV1_encoder_cb));
+#if defined(RecFile)
+  if (RecFile != NULL) {
+      fclose(RecFile);
+      RecFile = NULL;
+  }
+#endif
+}
+
+void a2dp_vendor_lhdcV1_feeding_reset(void) {
+  /* By default, just clear the entire state */
+  memset(&a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state, 0,
+         sizeof(a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state));
+
+  a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.bytes_per_tick =
+      (a2dp_lhdcV1_encoder_cb.feeding_params.sample_rate *
+       a2dp_lhdcV1_encoder_cb.feeding_params.bits_per_sample / 8 *
+       a2dp_lhdcV1_encoder_cb.feeding_params.channel_count *
+       A2DP_LHDCV1_ENCODER_INTERVAL_MS) /
+      1000;
+  a2dp_lhdcV1_encoder_cb.buf_seq = 0;
+  LOG_DEBUG(LOG_TAG, "%s: PCM bytes per tick %u", __func__,
+            a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.bytes_per_tick);
+}
+
+void a2dp_vendor_lhdcV1_feeding_flush(void) {
+  a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.counter = 0;
+  LOG_DEBUG(LOG_TAG, "%s", __func__);
+}
+
+uint64_t a2dp_vendor_lhdcV1_get_encoder_interval_ms(void) {
+  LOG_DEBUG(LOG_TAG, "%s: A2DP_LHDCV1_ENCODER_INTERVAL_MS %u",
+              __func__, A2DP_LHDCV1_ENCODER_INTERVAL_MS);
+  return A2DP_LHDCV1_ENCODER_INTERVAL_MS;
+}
+
+void a2dp_vendor_lhdcV1_send_frames(uint64_t timestamp_us) {
+  uint8_t nb_frame = 0;
+  uint8_t nb_iterations = 0;
+
+  a2dp_lhdcV1_get_num_frame_iteration(&nb_iterations, &nb_frame, timestamp_us);
+  LOG_DEBUG(LOG_TAG, "%s: Sending %d frames per iteration, %d iterations",
+              __func__, nb_frame, nb_iterations);
+  if (nb_frame == 0) return;
+
+  for (uint8_t counter = 0; counter < nb_iterations; counter++) {
+    // Transcode frame and enqueue
+    a2dp_lhdcV1_encode_frames(nb_frame);
+  }
+}
+
+// Obtains the number of frames to send and number of iterations
+// to be used. |num_of_iterations| and |num_of_frames| parameters
+// are used as output param for returning the respective values.
+static void a2dp_lhdcV1_get_num_frame_iteration(uint8_t* num_of_iterations,
+                                              uint8_t* num_of_frames,
+                                              uint64_t timestamp_us) {
+  uint32_t result = 0;
+  uint8_t nof = 0;
+  uint8_t noi = 1;
+
+  uint32_t pcm_bytes_per_frame =
+      A2DP_LHDCV1_SAMPLES_PER_FRAME *
+      a2dp_lhdcV1_encoder_cb.feeding_params.channel_count *
+      a2dp_lhdcV1_encoder_cb.feeding_params.bits_per_sample / 8;
+  LOG_DEBUG(LOG_TAG, "%s: pcm_bytes_per_frame %u", __func__,
+              pcm_bytes_per_frame);
+
+  uint32_t us_this_tick = A2DP_LHDCV1_ENCODER_INTERVAL_MS * 1000;
+  uint64_t now_us = timestamp_us;
+  if (a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.last_frame_us != 0)
+    us_this_tick =
+        (now_us - a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.last_frame_us);
+  a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.last_frame_us = now_us;
+
+  a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.counter +=
+      a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.bytes_per_tick * us_this_tick /
+      (A2DP_LHDCV1_ENCODER_INTERVAL_MS * 1000);
+
+  result =
+      a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.counter / pcm_bytes_per_frame;
+  a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.counter -=
+      result * pcm_bytes_per_frame;
+  nof = result;
+
+  LOG_DEBUG(LOG_TAG, "%s: effective num of frames %u, iterations %u",
+              __func__, nof, noi);
+
+  *num_of_frames = nof;
+  *num_of_iterations = noi;
+}
+
+static BT_HDR *bt_buf_new( void) {
+    BT_HDR *p_buf = ( BT_HDR*)osi_malloc( BT_DEFAULT_BUFFER_SIZE);
+    if ( p_buf == NULL) {
+        // LeoKu(C): should not happen
+        LOG_ERROR( LOG_TAG, "%s: bt_buf_new failed!", __func__);
+        return  NULL;
+    }
+
+    p_buf->offset = A2DP_LHDCV1_OFFSET;
+    p_buf->len = 0;
+    p_buf->layer_specific = 0;
+    return  p_buf;
+}
+
+#include <vector>
+using namespace std;
+static void a2dp_lhdcV1_encode_frames(uint8_t nb_frame) {
+    BT_HDR * p_buf = NULL;
+    //BT_HDR * p_btBufs[128];
+    vector<BT_HDR * > btBufs;
+    uint8_t nb_frame_org = nb_frame;
+    tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params =
+        &a2dp_lhdcV1_encoder_cb.lhdcV1_encoder_params;
+    uint32_t pcm_bytes_per_frame = LHDCV1_BT_ENC_BLOCK_SIZE *
+                                 a2dp_lhdcV1_encoder_cb.feeding_params.channel_count *
+                                 a2dp_lhdcV1_encoder_cb.feeding_params.bits_per_sample / 8;
+
+
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdcV1_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN - 1);
+#else
+    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdcV1_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN);
+#endif
+    uint8_t * read_buffer = (uint8_t*)malloc(pcm_bytes_per_frame * 2);
+    uint8_t * write_buffer = (uint8_t*)&(read_buffer[pcm_bytes_per_frame]);
+    uint8_t latency = p_encoder_params->latency_mode_index;
+    int out_offset = 0;
+    int out_len = 0;
+    static uint32_t time_prev = bluetooth::common::time_get_os_boottime_ms();
+    static uint32_t allSendbytes = 0;
+
+    //if (!p_encoder_params->isChannelSeparation) {
+        while( nb_frame) {
+            if ( !a2dp_lhdcV1_read_feeding(read_buffer)) {
+            LOG_WARN(LOG_TAG, "%s: underflow %d", __func__, nb_frame);
+            a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.counter +=
+                      nb_frame * LHDCV1_BT_ENC_BLOCK_SIZE *
+                      a2dp_lhdcV1_encoder_cb.feeding_params.channel_count *
+                      a2dp_lhdcV1_encoder_cb.feeding_params.bits_per_sample / 8;
+                break;
+            }
+
+            out_offset = 0;
+            out_len = lhdcV1_encode_func(a2dp_lhdcV1_encoder_cb.lhdcV1_handle, read_buffer, write_buffer);
+    #if defined(RecFile)
+            if (RecFile != NULL && out_len > 0) {
+                fwrite(write_buffer, sizeof(uint8_t), out_len, RecFile);
+            }
+    #endif
+
+            nb_frame--;
+
+            while (out_len > 0) {
+                if (p_buf == NULL) {
+                    if (NULL == (p_buf = bt_buf_new())) {
+                        LOG_ERROR (LOG_TAG, "%s: ERROR", __func__);
+                        if (read_buffer) {
+                            free(read_buffer);
+                            read_buffer = NULL;
+                        }
+                        for(BT_HDR*  p : btBufs) {
+                            free(p);
+                        }
+                        btBufs.clear();
+                        return;
+                    }
+                }
+
+                uint8_t *p = ( uint8_t *)( p_buf + 1) + p_buf->offset + p_buf->len;
+                int space = max_mtu_len - p_buf->len;
+                int bytes = ( out_len < space)? out_len : space;
+                memcpy( p, &write_buffer[out_offset], bytes);
+                out_offset += bytes;
+                out_len -= bytes;
+                p_buf->len += bytes;
+                allSendbytes += bytes;
+
+                if ( p_buf->len >= max_mtu_len ) {
+                    btBufs.push_back(p_buf);
+                    // allocate new one
+                    p_buf = NULL;
+                    if (btBufs.size() >= 64) {
+                        LOG_ERROR(LOG_TAG, "%s: Packet buffer usage to big!(%u)", __func__, (uint32_t)btBufs.size());
+                        break;
+                    }
+                }
+            }
+        }
+        uint32_t now_ms = bluetooth::common::time_get_os_boottime_ms();
+        if (now_ms - time_prev >= 1000 ) {
+            /* code */
+            LOG_WARN(LOG_TAG, "%s: Current data rate about %d kbps", __func__, (allSendbytes * 8) / 1000);
+            allSendbytes = 0;
+            time_prev = now_ms;
+        }
+
+        if ( p_buf) {
+            btBufs.push_back(p_buf);
+        }
+
+        LOG_DEBUG(LOG_TAG, "%s:btBufs.size() = %u", __func__, (uint32_t)btBufs.size());
+        if ( btBufs.size() == 1) {
+            p_buf = btBufs[0];
+
+            p_buf->layer_specific = a2dp_lhdcV1_encoder_cb.buf_seq++;
+            p_buf->layer_specific <<= 8;
+            p_buf->layer_specific |= ( latency | ( nb_frame_org << A2DP_LHDC_HDR_NUM_SHIFT));
+
+            *( ( uint32_t*)( p_buf + 1)) = a2dp_lhdcV1_encoder_cb.timestamp;
+
+            a2dp_lhdcV1_encoder_cb.enqueue_callback( p_buf, 1, p_buf->len);
+
+        } else {
+
+            uint8_t i;
+
+            if (btBufs.size() > 16) {
+                LOG_DEBUG(LOG_TAG, "%s:btBufs.size() = %u", __func__, (uint32_t)btBufs.size());
+            }
+
+            for( i = 0; i < btBufs.size(); i++) {
+                p_buf = btBufs[i];
+
+                p_buf->layer_specific = a2dp_lhdcV1_encoder_cb.buf_seq++;
+                p_buf->layer_specific <<= 8;
+                p_buf->layer_specific |= ( A2DP_LHDC_HDR_F_MSK | latency);
+
+                if ( i == 0) {
+                    p_buf->layer_specific |= ( A2DP_LHDC_HDR_S_MSK | ( nb_frame_org << A2DP_LHDC_HDR_NUM_SHIFT));
+                } else if ( i == ( btBufs.size() - 1)) {
+                    p_buf->layer_specific |= A2DP_LHDC_HDR_L_MSK;
+                }
+
+                *( ( uint32_t*)( p_buf + 1)) = a2dp_lhdcV1_encoder_cb.timestamp;
+
+                a2dp_lhdcV1_encoder_cb.enqueue_callback( p_buf, 1, p_buf->len);
+            }
+        }
+
+        a2dp_lhdcV1_encoder_cb.timestamp += ( nb_frame_org * LHDCV1_BT_ENC_BLOCK_SIZE);
+        if (read_buffer) {
+            free(read_buffer);
+            read_buffer = NULL;
+        }
+        btBufs.clear();
+}
+
+static bool a2dp_lhdcV1_read_feeding(uint8_t* read_buffer) {
+  uint32_t read_size = LHDCV1_BT_ENC_BLOCK_SIZE *
+                       a2dp_lhdcV1_encoder_cb.feeding_params.channel_count *
+                       a2dp_lhdcV1_encoder_cb.feeding_params.bits_per_sample / 8;
+
+  a2dp_lhdcV1_encoder_cb.stats.media_read_total_expected_reads_count++;
+  a2dp_lhdcV1_encoder_cb.stats.media_read_total_expected_read_bytes += read_size;
+
+  /* Read Data from UIPC channel */
+  uint32_t nb_byte_read =
+      a2dp_lhdcV1_encoder_cb.read_callback(read_buffer, read_size);
+  LOG_DEBUG(LOG_TAG, "%s: want to read size %u, read byte number %u",
+                    __func__, read_size, nb_byte_read);
+  a2dp_lhdcV1_encoder_cb.stats.media_read_total_actual_read_bytes += nb_byte_read;
+
+  if (nb_byte_read < read_size) {
+    if (nb_byte_read == 0) return false;
+
+    /* Fill the unfilled part of the read buffer with silence (0) */
+    memset(((uint8_t*)read_buffer) + nb_byte_read, 0, read_size - nb_byte_read);
+    nb_byte_read = read_size;
+  }
+  a2dp_lhdcV1_encoder_cb.stats.media_read_total_actual_reads_count++;
+
+  return true;
+}
+
+static std::string quality_mode_index_to_name(int quality_mode_index) {
+  switch (quality_mode_index) {
+    case LHDCBT_QUALITY_HIGH:
+      return "HIGH";
+    case LHDCBT_QUALITY_MID:
+      return "MID";
+    case LHDCBT_QUALITY_LOW:
+      return "LOW";
+    case LHDCBT_QUALITY_AUTO:
+      return "ABR";
+    default:
+      return "Unknown";
+  }
+}
+
+static std::string latency_mode_index_to_name(int latency_mode_index){
+    switch (latency_mode_index) {
+        case A2DP_LHDC_LATENCY_HIGH:
+            return "Long Latency";
+        case A2DP_LHDC_LATENCY_MID:
+            return "Middle Latency";
+        case A2DP_LHDC_LATENCY_LOW:
+            return "Short Latency";
+        default:
+            return "Unknown";
+    }
+}
+
+void a2dp_vendor_lhdcV1_set_transmit_queue_length(size_t transmit_queue_length) {
+  a2dp_lhdcV1_encoder_cb.TxQueueLength = transmit_queue_length;
+  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params = &a2dp_lhdcV1_encoder_cb.lhdcV1_encoder_params;
+  LOG_DEBUG(LOG_TAG, "%s: transmit_queue_length %zu", __func__, transmit_queue_length);
+  if (p_encoder_params->quality_mode_index == LHDCBT_QUALITY_AUTO) {
+      LOG_DEBUG(LOG_TAG, "%s: Auto Bitrate Enabled!", __func__);
+      if (lhdcV1_auto_adjust_bitrate_func != NULL) {
+          lhdcV1_auto_adjust_bitrate_func(a2dp_lhdcV1_encoder_cb.lhdcV1_handle, transmit_queue_length);
+      }
+  }
+}
+
+uint64_t A2dpCodecConfigLhdcV1::encoderIntervalMs() const {
+  return a2dp_vendor_lhdcV1_get_encoder_interval_ms();
+}
+
+int A2dpCodecConfigLhdcV1::getEffectiveMtu() const {
+  return a2dp_lhdcV1_encoder_cb.TxAaMtuSize;
+}
+
+void A2dpCodecConfigLhdcV1::debug_codec_dump(int fd) {
+  a2dp_lhdcV1_encoder_stats_t* stats = &a2dp_lhdcV1_encoder_cb.stats;
+  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params =
+      &a2dp_lhdcV1_encoder_cb.lhdcV1_encoder_params;
+
+  A2dpCodecConfig::debug_codec_dump(fd);
+
+  dprintf(fd,
+          "  Packet counts (expected/dropped)                        : %zu / "
+          "%zu\n",
+          stats->media_read_total_expected_packets,
+          stats->media_read_total_dropped_packets);
+
+  dprintf(fd,
+          "  PCM read counts (expected/actual)                       : %zu / "
+          "%zu\n",
+          stats->media_read_total_expected_reads_count,
+          stats->media_read_total_actual_reads_count);
+
+  dprintf(fd,
+          "  PCM read bytes (expected/actual)                        : %zu / "
+          "%zu\n",
+          stats->media_read_total_expected_read_bytes,
+          stats->media_read_total_actual_read_bytes);
+
+  dprintf(
+      fd, "  LHDC quality mode                                       : %s\n",
+      quality_mode_index_to_name(p_encoder_params->quality_mode_index).c_str());
+
+  dprintf(fd,
+          "  LHDC transmission bitrate (Kbps)                        : %d\n",
+          lhdcV1_get_bitrate_func(a2dp_lhdcV1_encoder_cb.lhdcV1_handle));
+
+  dprintf(fd,
+          "  LHDC saved transmit queue length                        : %zu\n",
+          a2dp_lhdcV1_encoder_cb.TxQueueLength);
+/*
+  if (a2dp_lhdcV1_encoder_cb.has_lhdcV1_abr_handle) {
+    dprintf(fd,
+            "  LHDC adaptive bit rate encode quality mode index        : %d\n",
+            a2dp_lhdcV1_encoder_cb.last_lhdcV1_abr_eqmid);
+    dprintf(fd,
+            "  LHDC adaptive bit rate adjustments                      : %zu\n",
+            a2dp_lhdcV1_encoder_cb.lhdcV1_abr_adjustments);
+  }
+  */
+}
diff --git a/system/bt/stack/a2dp/a2dp_vendor_lhdcv2.cc b/system/bt/stack/a2dp/a2dp_vendor_lhdcv2.cc
new file mode 100755
index 00000000..1b5863b7
--- /dev/null
+++ b/system/bt/stack/a2dp/a2dp_vendor_lhdcv2.cc
@@ -0,0 +1,1430 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/******************************************************************************
+ *
+ *  Utility functions to help build and parse the LHDC Codec Information
+ *  Element and Media Payload.
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "a2dp_vendor_lhdcv2"
+
+#include "bt_target.h"
+
+#include "a2dp_vendor_lhdcv2.h"
+
+#include <string.h>
+
+#include <base/logging.h>
+#include "a2dp_vendor.h"
+#include "a2dp_vendor_lhdcv2_encoder.h"
+#include "bt_utils.h"
+#include "btif_av_co.h"
+#include "osi/include/log.h"
+#include "osi/include/osi.h"
+
+// data type for the LHDC Codec Information Element */
+// NOTE: bits_per_sample is needed only for LHDC encoder initialization.
+typedef struct {
+  uint32_t vendorId;
+  uint16_t codecId;    /* Codec ID for LHDC */
+  uint8_t sampleRate;  /* Sampling Frequency */
+  btav_a2dp_codec_bits_per_sample_t bits_per_sample;
+  uint8_t channelSplitMode;
+  uint8_t version;
+  uint8_t maxTargetBitrate;
+  bool isLLSupported;
+} tA2DP_LHDC_CIE;
+
+/* LHDC Source codec capabilities */
+static const tA2DP_LHDC_CIE a2dp_lhdc_source_caps = {
+    A2DP_LHDC_VENDOR_ID,  // vendorId
+    A2DP_LHDCV2_CODEC_ID,   // codecId
+    // sampleRate
+    //(A2DP_LHDC_SAMPLING_FREQ_48000),
+    (A2DP_LHDC_SAMPLING_FREQ_44100 | A2DP_LHDC_SAMPLING_FREQ_48000 | A2DP_LHDC_SAMPLING_FREQ_96000),
+    // bits_per_sample
+    (BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16 | BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24),
+    //Channel Separation
+    A2DP_LHDC_CH_SPLIT_NONE | A2DP_LHDC_CH_SPLIT_TWS,
+    //Version number
+    A2DP_LHDC_VER2,
+    //Max target bit Rate
+    A2DP_LHDC_MAX_BIT_RATE_900K,
+    //LL supported ?
+    false,
+};
+    //(BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)};
+
+/* Default LHDC codec configuration */
+static const tA2DP_LHDC_CIE a2dp_lhdc_default_config = {
+    A2DP_LHDC_VENDOR_ID,                // vendorId
+    A2DP_LHDCV2_CODEC_ID,                 // codecId
+    A2DP_LHDC_SAMPLING_FREQ_96000,      // sampleRate
+    BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24,  // bits_per_sample
+    A2DP_LHDC_CH_SPLIT_NONE,
+    A2DP_LHDC_VER2,
+    A2DP_LHDC_MAX_BIT_RATE_900K,
+    false,
+};
+
+static const tA2DP_ENCODER_INTERFACE a2dp_encoder_interface_lhdcv2 = {
+    a2dp_vendor_lhdcv2_encoder_init,
+    a2dp_vendor_lhdcv2_encoder_cleanup,
+    a2dp_vendor_lhdcv2_feeding_reset,
+    a2dp_vendor_lhdcv2_feeding_flush,
+    a2dp_vendor_lhdcv2_get_encoder_interval_ms,
+    a2dp_vendor_lhdcv2_send_frames,
+    a2dp_vendor_lhdcv2_set_transmit_queue_length};
+
+UNUSED_ATTR static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV2(
+    const tA2DP_LHDC_CIE* p_cap, const uint8_t* p_codec_info,
+    bool is_peer_codec_info);
+
+
+// Builds the LHDC Media Codec Capabilities byte sequence beginning from the
+// LOSC octet. |media_type| is the media type |AVDT_MEDIA_TYPE_*|.
+// |p_ie| is a pointer to the LHDC Codec Information Element information.
+// The result is stored in |p_result|. Returns A2DP_SUCCESS on success,
+// otherwise the corresponding A2DP error status code.
+static tA2DP_STATUS A2DP_BuildInfoLhdcV2(uint8_t media_type,
+                                       const tA2DP_LHDC_CIE* p_ie,
+                                       uint8_t* p_result) {
+
+  const uint8_t* tmpInfo = p_result;
+  if (p_ie == NULL || p_result == NULL) {
+    return A2DP_INVALID_PARAMS;
+  }
+
+  *p_result++ = A2DP_LHDCV2_CODEC_LEN;    //0
+  *p_result++ = (media_type << 4);      //1
+  *p_result++ = A2DP_MEDIA_CT_NON_A2DP; //2
+
+  // Vendor ID and Codec ID
+  *p_result++ = (uint8_t)(p_ie->vendorId & 0x000000FF); //3
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0x0000FF00) >> 8);  //4
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0x00FF0000) >> 16); //5
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0xFF000000) >> 24); //6
+  *p_result++ = (uint8_t)(p_ie->codecId & 0x00FF);  //7
+  *p_result++ = (uint8_t)((p_ie->codecId & 0xFF00) >> 8);   //8
+
+  // Sampling Frequency & Bits per sample
+  uint8_t para = 0;
+
+  // sample rate bit0 ~ bit2
+  para = (uint8_t)(p_ie->sampleRate & A2DP_LHDC_SAMPLING_FREQ_MASK);
+
+  if (p_ie->bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24)
+      para |= A2DP_LHDC_BIT_FMT_24;
+  if(p_ie->bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)
+      para |= A2DP_LHDC_BIT_FMT_16;
+
+  // Save octet 9
+  *p_result++ = para;   //9
+
+  para = p_ie->version;
+
+  para |= p_ie->maxTargetBitrate;
+
+  para |= p_ie->isLLSupported ? A2DP_LHDC_LL_SUPPORTED : A2DP_LHDC_LL_NONE;
+
+  // Save octet 10
+  *p_result++ = para;   //a
+
+  //Save octet 11
+  para = p_ie->channelSplitMode;
+
+  *p_result++ = para;   //b
+
+  LOG_DEBUG(LOG_TAG, "%s: Info build result = [0]:0x%x, [1]:0x%x, [2]:0x%x, [3]:0x%x, "
+                     "[4]:0x%x, [5]:0x%x, [6]:0x%x, [7]:0x%x, [8]:0x%x, [9]:0x%x, [10]:0x%x, [11]:0x%x",
+     __func__, tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3],
+                    tmpInfo[4], tmpInfo[5], tmpInfo[6], tmpInfo[7], tmpInfo[8], tmpInfo[9], tmpInfo[10], tmpInfo[11]);
+  return A2DP_SUCCESS;
+}
+
+// Parses the LHDC Media Codec Capabilities byte sequence beginning from the
+// LOSC octet. The result is stored in |p_ie|. The byte sequence to parse is
+// |p_codec_info|. If |is_capability| is true, the byte sequence is
+// codec capabilities, otherwise is codec configuration.
+// Returns A2DP_SUCCESS on success, otherwise the corresponding A2DP error
+// status code.
+static tA2DP_STATUS A2DP_ParseInfoLhdcV2(tA2DP_LHDC_CIE* p_ie,
+                                       const uint8_t* p_codec_info,
+                                       bool is_capability) {
+  uint8_t losc;
+  uint8_t media_type;
+  tA2DP_CODEC_TYPE codec_type;
+  const uint8_t* tmpInfo = p_codec_info;
+
+  //LOG_DEBUG(LOG_TAG, "%s: p_ie = %p, p_codec_info = %p", __func__, p_ie, p_codec_info);
+  if (p_ie == NULL || p_codec_info == NULL) return A2DP_INVALID_PARAMS;
+
+  // Check the codec capability length
+  losc = *p_codec_info++;
+
+  if (losc != A2DP_LHDCV2_CODEC_LEN) return A2DP_WRONG_CODEC;
+
+  media_type = (*p_codec_info++) >> 4;
+  codec_type = *p_codec_info++;
+    //LOG_DEBUG(LOG_TAG, "%s: media_type = %d, codec_type = %d", __func__, media_type, codec_type);
+  /* Check the Media Type and Media Codec Type */
+  if (media_type != AVDT_MEDIA_TYPE_AUDIO ||
+      codec_type != A2DP_MEDIA_CT_NON_A2DP) {
+    return A2DP_WRONG_CODEC;
+  }
+
+  // Check the Vendor ID and Codec ID */
+  p_ie->vendorId = (*p_codec_info & 0x000000FF) |
+                   (*(p_codec_info + 1) << 8 & 0x0000FF00) |
+                   (*(p_codec_info + 2) << 16 & 0x00FF0000) |
+                   (*(p_codec_info + 3) << 24 & 0xFF000000);
+  p_codec_info += 4;
+  p_ie->codecId =
+      (*p_codec_info & 0x00FF) | (*(p_codec_info + 1) << 8 & 0xFF00);
+  p_codec_info += 2;
+  LOG_DEBUG(LOG_TAG, "%s:Vendor(0x%08x), Codec(0x%04x)", __func__, p_ie->vendorId, p_ie->codecId);
+  if (p_ie->vendorId != A2DP_LHDC_VENDOR_ID ||
+      p_ie->codecId != A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_WRONG_CODEC;
+  }
+
+  p_ie->sampleRate = *p_codec_info & A2DP_LHDC_SAMPLING_FREQ_MASK;
+  if ((*p_codec_info & A2DP_LHDC_BIT_FMT_MASK) == 0) {
+    return A2DP_WRONG_CODEC;
+  }
+
+  p_ie->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+  if (*p_codec_info & A2DP_LHDC_BIT_FMT_24)
+    p_ie->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+  if (*p_codec_info & A2DP_LHDC_BIT_FMT_16) {
+    p_ie->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+  }
+
+
+  p_codec_info += 1;
+
+  p_ie->version = (*p_codec_info) & A2DP_LHDC_VERSION_MASK;
+  //p_ie->version = 1;
+
+  p_ie->maxTargetBitrate = (*p_codec_info) & A2DP_LHDC_MAX_BIT_RATE_MASK;
+  //p_ie->maxTargetBitrate = A2DP_LHDC_MAX_BIT_RATE_900K;
+
+  p_ie->isLLSupported = ((*p_codec_info & A2DP_LHDC_LL_MASK) != 0)? true : false;
+  //p_ie->isLLSupported = false;
+
+  p_codec_info += 1;
+
+  p_ie->channelSplitMode = (*p_codec_info) & A2DP_LHDC_CH_SPLIT_MSK;
+  //p_ie->channelSplitMode = A2DP_LHDC_CH_SPLIT_NONE;
+
+
+
+
+    LOG_DEBUG(LOG_TAG, "%s: codec info = [0]:0x%x, [1]:0x%x, [2]:0x%x, [3]:0x%x, [4]:0x%x, [5]:0x%x, [6]:0x%x, [7]:0x%x, [8]:0x%x, [9]:0x%x, [10]:0x%x, [11]:0x%x",
+            __func__, tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3], tmpInfo[4], tmpInfo[5], tmpInfo[6],
+                        tmpInfo[7], tmpInfo[8], tmpInfo[9], tmpInfo[10], tmpInfo[11]);
+
+  if (is_capability) return A2DP_SUCCESS;
+
+  if (A2DP_BitsSet(p_ie->sampleRate) != A2DP_SET_ONE_BIT)
+    return A2DP_BAD_SAMP_FREQ;
+
+  return A2DP_SUCCESS;
+}
+
+// Build the LHDC Media Payload Header.
+// |p_dst| points to the location where the header should be written to.
+// If |frag| is true, the media payload frame is fragmented.
+// |start| is true for the first packet of a fragmented frame.
+// |last| is true for the last packet of a fragmented frame.
+// If |frag| is false, |num| is the number of number of frames in the packet,
+// otherwise is the number of remaining fragments (including this one).
+/*
+static void A2DP_BuildMediaPayloadHeaderLhdc(uint8_t* p, uint16_t num) {
+  if (p == NULL) return;
+  *p = ( uint8_t)( num & 0xff);
+}
+*/
+
+static bool A2DP_MaxBitRatetoQualityLevelLhdcV2(uint8_t *mode, uint8_t bitrate) {
+  if (mode == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return false;
+  }
+
+  switch (bitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) {
+  case A2DP_LHDC_MAX_BIT_RATE_900K:
+    *mode = A2DP_LHDC_QUALITY_HIGH;
+    return true;
+  case A2DP_LHDC_MAX_BIT_RATE_500K:
+    *mode = A2DP_LHDC_QUALITY_MID;
+    return true;
+  case A2DP_LHDC_MAX_BIT_RATE_400K:
+    *mode = A2DP_LHDC_QUALITY_LOW;
+    return true;
+  }
+  return false;
+}
+
+static std::string lhdcV2_QualityModeBitRate_toString(uint8_t value) {
+  switch((int)value)
+  {
+  case A2DP_LHDC_QUALITY_ABR:
+    return "ABR";
+  case A2DP_LHDC_QUALITY_HIGH1:
+    return "HIGH 1 (1000 Kbps)";
+  case A2DP_LHDC_QUALITY_HIGH:
+    return "HIGH (900 Kbps)";
+  case A2DP_LHDC_QUALITY_MID:
+    return "MID (500 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW:
+    return "LOW (400 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW4:
+    return "LOW 4 (320 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW3:
+    return "LOW 3 (256 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW2:
+    return "LOW 2 (192 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW1:
+    return "LOW 1 (128 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW0:
+    return "LOW 0 (64 Kbps)";
+  default:
+    return "Unknown Bit Rate Mode";
+  }
+}
+
+bool A2DP_IsVendorSourceCodecValidLhdcV2(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE cfg_cie;
+
+  /* Use a liberal check when parsing the codec info */
+  return (A2DP_ParseInfoLhdcV2(&cfg_cie, p_codec_info, false) == A2DP_SUCCESS) ||
+         (A2DP_ParseInfoLhdcV2(&cfg_cie, p_codec_info, true) == A2DP_SUCCESS);
+}
+
+bool A2DP_IsVendorPeerSinkCodecValidLhdcV2(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE cfg_cie;
+
+  /* Use a liberal check when parsing the codec info */
+  return (A2DP_ParseInfoLhdcV2(&cfg_cie, p_codec_info, false) == A2DP_SUCCESS) ||
+         (A2DP_ParseInfoLhdcV2(&cfg_cie, p_codec_info, true) == A2DP_SUCCESS);
+}
+
+// Checks whether A2DP LHDC codec configuration matches with a device's codec
+// capabilities. |p_cap| is the LHDC codec configuration. |p_codec_info| is
+// the device's codec capabilities.
+// If |is_capability| is true, the byte sequence is codec capabilities,
+// otherwise is codec configuration.
+// |p_codec_info| contains the codec capabilities for a peer device that
+// is acting as an A2DP source.
+// Returns A2DP_SUCCESS if the codec configuration matches with capabilities,
+// otherwise the corresponding A2DP error status code.
+static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV2(
+    const tA2DP_LHDC_CIE* p_cap, const uint8_t* p_codec_info,
+    bool is_capability) {
+  tA2DP_STATUS status;
+  tA2DP_LHDC_CIE cfg_cie;
+
+  /* parse configuration */
+  status = A2DP_ParseInfoLhdcV2(&cfg_cie, p_codec_info, is_capability);
+  if (status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: parsing failed %d", __func__, status);
+    return status;
+  }
+
+  /* verify that each parameter is in range */
+
+  LOG_DEBUG(LOG_TAG, "%s: FREQ peer: 0x%x, capability 0x%x", __func__,
+            cfg_cie.sampleRate, p_cap->sampleRate);
+
+  LOG_DEBUG(LOG_TAG, "%s: BIT_FMT peer: 0x%x, capability 0x%x", __func__,
+            cfg_cie.bits_per_sample, p_cap->bits_per_sample);
+
+  /* sampling frequency */
+  if ((cfg_cie.sampleRate & p_cap->sampleRate) == 0) return A2DP_NS_SAMP_FREQ;
+
+  /* bit per sample */
+  if ((cfg_cie.bits_per_sample & p_cap->bits_per_sample) == 0) return A2DP_NS_CH_MODE;
+
+  return A2DP_SUCCESS;
+}
+
+bool A2DP_VendorUsesRtpHeaderLhdcV2(UNUSED_ATTR bool content_protection_enabled,
+                                  UNUSED_ATTR const uint8_t* p_codec_info) {
+  // TODO: Is this correct? The RTP header is always included?
+  return true;
+}
+
+const char* A2DP_VendorCodecNameLhdcV2(UNUSED_ATTR const uint8_t* p_codec_info) {
+  return "LHDC V2";
+}
+
+bool A2DP_VendorCodecTypeEqualsLhdcV2(const uint8_t* p_codec_info_a,
+                                    const uint8_t* p_codec_info_b) {
+  tA2DP_LHDC_CIE lhdc_cie_a;
+  tA2DP_LHDC_CIE lhdc_cie_b;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status =
+      A2DP_ParseInfoLhdcV2(&lhdc_cie_a, p_codec_info_a, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return false;
+  }
+  a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie_b, p_codec_info_b, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return false;
+  }
+
+  return true;
+}
+
+bool A2DP_VendorCodecEqualsLhdcV2(const uint8_t* p_codec_info_a,
+                                const uint8_t* p_codec_info_b) {
+  tA2DP_LHDC_CIE lhdc_cie_a;
+  tA2DP_LHDC_CIE lhdc_cie_b;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status =
+      A2DP_ParseInfoLhdcV2(&lhdc_cie_a, p_codec_info_a, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return false;
+  }
+  a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie_b, p_codec_info_b, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return false;
+  }
+
+  return (lhdc_cie_a.sampleRate == lhdc_cie_b.sampleRate) &&
+         (lhdc_cie_a.bits_per_sample == lhdc_cie_b.bits_per_sample);
+}
+
+// Savitech Patch - START  Offload
+int A2DP_VendorGetBitRateLhdcV2(const uint8_t* p_codec_info) {
+
+  A2dpCodecConfig* current_codec = bta_av_get_a2dp_current_codec();
+  btav_a2dp_codec_config_t codec_config_ = current_codec->getCodecConfig();
+
+  if ((codec_config_.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) ==
+      A2DP_LHDC_QUALITY_MAGIC_NUM) {
+    switch ((int)(codec_config_.codec_specific_1 & 0xff)) {
+      case A2DP_LHDC_QUALITY_LOW0:
+        return 64000;
+      case A2DP_LHDC_QUALITY_LOW1:
+        return 128000;
+      case A2DP_LHDC_QUALITY_LOW2:
+        return 192000;
+      case A2DP_LHDC_QUALITY_LOW3:
+        return 256000;
+      case A2DP_LHDC_QUALITY_LOW4:
+        return 320000;
+      case A2DP_LHDC_QUALITY_LOW:
+        return 400000;
+      case A2DP_LHDC_QUALITY_MID:
+        return 600000;
+      case A2DP_LHDC_QUALITY_HIGH:
+        return 900000;
+      case A2DP_LHDC_QUALITY_ABR:
+        return 9999999;
+      case A2DP_LHDC_QUALITY_HIGH1:
+        [[fallthrough]];
+      default:
+        return -1;
+    }
+  }
+  return 400000;
+}
+// Savitech Patch - END
+
+int A2DP_VendorGetTrackSampleRateLhdcV2(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+  switch (lhdc_cie.sampleRate) {
+    case A2DP_LHDC_SAMPLING_FREQ_44100:
+      return 44100;
+    case A2DP_LHDC_SAMPLING_FREQ_48000:
+      return 48000;
+    case A2DP_LHDC_SAMPLING_FREQ_88200:
+      return 88200;
+    case A2DP_LHDC_SAMPLING_FREQ_96000:
+      return 96000;
+  }
+
+  return -1;
+}
+
+int A2DP_VendorGetTrackBitsPerSampleLhdcV2(const uint8_t* p_codec_info) {
+    tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+  switch (lhdc_cie.bits_per_sample) {
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+      return 16;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+      return 24;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
+      return 32;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+      return -1;
+  }
+}
+
+int A2DP_VendorGetTrackChannelCountLhdcV2(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+  return 2;
+}
+
+int A2DP_VendorGetChannelModeCodeLhdcV2(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+  return A2DP_LHDC_CHANNEL_MODE_STEREO;
+}
+
+bool A2DP_VendorGetPacketTimestampLhdcV2(UNUSED_ATTR const uint8_t* p_codec_info,
+                                       const uint8_t* p_data,
+                                       uint32_t* p_timestamp) {
+  // TODO: Is this function really codec-specific?
+  *p_timestamp = *(const uint32_t*)p_data;
+  return true;
+}
+
+int16_t A2DP_VendorGetMaxDatarateLhdcV2(const uint8_t* p_codec_info){
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie, p_codec_info, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+/*
+#define A2DP_LHDC_MAX_BIT_RATE_900K       0x00
+#define A2DP_LHDC_MAX_BIT_RATE_500K       0x10
+#define A2DP_LHDC_MAX_BIT_RATE_400K       0x20
+
+#define A2DP_LHDC_QUALITY_HIGH   7  // Equal to LHDCBT_EQMID_HQ 900kbps
+#define A2DP_LHDC_QUALITY_MID    6   // Equal to LHDCBT_EQMID_SQ 500/560kbps
+#define A2DP_LHDC_QUALITY_LOW    5   // Equal to LHDCBT_EQMID_MQ 400kbps
+*/
+  switch (lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) {
+      case A2DP_LHDC_MAX_BIT_RATE_900K:
+      return A2DP_LHDC_QUALITY_HIGH;
+      case A2DP_LHDC_MAX_BIT_RATE_500K:
+      return A2DP_LHDC_QUALITY_MID;
+      case A2DP_LHDC_MAX_BIT_RATE_400K:
+      return A2DP_LHDC_QUALITY_LOW;
+  }
+  return -1;
+}
+
+bool A2DP_VendorGetLowLatencyStateLhdcV2(const uint8_t* p_codec_info){
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+  LOG_INFO(LOG_TAG, "%s: isLLSupported =%d", __func__, lhdc_cie.isLLSupported);
+
+  return lhdc_cie.isLLSupported ? true : false;
+}
+
+uint8_t A2DP_VendorGetVersionLhdcV2(const uint8_t* p_codec_info){
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+  LOG_INFO(LOG_TAG, "%s: version =%d", __func__, lhdc_cie.version);
+
+  return lhdc_cie.version;
+}
+
+
+int8_t A2DP_VendorGetChannelSplitModeLhdcV2(const uint8_t* p_codec_info){
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+  LOG_INFO(LOG_TAG, "%s: channelSplitMode =%d", __func__, lhdc_cie.channelSplitMode);
+
+  return lhdc_cie.channelSplitMode;
+}
+
+bool A2DP_VendorBuildCodecHeaderLhdcV2(UNUSED_ATTR const uint8_t* p_codec_info,
+                                     BT_HDR* p_buf,
+                                     uint16_t frames_per_packet) {
+  uint8_t* p;
+
+  p_buf->offset -= A2DP_LHDC_MPL_HDR_LEN;
+  p = (uint8_t*)(p_buf + 1) + p_buf->offset;
+  p_buf->len += A2DP_LHDC_MPL_HDR_LEN;
+  p[0] = ( uint8_t)( frames_per_packet & 0xff);
+  p[1] = ( uint8_t)( ( frames_per_packet >> 8) & 0xff);
+  //A2DP_BuildMediaPayloadHeaderLhdc(p, frames_per_packet);
+  return true;
+}
+
+void A2DP_VendorDumpCodecInfoLhdcV2(const uint8_t* p_codec_info) {
+  tA2DP_STATUS a2dp_status;
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  LOG_DEBUG(LOG_TAG, "%s", __func__);
+
+  a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie, p_codec_info, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: A2DP_ParseInfoLhdcV2 fail:%d", __func__, a2dp_status);
+    return;
+  }
+
+  LOG_DEBUG(LOG_TAG, "\tsamp_freq: 0x%x", lhdc_cie.sampleRate);
+  if (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+    LOG_DEBUG(LOG_TAG, "\tsamp_freq: (44100)");
+  }
+  if (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+    LOG_DEBUG(LOG_TAG, "\tsamp_freq: (48000)");
+  }
+  if (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+    LOG_DEBUG(LOG_TAG, "\tsamp_freq: (88200)");
+  }
+  if (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+    LOG_DEBUG(LOG_TAG, "\tsamp_freq: (96000)");
+  }
+}
+
+std::string A2DP_VendorCodecInfoStringLhdcV2(const uint8_t* p_codec_info) {
+  std::stringstream res;
+  std::string field;
+  tA2DP_STATUS a2dp_status;
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie, p_codec_info, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    res << "A2DP_ParseInfoLhdcV2 fail: " << loghex(a2dp_status);
+    return res.str();
+  }
+
+  res << "\tname: LHDC\n";
+
+  // Sample frequency
+  field.clear();
+  AppendField(&field, (lhdc_cie.sampleRate == 0), "NONE");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100),
+              "44100");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000),
+              "48000");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200),
+              "88200");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000),
+              "96000");
+  res << "\tsamp_freq: " << field << " (" << loghex(lhdc_cie.sampleRate)
+      << ")\n";
+
+  // Channel mode
+  field.clear();
+  AppendField(&field, 1,
+             "Stereo");
+  res << "\tch_mode: " << field << " (" << "Only support stereo."
+      << ")\n";
+
+  // bits per sample
+  field.clear();
+  AppendField(&field, (lhdc_cie.bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16),
+              "16");
+  AppendField(&field, (lhdc_cie.bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24),
+              "24");
+  res << "\tbits_depth: " << field << " bits (" << loghex((int)lhdc_cie.bits_per_sample)
+      << ")\n";
+
+  // Max data rate...
+  field.clear();
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_900K),
+              "900Kbps");
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_500K),
+              "500Kbps");
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_400K),
+              "400Kbps");
+  res << "\tMax target-rate: " << field << " (" << loghex((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK))
+      << ")\n";
+
+  // Version
+  field.clear();
+  AppendField(&field, (lhdc_cie.version <= A2DP_LHDC_VER2),
+              "LHDC V2");
+  res << "\tversion: " << field << " (" << loghex(lhdc_cie.version)
+      << ")\n";
+
+
+  /*
+  field.clear();
+  AppendField(&field, 0, "NONE");
+  AppendField(&field, 0,
+              "Mono");
+  AppendField(&field, 0,
+              "Dual");
+  AppendField(&field, 1,
+              "Stereo");
+  res << "\tch_mode: " << field << " (" << loghex(lhdc_cie.channelMode)
+      << ")\n";
+*/
+  return res.str();
+}
+
+const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterfaceLhdcV2(
+    const uint8_t* p_codec_info) {
+  if (!A2DP_IsVendorSourceCodecValidLhdcV2(p_codec_info)) return NULL;
+
+  return &a2dp_encoder_interface_lhdcv2;
+}
+
+bool A2DP_VendorAdjustCodecLhdcV2(uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE cfg_cie;
+
+  // Nothing to do: just verify the codec info is valid
+  if (A2DP_ParseInfoLhdcV2(&cfg_cie, p_codec_info, true) != A2DP_SUCCESS)
+    return false;
+
+  return true;
+}
+
+btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndexLhdcV2(
+    UNUSED_ATTR const uint8_t* p_codec_info) {
+  return BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2;
+}
+
+const char* A2DP_VendorCodecIndexStrLhdcV2(void) { return "LHDC V2"; }
+
+bool A2DP_VendorInitCodecConfigLhdcV2(AvdtpSepConfig* p_cfg) {
+  if (A2DP_BuildInfoLhdcV2(AVDT_MEDIA_TYPE_AUDIO, &a2dp_lhdc_source_caps,
+                         p_cfg->codec_info) != A2DP_SUCCESS) {
+    return false;
+  }
+
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+  /* Content protection info - support SCMS-T */
+  uint8_t* p = p_cfg->protect_info;
+  *p++ = AVDT_CP_LOSC;
+  UINT16_TO_STREAM(p, AVDT_CP_SCMS_T_ID);
+  p_cfg->num_protect = 1;
+#endif
+
+  return true;
+}
+
+UNUSED_ATTR static void build_codec_config(const tA2DP_LHDC_CIE& config_cie,
+                                           btav_a2dp_codec_config_t* result) {
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+
+  result->bits_per_sample = config_cie.bits_per_sample;
+
+  result->channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+}
+
+A2dpCodecConfigLhdcV2::A2dpCodecConfigLhdcV2(
+    btav_a2dp_codec_priority_t codec_priority)
+    : A2dpCodecConfig(BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2, "LHDC V2",
+                      codec_priority) {
+  // Compute the local capability
+  if (a2dp_lhdc_source_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+  }
+  if (a2dp_lhdc_source_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+  }
+  if (a2dp_lhdc_source_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+  }
+  if (a2dp_lhdc_source_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+  }
+  codec_local_capability_.bits_per_sample = a2dp_lhdc_source_caps.bits_per_sample;
+
+  codec_local_capability_.channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+}
+
+A2dpCodecConfigLhdcV2::~A2dpCodecConfigLhdcV2() {}
+
+bool A2dpCodecConfigLhdcV2::init() {
+  if (!isValid()) return false;
+
+  // Load the encoder
+  if (!A2DP_VendorLoadEncoderLhdcV2()) {
+    LOG_ERROR(LOG_TAG, "%s: cannot load the encoder", __func__);
+    return false;
+  }
+
+  return true;
+}
+
+bool A2dpCodecConfigLhdcV2::useRtpHeaderMarkerBit() const { return false; }
+
+//
+// Selects the best sample rate from |sampleRate|.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_best_sample_rate(uint8_t sampleRate,
+                                    tA2DP_LHDC_CIE* p_result,
+                                    btav_a2dp_codec_config_t* p_codec_config) {
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+    return true;
+  }
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+    return true;
+  }
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    return true;
+  }
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    return true;
+  }
+  return false;
+}
+
+//
+// Selects the audio sample rate from |p_codec_audio_config|.
+// |sampleRate| contains the capability.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_audio_sample_rate(
+    const btav_a2dp_codec_config_t* p_codec_audio_config, uint8_t sampleRate,
+    tA2DP_LHDC_CIE* p_result, btav_a2dp_codec_config_t* p_codec_config) {
+  switch (p_codec_audio_config->sample_rate) {
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
+        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
+        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
+        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_16000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_24000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
+      break;
+  }
+  return false;
+}
+
+//
+// Selects the best bits per sample from |bits_per_sample|.
+// |bits_per_sample| contains the capability.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_best_bits_per_sample(
+    btav_a2dp_codec_bits_per_sample_t bits_per_sample, tA2DP_LHDC_CIE* p_result,
+    btav_a2dp_codec_config_t* p_codec_config) {
+  if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+    p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+    return true;
+  }
+  if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    return true;
+  }
+  return false;
+}
+
+//
+// Selects the audio bits per sample from |p_codec_audio_config|.
+// |bits_per_sample| contains the capability.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_audio_bits_per_sample(
+    const btav_a2dp_codec_config_t* p_codec_audio_config,
+    btav_a2dp_codec_bits_per_sample_t bits_per_sample, tA2DP_LHDC_CIE* p_result,
+    btav_a2dp_codec_config_t* p_codec_config) {
+  switch (p_codec_audio_config->bits_per_sample) {
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+        p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+        p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+        p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+        p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+      break;
+  }
+  return false;
+}
+
+bool A2dpCodecConfigLhdcV2::copySinkCapability(uint8_t * codec_info){
+    std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
+    memcpy(codec_info, ota_codec_peer_capability_, AVDT_CODEC_SIZE);
+    return true;
+}
+
+bool A2dpCodecConfigLhdcV2::setCodecConfig(const uint8_t* p_peer_codec_info,
+                                         bool is_capability,
+                                         uint8_t* p_result_codec_config) {
+  std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
+  tA2DP_LHDC_CIE sink_info_cie;
+  tA2DP_LHDC_CIE result_config_cie;
+  uint8_t sampleRate;
+  uint8_t qualityMode = 0;
+  uint8_t bitRateQmode = 0;
+  bool isLLEnabled;
+  btav_a2dp_codec_bits_per_sample_t bits_per_sample;
+
+  // Save the internal state
+  btav_a2dp_codec_config_t saved_codec_config = codec_config_;
+  btav_a2dp_codec_config_t saved_codec_capability = codec_capability_;
+  btav_a2dp_codec_config_t saved_codec_selectable_capability =
+      codec_selectable_capability_;
+  btav_a2dp_codec_config_t saved_codec_user_config = codec_user_config_;
+  btav_a2dp_codec_config_t saved_codec_audio_config = codec_audio_config_;
+  uint8_t saved_ota_codec_config[AVDT_CODEC_SIZE];
+  uint8_t saved_ota_codec_peer_capability[AVDT_CODEC_SIZE];
+  uint8_t saved_ota_codec_peer_config[AVDT_CODEC_SIZE];
+  memcpy(saved_ota_codec_config, ota_codec_config_, sizeof(ota_codec_config_));
+  memcpy(saved_ota_codec_peer_capability, ota_codec_peer_capability_,
+         sizeof(ota_codec_peer_capability_));
+  memcpy(saved_ota_codec_peer_config, ota_codec_peer_config_,
+         sizeof(ota_codec_peer_config_));
+
+  tA2DP_STATUS status =
+      A2DP_ParseInfoLhdcV2(&sink_info_cie, p_peer_codec_info, is_capability);
+  if (status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: can't parse peer's Sink capabilities: error = %d",
+              __func__, status);
+    goto fail;
+  }
+
+  //
+  // Build the preferred configuration
+  //
+  memset(&result_config_cie, 0, sizeof(result_config_cie));
+  result_config_cie.vendorId = a2dp_lhdc_source_caps.vendorId;
+  result_config_cie.codecId = a2dp_lhdc_source_caps.codecId;
+
+  if (sink_info_cie.version > a2dp_lhdc_source_caps.version) {
+    LOG_ERROR(LOG_TAG, "%s: Sink capbility version miss match! peer(%d), host(%d)",
+              __func__, sink_info_cie.version, a2dp_lhdc_source_caps.version);
+    goto fail;
+  }
+
+  result_config_cie.version = sink_info_cie.version;
+
+  if (sink_info_cie.channelSplitMode & A2DP_LHDC_CH_SPLIT_TWS) {
+      result_config_cie.channelSplitMode = A2DP_LHDC_CH_SPLIT_TWS;
+  }else{
+      result_config_cie.channelSplitMode = A2DP_LHDC_CH_SPLIT_NONE;
+  }
+
+
+  isLLEnabled = (a2dp_lhdc_source_caps.isLLSupported & sink_info_cie.isLLSupported);
+  result_config_cie.isLLSupported = false;
+  switch (codec_user_config_.codec_specific_2 & 0x1ULL) {
+    case A2DP_LHDC_LL_ENABLE:
+    if (isLLEnabled) {
+      result_config_cie.isLLSupported = true;
+      codec_config_.codec_specific_2 |= 0x1ULL;
+    }
+    break;
+    case A2DP_LHDC_LL_DISABLE:
+      result_config_cie.isLLSupported = false;
+      codec_config_.codec_specific_2 &= ~0x1ULL;
+    break;
+  }
+  //result_config_cie.isLLSupported = sink_info_cie.isLLSupported;
+  LOG_ERROR(LOG_TAG, "%s: isLLSupported, Sink(0x%02x) Set(0x%08x), result(0x%02x)", __func__,
+                                sink_info_cie.isLLSupported,
+                                (uint32_t)codec_user_config_.codec_specific_2,
+                                result_config_cie.isLLSupported);
+
+  //
+  // Select the sample frequency
+  //
+  sampleRate = a2dp_lhdc_source_caps.sampleRate & sink_info_cie.sampleRate;
+  LOG_ERROR(LOG_TAG, "%s: samplrate = 0x%x", __func__, sampleRate);
+  codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+  switch (codec_user_config_.sample_rate) {
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
+        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+        codec_config_.sample_rate = codec_user_config_.sample_rate;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+        codec_config_.sample_rate = codec_user_config_.sample_rate;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
+        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+        codec_config_.sample_rate = codec_user_config_.sample_rate;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
+        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+        codec_config_.sample_rate = codec_user_config_.sample_rate;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_16000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_24000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
+      codec_capability_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+      codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+      break;
+  }
+
+  // Select the sample frequency if there is no user preference
+  do {
+    // Compute the selectable capability
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+      codec_selectable_capability_.sample_rate |=
+          BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    }
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+      codec_selectable_capability_.sample_rate |=
+          BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    }
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+      codec_selectable_capability_.sample_rate |=
+          BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+    }
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+      codec_selectable_capability_.sample_rate |=
+          BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+    }
+
+    if (codec_config_.sample_rate != BTAV_A2DP_CODEC_SAMPLE_RATE_NONE) break;
+
+    // Compute the common capability
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+
+    // No user preference - try the codec audio config
+    if (select_audio_sample_rate(&codec_audio_config_, sampleRate,
+                                 &result_config_cie, &codec_config_)) {
+      break;
+    }
+
+    // No user preference - try the default config
+    if (select_best_sample_rate(
+            a2dp_lhdc_default_config.sampleRate & sink_info_cie.sampleRate,
+            &result_config_cie, &codec_config_)) {
+      break;
+    }
+
+    // No user preference - use the best match
+    if (select_best_sample_rate(sampleRate, &result_config_cie,
+                                &codec_config_)) {
+      break;
+    }
+  } while (false);
+  if (codec_config_.sample_rate == BTAV_A2DP_CODEC_SAMPLE_RATE_NONE) {
+    LOG_ERROR(LOG_TAG,
+              "%s: cannot match sample frequency: source caps = 0x%x "
+              "sink info = 0x%x",
+              __func__, a2dp_lhdc_source_caps.sampleRate, sink_info_cie.sampleRate);
+    goto fail;
+  }
+
+  //
+  // Select the bits per sample
+  //
+  // NOTE: this information is NOT included in the LHDC A2DP codec description
+  // that is sent OTA.
+  bits_per_sample = a2dp_lhdc_source_caps.bits_per_sample & sink_info_cie.bits_per_sample;
+  LOG_ERROR(LOG_TAG, "%s: a2dp_lhdc_source_caps.bits_per_sample = 0x%02x, sink_info_cie.bits_per_sample = 0x%02x", __func__, a2dp_lhdc_source_caps.bits_per_sample, sink_info_cie.bits_per_sample);
+  codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+  switch (codec_user_config_.bits_per_sample) {
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+        result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+        codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
+        codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
+      }
+      break;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+        result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+        codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
+        codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
+      }
+      break;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+      result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+      codec_capability_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+      codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+      break;
+  }
+
+  // Select the bits per sample if there is no user preference
+  do {
+    // Compute the selectable capability
+      // Compute the selectable capability
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)
+        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24)
+        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+
+    if (codec_config_.bits_per_sample != BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE) break;
+
+    // Compute the common capability
+    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)
+      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24)
+      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+
+    // No user preference - the the codec audio config
+    if (select_audio_bits_per_sample(&codec_audio_config_, bits_per_sample,
+                                     &result_config_cie, &codec_config_)) {
+      break;
+    }
+
+    // No user preference - try the default config
+    if (select_best_bits_per_sample(a2dp_lhdc_default_config.bits_per_sample & sink_info_cie.bits_per_sample,
+                                    &result_config_cie, &codec_config_)) {
+      break;
+    }
+
+    // No user preference - use the best match
+    if (select_best_bits_per_sample(bits_per_sample,
+                                    &result_config_cie, &codec_config_)) {
+      break;
+    }
+  } while (false);
+  if (codec_config_.bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE) {
+    LOG_ERROR(LOG_TAG,
+              "%s: cannot match bits per sample: default = 0x%x "
+              "user preference = 0x%x",
+              __func__, a2dp_lhdc_default_config.bits_per_sample,
+              codec_user_config_.bits_per_sample);
+    goto fail;
+  }
+
+  //
+  // Select the channel mode
+  //
+  LOG_ERROR(LOG_TAG, "%s: channelMode = Only supported stereo", __func__);
+  codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
+  switch (codec_user_config_.channel_mode) {
+    case BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO:
+      codec_capability_.channel_mode = codec_user_config_.channel_mode;
+      codec_config_.channel_mode = codec_user_config_.channel_mode;
+      break;
+    case BTAV_A2DP_CODEC_CHANNEL_MODE_MONO:
+    case BTAV_A2DP_CODEC_CHANNEL_MODE_NONE:
+      codec_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
+      codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
+      break;
+  }
+  codec_selectable_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  codec_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  if (codec_config_.channel_mode == BTAV_A2DP_CODEC_CHANNEL_MODE_NONE) {
+    LOG_ERROR(LOG_TAG,
+              "%s: codec_config_.channel_mode != BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO "
+              , __func__);
+    goto fail;
+  }
+
+  result_config_cie.maxTargetBitrate = sink_info_cie.maxTargetBitrate;
+
+  LOG_DEBUG(LOG_TAG, "%s: Config bitrate result(0x%02x), prev(0x%02x)", __func__, result_config_cie.maxTargetBitrate, sink_info_cie.maxTargetBitrate);
+
+
+  result_config_cie.channelSplitMode = sink_info_cie.channelSplitMode;
+  LOG_ERROR(LOG_TAG, "%s: channelSplitMode = %d", __func__, result_config_cie.channelSplitMode);
+
+  // quality mode (BitRate) adjust
+  if ((codec_user_config_.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) != A2DP_LHDC_QUALITY_MAGIC_NUM) {
+    codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_ABR;
+    LOG_DEBUG(LOG_TAG, "%s: tag not match, use default Mode: ABR", __func__);
+  }
+  qualityMode = (uint8_t)codec_user_config_.codec_specific_1 & A2DP_LHDC_QUALITY_MASK;
+
+  //
+  // quality mode adjust when non-ABR
+  //
+  if (qualityMode != A2DP_LHDC_QUALITY_ABR) {
+    // get corresponding quality mode of the max target bit rate
+    if (!A2DP_MaxBitRatetoQualityLevelLhdcV2(&bitRateQmode, result_config_cie.maxTargetBitrate)) {
+      LOG_ERROR(LOG_TAG, "%s: get quality mode from maxTargetBitrate error", __func__);
+      goto fail;
+    }
+    // downgrade audio quality according to the max target bit rate
+    if (qualityMode > bitRateQmode) {
+      codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | bitRateQmode;
+      qualityMode = bitRateQmode;
+      LOG_DEBUG(LOG_TAG, "%s: downgrade quality mode to 0x%02X by max target bitrate", __func__, qualityMode);
+    }
+
+    // High1(1000K) does not supported in V2, downgrade to High(900K)
+    if (qualityMode == A2DP_LHDC_QUALITY_HIGH1) {
+      LOG_DEBUG(LOG_TAG, "%s: reset non-supported quality mode %s to HIGH (900 Kbps)", __func__,
+          lhdcV2_QualityModeBitRate_toString(qualityMode).c_str());
+      codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_HIGH;
+      qualityMode = A2DP_LHDC_QUALITY_HIGH;
+    }
+  }
+
+  LOG_DEBUG(LOG_TAG, "%s: => final quality mode(0x%02X) = %s", __func__,
+      qualityMode,
+      lhdcV2_QualityModeBitRate_toString(qualityMode).c_str());
+
+  if (int ret = A2DP_BuildInfoLhdcV2(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
+                         p_result_codec_config) != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG,"%s: A2DP_BuildInfoLhdcV2 fail(0x%x)", __func__, ret);
+    goto fail;
+  }
+
+  //
+  // Copy the codec-specific fields if they are not zero
+  //
+  if (codec_user_config_.codec_specific_1 != 0)
+    codec_config_.codec_specific_1 = codec_user_config_.codec_specific_1;
+  if (codec_user_config_.codec_specific_2 != 0)
+    codec_config_.codec_specific_2 = codec_user_config_.codec_specific_2;
+  if (codec_user_config_.codec_specific_3 != 0)
+    codec_config_.codec_specific_3 = codec_user_config_.codec_specific_3;
+  //codec_config_.codec_specific_3 = result_config_cie.isLLSupported == true ? 1 : 0;
+
+  if (codec_user_config_.codec_specific_4 != 0)
+    codec_config_.codec_specific_4 = codec_user_config_.codec_specific_4;
+
+
+  // Create a local copy of the peer codec capability, and the
+  // result codec config.
+    LOG_ERROR(LOG_TAG,"%s: is_capability = %d", __func__, is_capability);
+  if (is_capability) {
+    status = A2DP_BuildInfoLhdcV2(AVDT_MEDIA_TYPE_AUDIO, &sink_info_cie,
+                                ota_codec_peer_capability_);
+  } else {
+    status = A2DP_BuildInfoLhdcV2(AVDT_MEDIA_TYPE_AUDIO, &sink_info_cie,
+                                ota_codec_peer_config_);
+  }
+  CHECK(status == A2DP_SUCCESS);
+
+  status = A2DP_BuildInfoLhdcV2(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
+                              ota_codec_config_);
+  CHECK(status == A2DP_SUCCESS);
+  return true;
+
+fail:
+  // Restore the internal state
+  codec_config_ = saved_codec_config;
+  codec_capability_ = saved_codec_capability;
+  codec_selectable_capability_ = saved_codec_selectable_capability;
+  codec_user_config_ = saved_codec_user_config;
+  codec_audio_config_ = saved_codec_audio_config;
+  memcpy(ota_codec_config_, saved_ota_codec_config, sizeof(ota_codec_config_));
+  memcpy(ota_codec_peer_capability_, saved_ota_codec_peer_capability,
+         sizeof(ota_codec_peer_capability_));
+  memcpy(ota_codec_peer_config_, saved_ota_codec_peer_config,
+         sizeof(ota_codec_peer_config_));
+  return false;
+}
+
+
+
+bool A2dpCodecConfigLhdcV2::setPeerCodecCapabilities(
+                                                   const uint8_t* p_peer_codec_capabilities) {
+    std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
+    tA2DP_LHDC_CIE peer_info_cie;
+    uint8_t sampleRate;
+    uint8_t bits_per_sample;
+
+    // Save the internal state
+    btav_a2dp_codec_config_t saved_codec_selectable_capability =
+    codec_selectable_capability_;
+    uint8_t saved_ota_codec_peer_capability[AVDT_CODEC_SIZE];
+    memcpy(saved_ota_codec_peer_capability, ota_codec_peer_capability_,
+           sizeof(ota_codec_peer_capability_));
+
+    tA2DP_STATUS status =
+    A2DP_ParseInfoLhdcV2(&peer_info_cie, p_peer_codec_capabilities, true);
+    if (status != A2DP_SUCCESS) {
+        LOG_ERROR(LOG_TAG, "%s: can't parse peer's capabilities: error = %d",
+                  __func__, status);
+        goto fail;
+    }
+
+    if (peer_info_cie.version > a2dp_lhdc_source_caps.version) {
+        LOG_ERROR(LOG_TAG, "%s: can't parse peer's capabilities: Missmatch version(%u:%u)",
+                  __func__, a2dp_lhdc_source_caps.version, peer_info_cie.version);
+        goto fail;
+    }
+
+    codec_selectable_capability_.codec_specific_3 = peer_info_cie.isLLSupported ? 1 : 0;
+
+    // Compute the selectable capability - bits per sample
+    //codec_selectable_capability_.bits_per_sample =
+    //a2dp_lhdc_source_caps.bits_per_sample;
+    bits_per_sample = a2dp_lhdc_source_caps.bits_per_sample & peer_info_cie.bits_per_sample;
+    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    }
+    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+    }
+
+
+    // Compute the selectable capability - sample rate
+    sampleRate = a2dp_lhdc_source_caps.sampleRate & peer_info_cie.sampleRate;
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+        codec_selectable_capability_.sample_rate |=
+        BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    }
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+        codec_selectable_capability_.sample_rate |=
+        BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    }
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+        codec_selectable_capability_.sample_rate |=
+        BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+    }
+
+
+    // Compute the selectable capability - channel mode
+    codec_selectable_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+
+    status = A2DP_BuildInfoLhdcV2(AVDT_MEDIA_TYPE_AUDIO, &peer_info_cie,
+                                ota_codec_peer_capability_);
+    CHECK(status == A2DP_SUCCESS);
+    return true;
+
+fail:
+    // Restore the internal state
+    codec_selectable_capability_ = saved_codec_selectable_capability;
+    memcpy(ota_codec_peer_capability_, saved_ota_codec_peer_capability,
+           sizeof(ota_codec_peer_capability_));
+    return false;
+}
diff --git a/system/bt/stack/a2dp/a2dp_vendor_lhdcv2_encoder.cc b/system/bt/stack/a2dp/a2dp_vendor_lhdcv2_encoder.cc
new file mode 100755
index 00000000..ed7140c1
--- /dev/null
+++ b/system/bt/stack/a2dp/a2dp_vendor_lhdcv2_encoder.cc
@@ -0,0 +1,942 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "a2dp_vendor_lhdcv2_encoder"
+#define ATRACE_TAG ATRACE_TAG_AUDIO
+
+#include "a2dp_vendor_lhdcv2_encoder.h"
+
+#ifndef OS_GENERIC
+#include <cutils/trace.h>
+#endif
+#include <dlfcn.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <lhdcBT.h>
+
+#include "a2dp_vendor.h"
+#include "a2dp_vendor_lhdcv2.h"
+#include "bt_common.h"
+#include "common/time_util.h"
+#include "osi/include/log.h"
+#include "osi/include/osi.h"
+
+//
+// Encoder for LHDC Source Codec
+//
+
+//
+// The LHDC encoder shared library, and the functions to use
+//
+static const char* LHDC_ENCODER_LIB_NAME = "liblhdcBT_enc.so";
+static void* lhdc_encoder_lib_handle = NULL;
+
+static const char* LHDC_GET_HANDLE_NAME = "lhdcBT_get_handle";
+typedef HANDLE_LHDC_BT (*tLHDC_GET_HANDLE)(int version);
+
+static const char* LHDC_FREE_HANDLE_NAME = "lhdcBT_free_handle";
+typedef void (*tLHDC_FREE_HANDLE)(HANDLE_LHDC_BT hLhdcParam);
+
+static const char* LHDC_GET_BITRATE_NAME = "lhdcBT_get_bitrate";
+typedef int (*tLHDC_GET_BITRATE)(HANDLE_LHDC_BT hLhdcParam);
+static const char* LHDC_SET_BITRATE_NAME = "lhdcBT_set_bitrate";
+typedef int (*tLHDC_SET_BITRATE)(HANDLE_LHDC_BT hLhdcParam, int index);
+
+//static const char* LHDC_GET_SAMPLING_FREQ_NAME = "lhdcBT_get_sampling_freq";
+//typedef int (*tLHDC_GET_SAMPLING_FREQ)(HANDLE_LHDC_BT hLhdcParam);
+
+static const char* LHDC_INIT_HANDLE_ENCODE_NAME = "lhdcBT_init_encoder";
+typedef int (*tLHDC_INIT_HANDLE_ENCODE)(HANDLE_LHDC_BT hLhdcParam,int sampling_freq, int bitPerSample, int bitrate_inx, int dualChannels, int need_padding, int mtu_size, int interval);
+
+static const char* LHDC_AUTO_ADJUST_BITRATE_NAME = "lhdcBT_adjust_bitrate";
+typedef int (*tLHDC_AUTO_ADJUST_BITRATE)(HANDLE_LHDC_BT hLhdcParam, size_t queueLength);
+
+
+static const char* LHDC_ENCODE_NAME = "lhdcBT_encode";
+typedef int (*tLHDC_ENCODE)(HANDLE_LHDC_BT hLhdcParam, void* p_pcm, unsigned char* p_stream);
+
+static const char* LHDC_SET_LIMIT_BITRATE_ENABLED_NAME = "lhdcBT_set_max_bitrate";
+typedef void (*tLHDC_SET_LIMIT_BITRATE_ENABLED)(HANDLE_LHDC_BT hLhdcParam, int max_rate_index);
+
+//static const char* LHDC_GET_ERROR_CODE_NAME = "lhdcBT_get_error_code";
+//typedef int (*tLHDC_GET_ERROR_CODE)(HANDLE_LHDC_BT hLhdcParam);
+
+//static const char* LHDC_GET_SUPPORTED_VERSION = "lhdcBT_getSupportedVersion";
+//typedef int (*tLHDC_GET_SUPPORTED_VERSION)(HANDLE_LHDC_BT hLhdcParam);
+
+static const char* LHDC_GET_BLOCK_SIZE = "lhdcBT_get_block_Size";
+typedef int (*tLHDC_GET_BLOCK_SIZE)(HANDLE_LHDC_BT hLhdcParam);
+
+static tLHDC_GET_HANDLE lhdc_get_handle_func;
+static tLHDC_FREE_HANDLE lhdc_free_handle_func;
+static tLHDC_GET_BITRATE lhdc_get_bitrate_func;
+static tLHDC_SET_BITRATE lhdc_set_bitrate_func;
+static tLHDC_INIT_HANDLE_ENCODE lhdc_init_handle_encode_func;
+static tLHDC_ENCODE lhdc_encode_func;
+static tLHDC_AUTO_ADJUST_BITRATE lhdc_auto_adjust_bitrate_func;
+//static tLHDC_GET_ERROR_CODE lhdc_get_error_code_func;
+static tLHDC_SET_LIMIT_BITRATE_ENABLED lhdc_set_limit_bitrate;
+//static tLHDC_GET_SUPPORTED_VERSION lhdc_get_supported_version;
+static tLHDC_GET_BLOCK_SIZE lhdc_get_block_size;
+
+// A2DP LHDC encoder interval in milliseconds
+#define A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS 11
+#define A2DP_LHDC_ENCODER_INTERVAL_MS 20
+
+// offset
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+#define A2DP_LHDC_OFFSET (AVDT_MEDIA_OFFSET + A2DP_LHDC_MPL_HDR_LEN + 1)
+#else
+#define A2DP_LHDC_OFFSET (AVDT_MEDIA_OFFSET + A2DP_LHDC_MPL_HDR_LEN)
+#endif
+
+//#define A2DP_LHDC_OFFSET (AVDT_MEDIA_OFFSET + 0)
+
+typedef struct {
+  uint32_t sample_rate;
+  uint8_t channel_mode;
+  uint8_t bits_per_sample;
+  int quality_mode_index;
+  int latency_mode_index;
+  int pcm_wlength;
+  LHDCBT_SMPL_FMT_T pcm_fmt;
+  int8_t channelSplitMode;
+  int8_t maxTargetBitrate;
+  bool isLLEnabled;
+} tA2DP_LHDC_ENCODER_PARAMS;
+
+typedef struct {
+  uint32_t counter;
+  uint32_t bytes_per_tick; /* pcm bytes read each media task tick */
+  uint64_t last_frame_us;
+  uint32_t n_frames;
+} tA2DP_LHDC_FEEDING_STATE;
+
+typedef struct {
+  uint64_t session_start_us;
+
+  size_t media_read_total_expected_packets;
+  size_t media_read_total_expected_reads_count;
+  size_t media_read_total_expected_read_bytes;
+
+  size_t media_read_total_dropped_packets;
+  size_t media_read_total_actual_reads_count;
+  size_t media_read_total_actual_read_bytes;
+} a2dp_lhdc_encoder_stats_t;
+
+typedef struct {
+  a2dp_source_read_callback_t read_callback;
+  a2dp_source_enqueue_callback_t enqueue_callback;
+  uint16_t TxAaMtuSize;
+  size_t TxQueueLength;
+
+  bool use_SCMS_T;
+  bool is_peer_edr;          // True if the peer device supports EDR
+  bool peer_supports_3mbps;  // True if the peer device supports 3Mbps EDR
+  uint16_t peer_mtu;         // MTU of the A2DP peer
+  uint32_t timestamp;        // Timestamp for the A2DP frames
+
+  HANDLE_LHDC_BT lhdc_handle;
+  bool has_lhdc_handle;  // True if lhdc_handle is valid
+  uint8_t version;
+
+  tA2DP_FEEDING_PARAMS feeding_params;
+  tA2DP_LHDC_ENCODER_PARAMS lhdc_encoder_params;
+  tA2DP_LHDC_FEEDING_STATE lhdc_feeding_state;
+
+  a2dp_lhdc_encoder_stats_t stats;
+  uint32_t buf_seq;
+} tA2DP_LHDC_ENCODER_CB;
+
+//static bool lhdc_abr_loaded = false;
+
+
+
+typedef struct _lhdc_frame_Info {
+    uint32_t frame_len;
+    uint32_t isSplit;
+    uint32_t isLeft;
+
+} lhdc_frame_Info_t;
+
+
+#define _RECODER_FILE_
+#if defined(_RECODER_FILE_)
+static FILE  *RecFile = NULL;
+#endif
+
+static tA2DP_LHDC_ENCODER_CB a2dp_lhdc_encoder_cb;
+
+static void a2dp_vendor_lhdcv2_encoder_update(uint16_t peer_mtu,
+                                            A2dpCodecConfig* a2dp_codec_config,
+                                            bool* p_restart_input,
+                                            bool* p_restart_output,
+                                            bool* p_config_updated);
+static void a2dp_lhdcv2_get_num_frame_iteration(uint8_t* num_of_iterations,
+                                              uint8_t* num_of_frames,
+                                              uint64_t timestamp_us);
+static void a2dp_lhdcv2_encode_frames(uint8_t nb_frame);
+static bool a2dp_lhdcv2_read_feeding(uint8_t* read_buffer, uint32_t *bytes_read);
+static std::string quality_mode_index_to_name(int quality_mode_index);
+//static std::string latency_mode_index_to_name(int latency_mode_index);
+
+static void* load_func(const char* func_name) {
+  void* func_ptr = dlsym(lhdc_encoder_lib_handle, func_name);
+  if (func_ptr == NULL) {
+    LOG_ERROR(LOG_TAG,
+              "%s: cannot find function '%s' in the encoder library: %s",
+              __func__, func_name, dlerror());
+    A2DP_VendorUnloadEncoderLhdcV2();
+    return NULL;
+  }
+  return func_ptr;
+}
+
+bool A2DP_VendorLoadEncoderLhdcV2(void) {
+  if (lhdc_encoder_lib_handle != NULL) return true;  // Already loaded
+
+  // Initialize the control block
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+
+  // Open the encoder library
+  lhdc_encoder_lib_handle = dlopen(LHDC_ENCODER_LIB_NAME, RTLD_NOW);
+  if (lhdc_encoder_lib_handle == NULL) {
+    LOG_ERROR(LOG_TAG, "%s: cannot open LHDC encoder library %s: %s", __func__,
+              LHDC_ENCODER_LIB_NAME, dlerror());
+    return false;
+  }
+
+
+  // Load all functions
+  lhdc_get_handle_func = (tLHDC_GET_HANDLE)load_func(LHDC_GET_HANDLE_NAME);
+  if (lhdc_get_handle_func == NULL) return false;
+  lhdc_free_handle_func = (tLHDC_FREE_HANDLE)load_func(LHDC_FREE_HANDLE_NAME);
+  if (lhdc_free_handle_func == NULL) return false;
+  lhdc_get_bitrate_func = (tLHDC_GET_BITRATE)load_func(LHDC_GET_BITRATE_NAME);
+  if (lhdc_get_bitrate_func == NULL) return false;
+  lhdc_set_bitrate_func = (tLHDC_SET_BITRATE)load_func(LHDC_SET_BITRATE_NAME);
+  if (lhdc_set_bitrate_func == NULL) return false;
+  lhdc_init_handle_encode_func =
+      (tLHDC_INIT_HANDLE_ENCODE)load_func(LHDC_INIT_HANDLE_ENCODE_NAME);
+  if (lhdc_init_handle_encode_func == NULL) return false;
+  lhdc_encode_func = (tLHDC_ENCODE)load_func(LHDC_ENCODE_NAME);
+  if (lhdc_encode_func == NULL) return false;
+  lhdc_auto_adjust_bitrate_func = (tLHDC_AUTO_ADJUST_BITRATE)load_func(LHDC_AUTO_ADJUST_BITRATE_NAME);
+  if (lhdc_auto_adjust_bitrate_func == NULL) return false;
+  //lhdc_get_error_code_func = (tLHDC_GET_ERROR_CODE)load_func(LHDC_GET_ERROR_CODE_NAME);
+  //if (lhdc_get_error_code_func == NULL) return false;
+
+
+  lhdc_set_limit_bitrate = (tLHDC_SET_LIMIT_BITRATE_ENABLED)load_func(LHDC_SET_LIMIT_BITRATE_ENABLED_NAME);
+  if (lhdc_set_limit_bitrate == NULL) return false;
+  //lhdc_get_supported_version = (tLHDC_GET_SUPPORTED_VERSION)load_func(LHDC_GET_SUPPORTED_VERSION);
+  //if (lhdc_get_supported_version == NULL) return false;
+  lhdc_get_block_size = (tLHDC_GET_BLOCK_SIZE)load_func(LHDC_GET_BLOCK_SIZE);
+  if (lhdc_get_block_size == NULL) return false;
+
+  return true;
+}
+
+void A2DP_VendorUnloadEncoderLhdcV2(void) {
+  // Cleanup any LHDC-related state
+
+    LOG_DEBUG(LOG_TAG, "%s: a2dp_lhdc_encoder_cb.has_lhdc_handle = %d, lhdc_free_handle_func = %p",
+              __func__, a2dp_lhdc_encoder_cb.has_lhdc_handle, lhdc_free_handle_func);
+  if (a2dp_lhdc_encoder_cb.has_lhdc_handle && lhdc_free_handle_func != NULL)
+    lhdc_free_handle_func(a2dp_lhdc_encoder_cb.lhdc_handle);
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+
+  lhdc_get_handle_func = NULL;
+  lhdc_free_handle_func = NULL;
+  lhdc_get_bitrate_func = NULL;
+  lhdc_set_bitrate_func = NULL;
+  lhdc_init_handle_encode_func = NULL;
+  lhdc_encode_func = NULL;
+  lhdc_auto_adjust_bitrate_func = NULL;
+  //lhdc_get_error_code_func = NULL;
+  lhdc_set_limit_bitrate = NULL;
+
+  if (lhdc_encoder_lib_handle != NULL) {
+    dlclose(lhdc_encoder_lib_handle);
+    lhdc_encoder_lib_handle = NULL;
+  }
+}
+
+void a2dp_vendor_lhdcv2_encoder_init(
+    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+    A2dpCodecConfig* a2dp_codec_config,
+    a2dp_source_read_callback_t read_callback,
+    a2dp_source_enqueue_callback_t enqueue_callback) {
+  if (a2dp_lhdc_encoder_cb.has_lhdc_handle)
+    lhdc_free_handle_func(a2dp_lhdc_encoder_cb.lhdc_handle);
+
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+
+  a2dp_lhdc_encoder_cb.stats.session_start_us = bluetooth::common::time_get_os_boottime_us();
+
+  a2dp_lhdc_encoder_cb.read_callback = read_callback;
+  a2dp_lhdc_encoder_cb.enqueue_callback = enqueue_callback;
+  a2dp_lhdc_encoder_cb.is_peer_edr = p_peer_params->is_peer_edr;
+  a2dp_lhdc_encoder_cb.peer_supports_3mbps = p_peer_params->peer_supports_3mbps;
+  a2dp_lhdc_encoder_cb.peer_mtu = p_peer_params->peer_mtu;
+  a2dp_lhdc_encoder_cb.timestamp = 0;
+
+
+  a2dp_lhdc_encoder_cb.use_SCMS_T = false;  // TODO: should be a parameter
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+  a2dp_lhdc_encoder_cb.use_SCMS_T = true;
+#endif
+
+  // NOTE: Ignore the restart_input / restart_output flags - this initization
+  // happens when the connection is (re)started.
+  bool restart_input = false;
+  bool restart_output = false;
+  bool config_updated = false;
+  a2dp_vendor_lhdcv2_encoder_update(a2dp_lhdc_encoder_cb.peer_mtu,
+                                  a2dp_codec_config, &restart_input,
+                                  &restart_output, &config_updated);
+}
+
+bool A2dpCodecConfigLhdcV2::updateEncoderUserConfig(
+    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params, bool* p_restart_input,
+    bool* p_restart_output, bool* p_config_updated) {
+  a2dp_lhdc_encoder_cb.is_peer_edr = p_peer_params->is_peer_edr;
+  a2dp_lhdc_encoder_cb.peer_supports_3mbps = p_peer_params->peer_supports_3mbps;
+  a2dp_lhdc_encoder_cb.peer_mtu = p_peer_params->peer_mtu;
+  a2dp_lhdc_encoder_cb.timestamp = 0;
+
+  if (a2dp_lhdc_encoder_cb.peer_mtu == 0) {
+    LOG_ERROR(LOG_TAG,
+              "%s: Cannot update the codec encoder for %s: "
+              "invalid peer MTU",
+              __func__, name().c_str());
+    return false;
+  }
+
+  a2dp_vendor_lhdcv2_encoder_update(a2dp_lhdc_encoder_cb.peer_mtu, this,
+                                  p_restart_input, p_restart_output,
+                                  p_config_updated);
+  return true;
+}
+
+// Update the A2DP LHDC encoder.
+// |peer_mtu| is the peer MTU.
+// |a2dp_codec_config| is the A2DP codec to use for the update.
+static void a2dp_vendor_lhdcv2_encoder_update(uint16_t peer_mtu,
+                                            A2dpCodecConfig* a2dp_codec_config,
+                                            bool* p_restart_input,
+                                            bool* p_restart_output,
+                                            bool* p_config_updated) {
+  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params =
+      &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+  uint8_t codec_info[AVDT_CODEC_SIZE];
+
+  *p_restart_input = false;
+  *p_restart_output = false;
+  *p_config_updated = false;
+
+  //Example for limit bit rate
+  //lhdc_set_limit_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, 0);
+
+
+  if (!a2dp_codec_config->copyOutOtaCodecConfig(codec_info)) {
+    LOG_ERROR(LOG_TAG,
+              "%s: Cannot update the codec encoder for %s: "
+              "invalid codec config",
+              __func__, a2dp_codec_config->name().c_str());
+    return;
+  }
+  const uint8_t* p_codec_info = codec_info;
+  btav_a2dp_codec_config_t codec_config = a2dp_codec_config->getCodecConfig();
+
+  if (!a2dp_lhdc_encoder_cb.has_lhdc_handle) {
+      a2dp_lhdc_encoder_cb.lhdc_handle = lhdc_get_handle_func(A2DP_VendorGetVersionLhdcV2(p_codec_info) <= A2DP_LHDC_VER2 ? 1 : -1);
+      if (a2dp_lhdc_encoder_cb.lhdc_handle == NULL) {
+        LOG_ERROR(LOG_TAG, "%s: Cannot get LHDC encoder handle", __func__);
+        return;  // TODO: Return an error?
+      }
+      a2dp_lhdc_encoder_cb.has_lhdc_handle = true;
+  }
+  a2dp_lhdc_encoder_cb.version = A2DP_VendorGetVersionLhdcV2(p_codec_info);
+
+
+  // The feeding parameters
+  tA2DP_FEEDING_PARAMS* p_feeding_params = &a2dp_lhdc_encoder_cb.feeding_params;
+  p_feeding_params->sample_rate =
+      A2DP_VendorGetTrackSampleRateLhdcV2(p_codec_info);
+  p_feeding_params->bits_per_sample =
+      a2dp_codec_config->getAudioBitsPerSample();
+  p_feeding_params->channel_count =
+      A2DP_VendorGetTrackChannelCountLhdcV2(p_codec_info);
+  LOG_DEBUG(LOG_TAG, "%s:(feeding) sample_rate=%u bits_per_sample=%u channel_count=%u",
+            __func__, p_feeding_params->sample_rate,
+            p_feeding_params->bits_per_sample, p_feeding_params->channel_count);
+
+  // The codec parameters
+  p_encoder_params->sample_rate =
+      a2dp_lhdc_encoder_cb.feeding_params.sample_rate;
+
+  uint16_t mtu_size =
+      BT_DEFAULT_BUFFER_SIZE - A2DP_LHDC_OFFSET - sizeof(BT_HDR);
+
+  a2dp_lhdc_encoder_cb.TxAaMtuSize = (mtu_size < peer_mtu) ? mtu_size : peer_mtu;
+
+  a2dp_lhdc_encoder_cb.TxAaMtuSize = a2dp_lhdc_encoder_cb.TxAaMtuSize & ((uint16_t)0xFFFE);
+
+  //get separation feature.
+  p_encoder_params->channelSplitMode = A2DP_VendorGetChannelSplitModeLhdcV2(p_codec_info);
+  // Set the quality mode index
+  //int old_quality_mode_index = p_encoder_params->quality_mode_index;
+  LOG_DEBUG(LOG_TAG, "%s:codec_config.codec_specific_1 = %d, codec_config.codec_specific_2 = %d", __func__, (int32_t)codec_config.codec_specific_1, (int32_t)codec_config.codec_specific_2);
+  if ((codec_config.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) == A2DP_LHDC_QUALITY_MAGIC_NUM) {
+      int newValue = codec_config.codec_specific_1 & 0xff;
+
+      // adjust non-supported quality modes and wrap to internal library used index
+      if (newValue == A2DP_LHDC_QUALITY_ABR) {
+        newValue = LHDCBT_QUALITY_AUTO; //9->8
+      }
+
+      if (newValue != p_encoder_params->quality_mode_index) {
+        p_encoder_params->quality_mode_index = newValue;
+        LOG_DEBUG(LOG_TAG, "%s: setting internal quality mode: %s(%d)", __func__,
+            quality_mode_index_to_name(p_encoder_params->quality_mode_index)
+            .c_str(), p_encoder_params->quality_mode_index);
+      }
+  }else {
+      p_encoder_params->quality_mode_index = LHDCBT_QUALITY_AUTO;
+      LOG_DEBUG(LOG_TAG, "%s: setting default quality mode to ABR", __func__);
+  }
+
+  //To correcting data to middle.
+  if (p_encoder_params->channelSplitMode >= A2DP_LHDC_CH_SPLIT_TWS
+       && p_encoder_params->quality_mode_index >= LHDCBT_QUALITY_HIGH) {
+      /* code */
+      LOG_DEBUG(LOG_TAG, "%s: Channel separation enabled, Max bit rate = LHDCBT_QUALITY_MID", __func__);
+      p_encoder_params->quality_mode_index = LHDCBT_QUALITY_MID;
+  }
+
+  p_encoder_params->maxTargetBitrate = A2DP_VendorGetMaxDatarateLhdcV2(p_codec_info);
+
+/*
+  //p_encoder_params->latency_mode_index = 1;
+  if ((codec_config.codec_specific_2 & A2DP_LHDC_VENDOR_CMD_MASK) == A2DP_LHDC_LATENCY_MAGIC_NUM) {
+      int newValue = codec_config.codec_specific_2 & 0xff;
+      if (newValue != p_encoder_params->latency_mode_index) {
+          p_encoder_params->latency_mode_index = newValue;
+          LOG_DEBUG(LOG_TAG, "%s: setting latency value to %s(%d)", __func__,
+                    latency_mode_index_to_name(p_encoder_params->latency_mode_index).c_str(),
+                    p_encoder_params->latency_mode_index);
+      }
+  }else {
+      p_encoder_params->latency_mode_index = A2DP_LHDC_LATENCY_MID;
+  }
+*/
+
+  p_encoder_params->isLLEnabled = (codec_config.codec_specific_2 & 1) != 0 ? true :false; //A2DP_VendorGetLowLatencyState(p_codec_info);
+
+
+  p_encoder_params->pcm_wlength =
+      a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample >> 3;
+  // Set the Audio format from pcm_wlength
+  p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S16;
+  if (p_encoder_params->pcm_wlength == 2)
+    p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S16;
+  else if (p_encoder_params->pcm_wlength == 3)
+    p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S24;
+ // else if (p_encoder_params->pcm_wlength == 4)
+//    p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S32;
+
+  LOG_DEBUG(LOG_TAG, "%s: MTU=%d, peer_mtu=%d", __func__,
+            a2dp_lhdc_encoder_cb.TxAaMtuSize, peer_mtu);
+  LOG_DEBUG(LOG_TAG,
+            "%s: sample_rate: %d "
+            "quality_mode_index: %d pcm_wlength: %d pcm_fmt: %d",
+            __func__, p_encoder_params->sample_rate,
+            p_encoder_params->quality_mode_index, p_encoder_params->pcm_wlength,
+            p_encoder_params->pcm_fmt);
+
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN - 1);
+#else
+    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN);
+#endif
+  // Initialize the encoder.
+  // NOTE: MTU in the initialization must include the AVDT media header size.
+  int result = lhdc_init_handle_encode_func(
+      a2dp_lhdc_encoder_cb.lhdc_handle,
+      p_encoder_params->sample_rate,
+      p_encoder_params->pcm_fmt,
+      p_encoder_params->quality_mode_index,
+      p_encoder_params->channelSplitMode > A2DP_LHDC_CH_SPLIT_NONE ? 1 : 0,
+      0 /* This parameter alaways is 0 in A2DP */ ,
+      max_mtu_len,
+      a2dp_vendor_lhdcv2_get_encoder_interval_ms()
+  );
+    lhdc_set_limit_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, p_encoder_params->maxTargetBitrate);
+
+    lhdc_set_bitrate_func(a2dp_lhdc_encoder_cb.lhdc_handle, p_encoder_params->quality_mode_index);
+
+#if defined(_RECODER_FILE_)
+  if (RecFile == NULL) {
+      RecFile = fopen("/sdcard/Download/lhdc.raw","wb");
+    LOG_ERROR(LOG_TAG, "%s: Create recode file = %p", __func__, RecFile);
+  }
+#endif
+  if (result != 0) {
+    LOG_ERROR(LOG_TAG, "%s: error initializing the LHDC encoder: %d", __func__,
+              result);
+  }
+}
+
+void a2dp_vendor_lhdcv2_encoder_cleanup(void) {
+  if (a2dp_lhdc_encoder_cb.has_lhdc_handle)
+    lhdc_free_handle_func(a2dp_lhdc_encoder_cb.lhdc_handle);
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+#if defined(_RECODER_FILE_)
+  if (RecFile != NULL) {
+      fclose(RecFile);
+      RecFile = NULL;
+  }
+#endif
+}
+
+void a2dp_vendor_lhdcv2_feeding_reset(void) {
+  /* By default, just clear the entire state */
+  memset(&a2dp_lhdc_encoder_cb.lhdc_feeding_state, 0,
+         sizeof(a2dp_lhdc_encoder_cb.lhdc_feeding_state));
+
+  int encoder_interval = a2dp_vendor_lhdcv2_get_encoder_interval_ms();
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick =
+      (a2dp_lhdc_encoder_cb.feeding_params.sample_rate *
+       a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8 *
+       a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+       encoder_interval) /
+      1000;
+  a2dp_lhdc_encoder_cb.buf_seq = 0;
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us = 0;
+  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params = &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+  LOG_DEBUG(LOG_TAG, "%s: quality_mode_index (%d)", __func__,
+      p_encoder_params->quality_mode_index);
+  if (p_encoder_params->quality_mode_index == LHDCBT_QUALITY_AUTO) {
+    if(lhdc_set_bitrate_func != NULL && a2dp_lhdc_encoder_cb.has_lhdc_handle)
+      LOG_DEBUG(LOG_TAG, "%s: reset ABR!", __func__);
+      lhdc_set_bitrate_func(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCBT_QUALITY_RESET_AUTO);
+  }
+  LOG_DEBUG(LOG_TAG, "%s: PCM bytes per tick %u, reset timestamp", __func__,
+            a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick);
+}
+
+void a2dp_vendor_lhdcv2_feeding_flush(void) {
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter = 0;
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.n_frames = 0;
+  LOG_DEBUG(LOG_TAG, "%s", __func__);
+}
+
+uint64_t a2dp_vendor_lhdcv2_get_encoder_interval_ms(void) {
+  //LOG_DEBUG(LOG_TAG, "%s: A2DP_LHDC_ENCODER_INTERVAL_MS %u",
+              //__func__, a2dp_lhdc_encoder_cb.lhdc_encoder_params.isLLEnabled ? A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS : A2DP_LHDC_ENCODER_INTERVAL_MS);
+  if (a2dp_lhdc_encoder_cb.lhdc_encoder_params.isLLEnabled){
+      return A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS;
+  }else{
+      return A2DP_LHDC_ENCODER_INTERVAL_MS;
+  }
+}
+
+void a2dp_vendor_lhdcv2_send_frames(uint64_t timestamp_us) {
+  uint8_t nb_frame = 0;
+  uint8_t nb_iterations = 0;
+
+  a2dp_lhdcv2_get_num_frame_iteration(&nb_iterations, &nb_frame, timestamp_us);
+  LOG_DEBUG(LOG_TAG, "%s: Sending %d frames per iteration, %d iterations",
+              __func__, nb_frame, nb_iterations);
+  if (nb_frame == 0) return;
+
+  for (uint8_t counter = 0; counter < nb_iterations; counter++) {
+    // Transcode frame and enqueue
+    if (a2dp_lhdc_encoder_cb.version <= 1) {
+        a2dp_lhdcv2_encode_frames(nb_frame);
+    }
+  }
+}
+
+// Obtains the number of frames to send and number of iterations
+// to be used. |num_of_iterations| and |num_of_frames| parameters
+// are used as output param for returning the respective values.
+static void a2dp_lhdcv2_get_num_frame_iteration(uint8_t* num_of_iterations,
+                                              uint8_t* num_of_frames,
+                                              uint64_t timestamp_us) {
+  uint32_t result = 0;
+  uint8_t nof = 0;
+  uint8_t noi = 1;
+  uint32_t pcm_bytes_per_frame = LHDCV2_BT_ENC_BLOCK_SIZE *
+      a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+      a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;;
+  //LOG_DEBUG(LOG_TAG, "%s: pcm_bytes_per_frame %u", __func__,
+//              pcm_bytes_per_frame);
+
+  int encoder_interval = a2dp_vendor_lhdcv2_get_encoder_interval_ms();
+  uint32_t us_this_tick = encoder_interval * 1000;
+  uint64_t now_us = timestamp_us;
+  if (a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us != 0)
+    us_this_tick =
+        (now_us - a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us);
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us = now_us;
+
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter +=
+      a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick * us_this_tick /
+      (encoder_interval * 1000);
+
+  result =
+      a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter / pcm_bytes_per_frame;
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter -=
+      result * pcm_bytes_per_frame;
+  nof = result;
+
+  //LOG_DEBUG(LOG_TAG, "%s: effective num of frames %u, iterations %u",
+//              __func__, nof, noi);
+
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.n_frames += nof;
+  if (a2dp_lhdc_encoder_cb.lhdc_feeding_state.n_frames > A2DP_LHDCV2_HDR_NUM_MAX) {
+    nof = A2DP_LHDCV2_HDR_NUM_MAX;
+  } else {
+    nof = a2dp_lhdc_encoder_cb.lhdc_feeding_state.n_frames;
+  }
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.n_frames -= nof;
+  *num_of_frames = nof;
+  *num_of_iterations = noi;
+}
+
+static BT_HDR *bt_buf_new( void) {
+    BT_HDR *p_buf = ( BT_HDR*)osi_malloc( BT_DEFAULT_BUFFER_SIZE);
+    if ( p_buf == NULL) {
+        // LeoKu(C): should not happen
+        LOG_ERROR( LOG_TAG, "%s: bt_buf_new failed!", __func__);
+        return  NULL;
+    }
+
+    p_buf->offset = A2DP_LHDC_OFFSET;
+    p_buf->len = 0;
+    p_buf->layer_specific = 0;
+    return  p_buf;
+}
+
+/**
+ * get lhdc frame header
+ */
+ /*
+static int a2dp_get_lhdc_header(uint8_t * in, lhdc_frame_Info_t * h) {
+    #define LHDC_HDR_LEN 4
+    uint32_t hdr = 0;
+    int ret = -1;
+    memcpy(&hdr, in , LHDC_HDR_LEN);
+    h->frame_len = ( int)( ( hdr >> 8) & 0x1fff);
+    h->isSplit = ( ( hdr & 0x00600000) == 0x00600000);
+    h->isLeft = ((hdr & 0xf) == 0);
+
+    if ( ( hdr & 0x4c000000) != 0x4c000000){
+        //printf( "lhdc hdr err!\n");
+    } else {
+        ret = 0;
+    }
+    return ret;
+}
+*/
+
+#include <vector>
+using namespace std;
+
+static void a2dp_lhdcv2_encode_frames(uint8_t nb_frame) {
+    BT_HDR * p_buf = NULL;
+    //BT_HDR * p_btBufs[128];
+    vector<BT_HDR * > btBufs;
+    uint8_t nb_frame_org = nb_frame;
+    //tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params =
+    //    &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+    uint32_t pcm_bytes_per_frame = LHDCV2_BT_ENC_BLOCK_SIZE *
+                                 a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+                                 a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
+
+
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN - 1);
+#else
+    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN);
+#endif
+    uint8_t * read_buffer = (uint8_t*)malloc(pcm_bytes_per_frame * 2);
+    uint8_t * write_buffer = (uint8_t*)&(read_buffer[pcm_bytes_per_frame]);
+    uint8_t latency = 0;//p_encoder_params->latency_mode_index;
+    int out_offset = 0;
+    int out_len = 0;
+    static uint32_t time_prev = bluetooth::common::time_get_os_boottime_ms();
+    static uint32_t allSendbytes = 0;
+    uint32_t bytes_read = 0;
+
+        while( nb_frame) {
+
+            uint32_t temp_bytes_read = 0;
+            if ( !a2dp_lhdcv2_read_feeding(read_buffer, &temp_bytes_read)) {
+            LOG_WARN(LOG_TAG, "%s: underflow %d", __func__, nb_frame);
+            a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter +=
+                      nb_frame * LHDCV2_BT_ENC_BLOCK_SIZE *
+                      a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+                      a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
+                break;
+            }
+            bytes_read += temp_bytes_read;
+            out_offset = 0;
+            out_len = lhdc_encode_func(a2dp_lhdc_encoder_cb.lhdc_handle, read_buffer, write_buffer);
+    #if defined(_RECODER_FILE_)
+            if (RecFile != NULL && out_len > 0) {
+                fwrite(write_buffer, sizeof(uint8_t), out_len, RecFile);
+            }
+    #endif
+            nb_frame--;
+
+            while (out_len > 0) {
+                if (p_buf == NULL) {
+                    if (NULL == (p_buf = bt_buf_new())) {
+                        LOG_ERROR (LOG_TAG, "%s: ERROR", __func__);
+                        if (read_buffer) {
+                            free(read_buffer);
+                            read_buffer = NULL;
+                        }
+                        for(BT_HDR*  p : btBufs) {
+                            free(p);
+                        }
+                        btBufs.clear();
+                        return;
+                    }
+                }
+
+                uint8_t *p = ( uint8_t *)( p_buf + 1) + p_buf->offset + p_buf->len;
+                int space = max_mtu_len - p_buf->len;
+                int bytes = ( out_len < space)? out_len : space;
+                memcpy( p, &write_buffer[out_offset], bytes);
+                out_offset += bytes;
+                out_len -= bytes;
+                p_buf->len += bytes;
+                allSendbytes += bytes;
+
+                if ( p_buf->len >= max_mtu_len ) {
+                    btBufs.push_back(p_buf);
+                    // allocate new one
+                    p_buf = NULL;
+                    if (btBufs.size() >= 64) {
+                        LOG_ERROR(LOG_TAG, "%s: Packet buffer usage to big!(%u)", __func__, (uint32_t)btBufs.size());
+                        break;
+                    }
+                }
+            }
+        }
+        uint32_t now_ms = bluetooth::common::time_get_os_boottime_ms();
+        if (now_ms - time_prev >= 1000 ) {
+            /* code */
+            LOG_WARN(LOG_TAG, "%s: Current data rate about %d kbps", __func__, (allSendbytes * 8) / 1000);
+            allSendbytes = 0;
+            time_prev = now_ms;
+        }
+
+        if ( p_buf) {
+            btBufs.push_back(p_buf);
+        }
+
+        LOG_DEBUG(LOG_TAG, "%s:btBufs.size() = %u", __func__, (uint32_t)btBufs.size());
+        if ( btBufs.size() == 1) {
+            p_buf = btBufs[0];
+
+            p_buf->layer_specific = a2dp_lhdc_encoder_cb.buf_seq++;
+            p_buf->layer_specific <<= 8;
+            p_buf->layer_specific |= ( latency | ( nb_frame_org << A2DP_LHDC_HDR_NUM_SHIFT));
+
+            *( ( uint32_t*)( p_buf + 1)) = a2dp_lhdc_encoder_cb.timestamp;
+
+            a2dp_lhdc_encoder_cb.enqueue_callback( p_buf, 1, bytes_read);
+            LOG_DEBUG (LOG_TAG, "%s: Read bytes(%d)", __func__, bytes_read);
+            bytes_read = 0;
+
+        } else {
+
+            uint8_t i;
+
+            for( i = 0; i < btBufs.size(); i++) {
+                p_buf = btBufs[i];
+
+                p_buf->layer_specific = a2dp_lhdc_encoder_cb.buf_seq++;
+                p_buf->layer_specific <<= 8;
+                p_buf->layer_specific |= ( A2DP_LHDC_HDR_F_MSK | latency);
+
+                if ( i == 0) {
+                    p_buf->layer_specific |= ( A2DP_LHDC_HDR_S_MSK | ( nb_frame_org << A2DP_LHDC_HDR_NUM_SHIFT));
+                } else if ( i == ( btBufs.size() - 1)) {
+                    p_buf->layer_specific |= A2DP_LHDC_HDR_L_MSK;
+                    bytes_read = 0;
+                }
+
+                *( ( uint32_t*)( p_buf + 1)) = a2dp_lhdc_encoder_cb.timestamp;
+
+                a2dp_lhdc_encoder_cb.enqueue_callback( p_buf, 1, bytes_read);
+                LOG_DEBUG (LOG_TAG, "%s: Read bytes(%d)", __func__, bytes_read);
+            }
+        }
+
+        a2dp_lhdc_encoder_cb.timestamp += ( nb_frame_org * LHDCV2_BT_ENC_BLOCK_SIZE);
+        if (read_buffer) {
+            free(read_buffer);
+            read_buffer = NULL;
+        }
+        btBufs.clear();
+}
+
+static bool a2dp_lhdcv2_read_feeding(uint8_t* read_buffer, uint32_t *bytes_read) {
+    uint32_t bytes_per_sample = a2dp_lhdc_encoder_cb.feeding_params.channel_count * a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
+    uint32_t read_size = LHDCV2_BT_ENC_BLOCK_SIZE * bytes_per_sample;
+
+
+  a2dp_lhdc_encoder_cb.stats.media_read_total_expected_reads_count++;
+  a2dp_lhdc_encoder_cb.stats.media_read_total_expected_read_bytes += read_size;
+
+  /* Read Data from UIPC channel */
+  uint32_t nb_byte_read =
+      a2dp_lhdc_encoder_cb.read_callback(read_buffer, read_size);
+  LOG_DEBUG(LOG_TAG, "%s: want to read size %u, read byte number %u",
+                    __func__, read_size, nb_byte_read);
+
+  if ((nb_byte_read % bytes_per_sample) != 0) {
+      LOG_ERROR(LOG_TAG, "%s: PCM data not alignment. The audio sample is shfit %d bytes.", __func__,(nb_byte_read % bytes_per_sample));
+  }
+  a2dp_lhdc_encoder_cb.stats.media_read_total_actual_read_bytes += nb_byte_read;
+
+  if (nb_byte_read < read_size) {
+    if (nb_byte_read == 0) return false;
+
+    /* Fill the unfilled part of the read buffer with silence (0) */
+    memset(((uint8_t*)read_buffer) + nb_byte_read, 0, read_size - nb_byte_read);
+    nb_byte_read = read_size;
+  }
+  a2dp_lhdc_encoder_cb.stats.media_read_total_actual_reads_count++;
+
+    *bytes_read = nb_byte_read;
+
+  return true;
+}
+
+// internal library: quality mode index table
+static std::string quality_mode_index_to_name(int quality_mode_index) {
+  switch (quality_mode_index) {
+    case LHDCBT_QUALITY_AUTO:
+      return "ABR";
+    case LHDCBT_QUALITY_HIGH:
+      return "HIGH";
+    case LHDCBT_QUALITY_MID:
+      return "MID";
+    case LHDCBT_QUALITY_LOW:
+      return "LOW";
+    case LHDCBT_QUALITY_LOW4:
+      return "LOW_320";
+    case LHDCBT_QUALITY_LOW3:
+      return "LOW_256";
+    case LHDCBT_QUALITY_LOW2:
+      return "LOW_192";
+    case LHDCBT_QUALITY_LOW1:
+      return "LOW_128";
+    case LHDCBT_QUALITY_LOW0:
+      return "LOW_64";
+    default:
+      return "Unknown";
+  }
+}
+/*
+static std::string latency_mode_index_to_name(int latency_mode_index){
+    switch (latency_mode_index) {
+      case A2DP_LHDC_LL_ENABLE:
+        return "LL is enabled";
+      case A2DP_LHDC_LL_DISABLE:
+        return "LL is diabled";
+      default:
+        return "Unknown";
+    }
+}
+*/
+
+void a2dp_vendor_lhdcv2_set_transmit_queue_length(size_t transmit_queue_length) {
+  a2dp_lhdc_encoder_cb.TxQueueLength = transmit_queue_length;
+  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params = &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+  LOG_DEBUG(LOG_TAG, "%s: transmit_queue_length %zu", __func__, transmit_queue_length);
+  if (p_encoder_params->quality_mode_index == LHDCBT_QUALITY_AUTO) {
+      LOG_DEBUG(LOG_TAG, "%s: Auto Bitrate Enabled!", __func__);
+      if (lhdc_auto_adjust_bitrate_func != NULL) {
+          lhdc_auto_adjust_bitrate_func(a2dp_lhdc_encoder_cb.lhdc_handle, transmit_queue_length);
+      }
+  }
+}
+
+uint64_t A2dpCodecConfigLhdcV2::encoderIntervalMs() const {
+  return a2dp_vendor_lhdcv2_get_encoder_interval_ms();
+}
+
+int A2dpCodecConfigLhdcV2::getEffectiveMtu() const {
+  return a2dp_lhdc_encoder_cb.TxAaMtuSize;
+}
+
+void A2dpCodecConfigLhdcV2::debug_codec_dump(int fd) {
+  a2dp_lhdc_encoder_stats_t* stats = &a2dp_lhdc_encoder_cb.stats;
+  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params =
+      &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+
+  A2dpCodecConfig::debug_codec_dump(fd);
+
+  dprintf(fd,
+          "  Packet counts (expected/dropped)                        : %zu / "
+          "%zu\n",
+          stats->media_read_total_expected_packets,
+          stats->media_read_total_dropped_packets);
+
+  dprintf(fd,
+          "  PCM read counts (expected/actual)                       : %zu / "
+          "%zu\n",
+          stats->media_read_total_expected_reads_count,
+          stats->media_read_total_actual_reads_count);
+
+  dprintf(fd,
+          "  PCM read bytes (expected/actual)                        : %zu / "
+          "%zu\n",
+          stats->media_read_total_expected_read_bytes,
+          stats->media_read_total_actual_read_bytes);
+
+  dprintf(
+      fd, "  LHDC quality mode                                       : %s\n",
+      quality_mode_index_to_name(p_encoder_params->quality_mode_index).c_str());
+
+  dprintf(fd,
+          "  LHDC transmission bitrate (Kbps)                        : %d\n",
+          lhdc_get_bitrate_func(a2dp_lhdc_encoder_cb.lhdc_handle));
+
+  dprintf(fd,
+          "  LHDC saved transmit queue length                        : %zu\n",
+          a2dp_lhdc_encoder_cb.TxQueueLength);
+/*
+  if (a2dp_lhdc_encoder_cb.has_lhdc_abr_handle) {
+    dprintf(fd,
+            "  LHDC adaptive bit rate encode quality mode index        : %d\n",
+            a2dp_lhdc_encoder_cb.last_lhdc_abr_eqmid);
+    dprintf(fd,
+            "  LHDC adaptive bit rate adjustments                      : %zu\n",
+            a2dp_lhdc_encoder_cb.lhdc_abr_adjustments);
+  }
+  */
+}
diff --git a/system/bt/stack/a2dp/a2dp_vendor_lhdcv3.cc b/system/bt/stack/a2dp/a2dp_vendor_lhdcv3.cc
new file mode 100755
index 00000000..8def0ef2
--- /dev/null
+++ b/system/bt/stack/a2dp/a2dp_vendor_lhdcv3.cc
@@ -0,0 +1,2613 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/******************************************************************************
+ *
+ *  Utility functions to help build and parse the LHDC Codec Information
+ *  Element and Media Payload.
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "a2dp_vendor_lhdcv3"
+
+#include "bt_target.h"
+
+#include "a2dp_vendor_lhdcv3.h"
+
+#include <string.h>
+
+#include <base/logging.h>
+#include "a2dp_vendor.h"
+#include "a2dp_vendor_lhdcv3_encoder.h"
+#include "bt_utils.h"
+#include "btif_av_co.h"
+#include "osi/include/log.h"
+#include "osi/include/osi.h"
+
+
+typedef struct {
+  btav_a2dp_codec_config_t *_codec_config_;
+  btav_a2dp_codec_config_t *_codec_capability_;
+  btav_a2dp_codec_config_t *_codec_local_capability_;
+  btav_a2dp_codec_config_t *_codec_selectable_capability_;
+  btav_a2dp_codec_config_t *_codec_user_config_;
+  btav_a2dp_codec_config_t *_codec_audio_config_;
+}tA2DP_CODEC_CONFIGS_PACK;
+
+typedef struct {
+  uint8_t   featureCode;    /* code definition for LHDC API ex: LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE */
+  uint8_t   inSpecBank;     /* in which specific bank */
+  uint8_t   bitPos;         /* at which bit index number of the specific bank */
+}tA2DP_LHDC_FEATURE_POS;
+
+/* source side metadata of JAS feature */
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_JAS = {
+    LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE,
+    LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
+    A2DP_LHDC_JAS_SPEC_BIT_POS,
+};
+/* source side metadata of AR feature */
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_AR = {
+    LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE,
+    LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
+    A2DP_LHDC_AR_SPEC_BIT_POS
+};
+/* source side metadata of LLAC feature */
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_LLAC = {
+    LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE,
+    LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
+    A2DP_LHDC_LLAC_SPEC_BIT_POS
+};
+/* source side metadata of META feature */
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_META = {
+    LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE,
+    LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
+    A2DP_LHDC_META_SPEC_BIT_POS
+};
+/* source side metadata of MBR feature */
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_MBR = {
+    LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE,
+    LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
+    A2DP_LHDC_MBR_SPEC_BIT_POS
+};
+/* source side metadata of LARC feature */
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_LARC = {
+    LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE,
+    LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
+    A2DP_LHDC_LARC_SPEC_BIT_POS
+};
+/* source side metadata of LHDCV4 feature */
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_LHDCV4 = {
+    LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE,
+    LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
+    A2DP_LHDC_V4_SPEC_BIT_POS
+};
+
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_all[] = {
+    a2dp_lhdc_source_caps_JAS,
+    a2dp_lhdc_source_caps_AR,
+    a2dp_lhdc_source_caps_LLAC,
+    a2dp_lhdc_source_caps_META,
+    a2dp_lhdc_source_caps_MBR,
+    a2dp_lhdc_source_caps_LARC,
+    a2dp_lhdc_source_caps_LHDCV4,
+};
+
+
+// data type for the LHDC Codec Information Element */
+// NOTE: bits_per_sample is needed only for LHDC encoder initialization.
+typedef struct {
+  uint32_t vendorId;
+  uint16_t codecId;    /* Codec ID for LHDC */
+  uint8_t sampleRate;  /* Sampling Frequency for LHDC*/
+  uint8_t llac_sampleRate;  /* Sampling Frequency for LLAC */
+  btav_a2dp_codec_bits_per_sample_t bits_per_sample;
+  uint8_t channelSplitMode;
+  uint8_t version;
+  uint8_t maxTargetBitrate;
+  bool isLLSupported;
+  //uint8_t supportedBitrate;
+  bool hasFeatureJAS;
+  bool hasFeatureAR;
+  bool hasFeatureLLAC;
+  bool hasFeatureMETA;
+  bool hasFeatureMinBitrate;
+  bool hasFeatureLARC;
+  bool hasFeatureLHDCV4;
+} tA2DP_LHDC_CIE;
+
+/* LHDC Source codec capabilities */
+static const tA2DP_LHDC_CIE a2dp_lhdc_source_caps = {
+    A2DP_LHDC_VENDOR_ID,  // vendorId
+    A2DP_LHDCV3_CODEC_ID,   // codecId
+    // sampleRate
+    //(A2DP_LHDC_SAMPLING_FREQ_48000),
+    (A2DP_LHDC_SAMPLING_FREQ_44100 | A2DP_LHDC_SAMPLING_FREQ_48000 | A2DP_LHDC_SAMPLING_FREQ_96000),
+	(A2DP_LHDC_SAMPLING_FREQ_48000),
+    // bits_per_sample
+    (BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16 | BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24),
+    //Channel Separation
+    //A2DP_LHDC_CH_SPLIT_NONE | A2DP_LHDC_CH_SPLIT_TWS,
+    A2DP_LHDC_BITRATE_ALL,
+    //Version number
+    A2DP_LHDC_VER3 | A2DP_LHDC_VER4 | A2DP_LHDC_VER6,
+    //Target bit Rate
+    A2DP_LHDC_MAX_BIT_RATE_900K,
+    //LL supported ?
+    true,
+
+    /*******************************
+     *  LHDC features/capabilities:
+     *  hasFeatureJAS
+     *  hasFeatureAR
+     *  hasFeatureLLAC
+     *  hasFeatureMETA
+     *  hasFeatureMinBitrate
+     *  hasFeatureLARC
+     *  hasFeatureLHDCV4
+     *******************************/
+    //bool hasFeatureJAS;
+    true,
+
+    //bool hasFeatureAR;
+    true,
+
+    //bool hasFeatureLLAC;
+    true,
+
+    //bool hasFeatureMETA;
+    true,
+
+    //bool hasFeatureMinBitrate;
+    true,
+
+    //bool hasFeatureLARC;
+    false,
+
+    //bool hasFeatureLHDCV4;
+    true,
+};
+    //(BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)};
+
+/* for response to API */
+static int A2DP_VendorGetSrcCapNumberLhdcv3()
+{
+  return (sizeof(a2dp_lhdc_source_caps_all) / sizeof(tA2DP_LHDC_FEATURE_POS) );
+}
+
+/* for response to API */
+bool A2DP_VendorGetSrcCapVectorLhdcv3(uint8_t *capVector)
+{
+    int capNumber = 0, run = 0;
+
+    if(!capVector)
+    {
+        LOG_ERROR(LOG_TAG, "%s: null buffer!", __func__);
+        return false;
+    }
+
+    /* count and check the number of source available capabilities */
+    capNumber = A2DP_VendorGetSrcCapNumberLhdcv3();
+
+    if(capNumber <= 0)
+    {
+      LOG_DEBUG(LOG_TAG, "%s: no capabilities, nothing to do!", __func__);
+      return true;
+    }
+
+    /* configure capabilities vector for LHDC API */
+    /* Byte-1:      featureCode
+     * Byte-2[7-6]: inSpecBank
+     * Byte-2[5-0]: bitPos
+     */
+    for(int i=0; i<capNumber; i++)
+    {
+      capVector[run] = a2dp_lhdc_source_caps_all[i].featureCode;
+      capVector[run+1] = a2dp_lhdc_source_caps_all[i].inSpecBank | a2dp_lhdc_source_caps_all[i].bitPos;
+      //LOG_DEBUG(LOG_TAG, "%s: fill cap(%d):[0x%02X 0x%02X]", __func__, i, capVector[run], capVector[run+1]);
+      run+=2;
+    }
+
+    return true;
+}
+
+/* Default LHDC codec configuration */
+static const tA2DP_LHDC_CIE a2dp_lhdc_default_config = {
+    A2DP_LHDC_VENDOR_ID,                // vendorId
+    A2DP_LHDCV3_CODEC_ID,                 // codecId
+    A2DP_LHDC_SAMPLING_FREQ_96000,      // LHDC default best sampleRate
+	A2DP_LHDC_SAMPLING_FREQ_48000,      // LLAC default best sampleRate
+    BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24,  // bits_per_sample
+    A2DP_LHDC_CH_SPLIT_NONE,
+    A2DP_LHDC_VER3,
+    A2DP_LHDC_MAX_BIT_RATE_900K,
+    false,
+
+    //bool hasFeatureJAS;
+    false,
+
+    //bool hasFeatureAR;
+    false,
+
+    //bool hasFeatureLLAC;
+    true,
+
+    //bool hasFeatureMETA;
+    false,
+
+    //bool hasFeatureMinBitrate;
+    true,
+
+    //bool hasFeatureLARC;
+    false,
+
+    //bool hasFeatureLHDCV4;
+    true,
+};
+
+static std::string lhdcV3_QualityModeBitRate_toString(uint32_t value) {
+  switch((int)value)
+  {
+  case A2DP_LHDC_QUALITY_ABR:
+    return "ABR";
+  case A2DP_LHDC_QUALITY_HIGH1:
+    return "HIGH 1 (1000 Kbps)";
+  case A2DP_LHDC_QUALITY_HIGH:
+    return "HIGH (900 Kbps)";
+  case A2DP_LHDC_QUALITY_MID:
+    return "MID (500 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW:
+    return "LOW (400 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW4:
+    return "LOW 4 (320 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW3:
+    return "LOW 3 (256 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW2:
+    return "LOW 2 (192 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW1:
+    return "LOW 1 (128 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW0:
+    return "LOW 0 (64 Kbps)";
+  default:
+    return "Unknown Bit Rate Mode";
+  }
+}
+
+static const tA2DP_ENCODER_INTERFACE a2dp_encoder_interface_lhdcv3 = {
+    a2dp_vendor_lhdcv3_encoder_init,
+    a2dp_vendor_lhdcv3_encoder_cleanup,
+    a2dp_vendor_lhdcv3_feeding_reset,
+    a2dp_vendor_lhdcv3_feeding_flush,
+    a2dp_vendor_lhdcv3_get_encoder_interval_ms,
+    a2dp_vendor_lhdcv3_send_frames,
+    a2dp_vendor_lhdcv3_set_transmit_queue_length};
+
+UNUSED_ATTR static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV3(
+    const tA2DP_LHDC_CIE* p_cap, const uint8_t* p_codec_info,
+    bool is_peer_codec_info);
+
+
+// Builds the LHDC Media Codec Capabilities byte sequence beginning from the
+// LOSC octet. |media_type| is the media type |AVDT_MEDIA_TYPE_*|.
+// |p_ie| is a pointer to the LHDC Codec Information Element information.
+// The result is stored in |p_result|. Returns A2DP_SUCCESS on success,
+// otherwise the corresponding A2DP error status code.
+static tA2DP_STATUS A2DP_BuildInfoLhdcV3(uint8_t media_type,
+                                       const tA2DP_LHDC_CIE* p_ie,
+                                       uint8_t* p_result) {
+
+  const uint8_t* tmpInfo = p_result;
+  if (p_ie == NULL || p_result == NULL) {
+    return A2DP_INVALID_PARAMS;
+  }
+
+  *p_result++ = A2DP_LHDCV3_CODEC_LEN;    //0
+  *p_result++ = (media_type << 4);      //1
+  *p_result++ = A2DP_MEDIA_CT_NON_A2DP; //2
+
+  // Vendor ID and Codec ID
+  *p_result++ = (uint8_t)(p_ie->vendorId & 0x000000FF); //3
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0x0000FF00) >> 8);  //4
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0x00FF0000) >> 16); //5
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0xFF000000) >> 24); //6
+  *p_result++ = (uint8_t)(p_ie->codecId & 0x00FF);  //7
+  *p_result++ = (uint8_t)((p_ie->codecId & 0xFF00) >> 8);   //8
+
+  // Sampling Frequency & Bits per sample
+  uint8_t para = 0;
+
+  // sample rate bit0 ~ bit2
+  para = (uint8_t)(p_ie->sampleRate & A2DP_LHDC_SAMPLING_FREQ_MASK);
+
+  if (p_ie->bits_per_sample == (BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24 | BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)) {
+      para = para | (A2DP_LHDC_BIT_FMT_24 | A2DP_LHDC_BIT_FMT_16);
+  }else if(p_ie->bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24){
+      para = para | A2DP_LHDC_BIT_FMT_24;
+  }else if(p_ie->bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16){
+      para = para | A2DP_LHDC_BIT_FMT_16;
+  }
+
+  if (p_ie->hasFeatureJAS)
+  {
+    para |= A2DP_LHDC_FEATURE_JAS;
+  }
+
+  if (p_ie->hasFeatureAR)
+  {
+    para |= A2DP_LHDC_FEATURE_AR;
+  }
+
+  // Save octet 9
+  *p_result++ = para;   //9
+
+  para = p_ie->version;
+
+  para |= p_ie->maxTargetBitrate;
+
+  para |= p_ie->isLLSupported ? A2DP_LHDC_LL_SUPPORTED : A2DP_LHDC_LL_NONE;
+
+  if (p_ie->hasFeatureLLAC)
+  {
+    para |= A2DP_LHDC_FEATURE_LLAC;
+  }
+
+  // Save octet 10
+  *p_result++ = para;   //a
+
+  //Save octet 11
+  para = p_ie->channelSplitMode;
+
+  if (p_ie->hasFeatureMETA)
+  {
+    para |= A2DP_LHDC_FEATURE_META;
+  }
+
+  if (p_ie->hasFeatureMinBitrate)
+  {
+    para |= A2DP_LHDC_FEATURE_MIN_BR;
+  }
+
+  if (p_ie->hasFeatureLARC)
+  {
+    para |= A2DP_LHDC_FEATURE_LARC;
+  }
+
+  if (p_ie->hasFeatureLHDCV4)
+  {
+    para |= A2DP_LHDC_FEATURE_LHDCV4;
+  }
+
+  *p_result++ = para;   //b
+
+  //Save octet 12
+  //para = p_ie->supportedBitrate;
+  //*p_result++ = para;   //c
+
+  LOG_DEBUG(LOG_TAG, "%s: Info build result = [0]:0x%x, [1]:0x%x, [2]:0x%x, [3]:0x%x, "
+                     "[4]:0x%x, [5]:0x%x, [6]:0x%x, [7]:0x%x, [8]:0x%x, [9]:0x%x, [10]:0x%x, [11]:0x%x",
+     __func__, tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3],
+                    tmpInfo[4], tmpInfo[5], tmpInfo[6], tmpInfo[7], tmpInfo[8], tmpInfo[9], tmpInfo[10], tmpInfo[11]);
+  return A2DP_SUCCESS;
+}
+
+// Parses the LHDC Media Codec Capabilities byte sequence beginning from the
+// LOSC octet. The result is stored in |p_ie|. The byte sequence to parse is
+// |p_codec_info|. If |is_capability| is true, the byte sequence is
+// codec capabilities, otherwise is codec configuration.
+// Returns A2DP_SUCCESS on success, otherwise the corresponding A2DP error
+// status code.
+static tA2DP_STATUS A2DP_ParseInfoLhdcV3(tA2DP_LHDC_CIE* p_ie,
+                                       const uint8_t* p_codec_info,
+                                       bool is_capability) {
+  uint8_t losc;
+  uint8_t media_type;
+  tA2DP_CODEC_TYPE codec_type;
+  const uint8_t* tmpInfo = p_codec_info;
+
+  //LOG_DEBUG(LOG_TAG, "%s: p_ie = %p, p_codec_info = %p", __func__, p_ie, p_codec_info);
+  if (p_ie == NULL || p_codec_info == NULL) return A2DP_INVALID_PARAMS;
+
+  // Check the codec capability length
+  losc = *p_codec_info++;
+
+  if (losc != A2DP_LHDCV3_CODEC_LEN) return A2DP_WRONG_CODEC;
+
+  media_type = (*p_codec_info++) >> 4;
+  codec_type = *p_codec_info++;
+    //LOG_DEBUG(LOG_TAG, "%s: media_type = %d, codec_type = %d", __func__, media_type, codec_type);
+  /* Check the Media Type and Media Codec Type */
+  if (media_type != AVDT_MEDIA_TYPE_AUDIO ||
+      codec_type != A2DP_MEDIA_CT_NON_A2DP) {
+    return A2DP_WRONG_CODEC;
+  }
+
+  // Check the Vendor ID and Codec ID */
+  p_ie->vendorId = (*p_codec_info & 0x000000FF) |
+                   (*(p_codec_info + 1) << 8 & 0x0000FF00) |
+                   (*(p_codec_info + 2) << 16 & 0x00FF0000) |
+                   (*(p_codec_info + 3) << 24 & 0xFF000000);
+  p_codec_info += 4;
+  p_ie->codecId =
+      (*p_codec_info & 0x00FF) | (*(p_codec_info + 1) << 8 & 0xFF00);
+  p_codec_info += 2;
+  LOG_VERBOSE(LOG_TAG, "%s:Vendor(0x%08x), Codec(0x%04x)", __func__, p_ie->vendorId, p_ie->codecId);
+  if (p_ie->vendorId != A2DP_LHDC_VENDOR_ID ||
+      p_ie->codecId != A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_WRONG_CODEC;
+  }
+
+  p_ie->sampleRate = *p_codec_info & A2DP_LHDC_SAMPLING_FREQ_MASK;
+  if ((*p_codec_info & A2DP_LHDC_BIT_FMT_MASK) == 0) {
+    return A2DP_WRONG_CODEC;
+  }
+
+  p_ie->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+  if (*p_codec_info & A2DP_LHDC_BIT_FMT_24)
+    p_ie->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+  if (*p_codec_info & A2DP_LHDC_BIT_FMT_16) {
+    p_ie->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+  }
+
+  p_ie->hasFeatureJAS = ((*p_codec_info & A2DP_LHDC_FEATURE_JAS) != 0) ? true : false;
+
+  p_ie->hasFeatureAR = ((*p_codec_info & A2DP_LHDC_FEATURE_AR) != 0) ? true : false;
+
+  p_codec_info += 1;
+
+  p_ie->version = (*p_codec_info) & A2DP_LHDC_VERSION_MASK;
+
+  p_ie->maxTargetBitrate = (*p_codec_info) & A2DP_LHDC_MAX_BIT_RATE_MASK;
+
+  p_ie->isLLSupported = ((*p_codec_info & A2DP_LHDC_LL_MASK) != 0)? true : false;
+
+  p_ie->hasFeatureLLAC = ((*p_codec_info & A2DP_LHDC_FEATURE_LLAC) != 0) ? true : false;
+
+  p_codec_info += 1;
+
+  p_ie->channelSplitMode = (*p_codec_info) & A2DP_LHDC_CH_SPLIT_MSK;
+
+  p_ie->hasFeatureMETA = ((*p_codec_info & A2DP_LHDC_FEATURE_META) != 0) ? true : false;
+
+  p_ie->hasFeatureMinBitrate = ((*p_codec_info & A2DP_LHDC_FEATURE_MIN_BR) != 0) ? true : false;
+
+  p_ie->hasFeatureLARC = ((*p_codec_info & A2DP_LHDC_FEATURE_LARC) != 0) ? true : false;
+
+  p_ie->hasFeatureLHDCV4 = ((*p_codec_info & A2DP_LHDC_FEATURE_LHDCV4) != 0) ? true : false;
+  
+  LOG_DEBUG(LOG_TAG, "%s:Has LL(%d) JAS(%d) AR(%d) META(%d) LLAC(%d) MBR(%d) LARC(%d) V4(%d)", __func__,
+      p_ie->isLLSupported,
+      p_ie->hasFeatureJAS,
+      p_ie->hasFeatureAR,
+      p_ie->hasFeatureMETA,
+      p_ie->hasFeatureLLAC,
+      p_ie->hasFeatureMinBitrate,
+      p_ie->hasFeatureLARC,
+      p_ie->hasFeatureLHDCV4);
+
+  LOG_DEBUG(LOG_TAG, "%s: codec info = [0]:0x%x, [1]:0x%x, [2]:0x%x, [3]:0x%x, [4]:0x%x, [5]:0x%x, [6]:0x%x, [7]:0x%x, [8]:0x%x, [9]:0x%x, [10]:0x%x, [11]:0x%x",
+            __func__, tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3], tmpInfo[4], tmpInfo[5], tmpInfo[6],
+                        tmpInfo[7], tmpInfo[8], tmpInfo[9], tmpInfo[10], tmpInfo[11]);
+
+  if (is_capability) return A2DP_SUCCESS;
+
+  if (A2DP_BitsSet(p_ie->sampleRate) != A2DP_SET_ONE_BIT)
+    return A2DP_BAD_SAMP_FREQ;
+
+  return A2DP_SUCCESS;
+}
+
+// Build the LHDC Media Payload Header.
+// |p_dst| points to the location where the header should be written to.
+// If |frag| is true, the media payload frame is fragmented.
+// |start| is true for the first packet of a fragmented frame.
+// |last| is true for the last packet of a fragmented frame.
+// If |frag| is false, |num| is the number of number of frames in the packet,
+// otherwise is the number of remaining fragments (including this one).
+/*
+static void A2DP_BuildMediaPayloadHeaderLhdc(uint8_t* p, uint16_t num) {
+  if (p == NULL) return;
+  *p = ( uint8_t)( num & 0xff);
+}
+*/
+
+bool A2DP_IsVendorSourceCodecValidLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE cfg_cie;
+
+  /* Use a liberal check when parsing the codec info */
+  return (A2DP_ParseInfoLhdcV3(&cfg_cie, p_codec_info, false) == A2DP_SUCCESS) ||
+         (A2DP_ParseInfoLhdcV3(&cfg_cie, p_codec_info, true) == A2DP_SUCCESS);
+}
+
+bool A2DP_IsVendorPeerSinkCodecValidLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE cfg_cie;
+
+  /* Use a liberal check when parsing the codec info */
+  return (A2DP_ParseInfoLhdcV3(&cfg_cie, p_codec_info, false) == A2DP_SUCCESS) ||
+         (A2DP_ParseInfoLhdcV3(&cfg_cie, p_codec_info, true) == A2DP_SUCCESS);
+}
+
+// Checks whether A2DP LHDC codec configuration matches with a device's codec
+// capabilities. |p_cap| is the LHDC codec configuration. |p_codec_info| is
+// the device's codec capabilities.
+// If |is_capability| is true, the byte sequence is codec capabilities,
+// otherwise is codec configuration.
+// |p_codec_info| contains the codec capabilities for a peer device that
+// is acting as an A2DP source.
+// Returns A2DP_SUCCESS if the codec configuration matches with capabilities,
+// otherwise the corresponding A2DP error status code.
+static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV3(
+    const tA2DP_LHDC_CIE* p_cap, const uint8_t* p_codec_info,
+    bool is_capability) {
+  tA2DP_STATUS status;
+  tA2DP_LHDC_CIE cfg_cie;
+
+  /* parse configuration */
+  status = A2DP_ParseInfoLhdcV3(&cfg_cie, p_codec_info, is_capability);
+  if (status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: parsing failed %d", __func__, status);
+    return status;
+  }
+
+  /* verify that each parameter is in range */
+
+  LOG_DEBUG(LOG_TAG, "%s: FREQ peer: 0x%x, capability 0x%x", __func__,
+            cfg_cie.sampleRate, p_cap->sampleRate);
+
+  LOG_DEBUG(LOG_TAG, "%s: BIT_FMT peer: 0x%x, capability 0x%x", __func__,
+            cfg_cie.bits_per_sample, p_cap->bits_per_sample);
+
+  /* sampling frequency */
+  if ((cfg_cie.sampleRate & p_cap->sampleRate) == 0) return A2DP_NS_SAMP_FREQ;
+
+  /* bit per sample */
+  if ((cfg_cie.bits_per_sample & p_cap->bits_per_sample) == 0) return A2DP_NS_CH_MODE;
+
+  return A2DP_SUCCESS;
+}
+
+bool A2DP_VendorUsesRtpHeaderLhdcV3(UNUSED_ATTR bool content_protection_enabled,
+                                  UNUSED_ATTR const uint8_t* p_codec_info) {
+  // TODO: Is this correct? The RTP header is always included?
+  return true;
+}
+
+const char* A2DP_VendorCodecNameLhdcV3(UNUSED_ATTR const uint8_t* p_codec_info) {
+  return "LHDC V3";
+}
+
+bool A2DP_VendorCodecTypeEqualsLhdcV3(const uint8_t* p_codec_info_a,
+                                    const uint8_t* p_codec_info_b) {
+  tA2DP_LHDC_CIE lhdc_cie_a;
+  tA2DP_LHDC_CIE lhdc_cie_b;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status =
+      A2DP_ParseInfoLhdcV3(&lhdc_cie_a, p_codec_info_a, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return false;
+  }
+  a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie_b, p_codec_info_b, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return false;
+  }
+
+  return true;
+}
+
+bool A2DP_VendorCodecEqualsLhdcV3(const uint8_t* p_codec_info_a,
+                                const uint8_t* p_codec_info_b) {
+  tA2DP_LHDC_CIE lhdc_cie_a;
+  tA2DP_LHDC_CIE lhdc_cie_b;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status =
+      A2DP_ParseInfoLhdcV3(&lhdc_cie_a, p_codec_info_a, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return false;
+  }
+  a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie_b, p_codec_info_b, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return false;
+  }
+
+  return (lhdc_cie_a.sampleRate == lhdc_cie_b.sampleRate) &&
+         (lhdc_cie_a.bits_per_sample == lhdc_cie_b.bits_per_sample) &&
+         /*(lhdc_cie_a.supportedBitrate == lhdc_cie_b.supportedBitrate) &&*/
+         (lhdc_cie_a.hasFeatureLLAC == lhdc_cie_b.hasFeatureLLAC) &&
+         (lhdc_cie_a.hasFeatureLHDCV4 == lhdc_cie_b.hasFeatureLHDCV4) &&
+         (lhdc_cie_a.isLLSupported == lhdc_cie_b.isLLSupported);
+}
+
+// Savitech Patch - START  Offload
+int A2DP_VendorGetBitRateLhdcV3(const uint8_t* p_codec_info) {
+
+  A2dpCodecConfig* current_codec = bta_av_get_a2dp_current_codec();
+  btav_a2dp_codec_config_t codec_config_ = current_codec->getCodecConfig();
+
+  if ((codec_config_.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) ==
+      A2DP_LHDC_QUALITY_MAGIC_NUM) {
+    switch ((int)(codec_config_.codec_specific_1 & 0xff)) {
+      case A2DP_LHDC_QUALITY_LOW0:
+        return 64000;
+      case A2DP_LHDC_QUALITY_LOW1:
+        return 128000;
+      case A2DP_LHDC_QUALITY_LOW2:
+        return 192000;
+      case A2DP_LHDC_QUALITY_LOW3:
+        return 256000;
+      case A2DP_LHDC_QUALITY_LOW4:
+        return 320000;
+      case A2DP_LHDC_QUALITY_LOW:
+        return 400000;
+      case A2DP_LHDC_QUALITY_MID:
+        return 600000;
+      case A2DP_LHDC_QUALITY_HIGH:
+        return 900000;
+      case A2DP_LHDC_QUALITY_ABR:
+        return 9999999;
+      case A2DP_LHDC_QUALITY_HIGH1:
+        [[fallthrough]];
+      default:
+        return -1;
+    }
+  }
+  return 400000;
+}
+// Savitech Patch - END
+
+int A2DP_VendorGetTrackSampleRateLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+  switch (lhdc_cie.sampleRate) {
+    case A2DP_LHDC_SAMPLING_FREQ_44100:
+      return 44100;
+    case A2DP_LHDC_SAMPLING_FREQ_48000:
+      return 48000;
+    case A2DP_LHDC_SAMPLING_FREQ_88200:
+      return 88200;
+    case A2DP_LHDC_SAMPLING_FREQ_96000:
+      return 96000;
+  }
+
+  return -1;
+}
+
+int A2DP_VendorGetTrackBitsPerSampleLhdcV3(const uint8_t* p_codec_info) {
+    tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+  switch (lhdc_cie.bits_per_sample) {
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+      return 16;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+      return 24;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
+      return 32;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+      return -1;
+  }
+}
+
+int A2DP_VendorGetTrackChannelCountLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+  return 2;
+}
+
+int A2DP_VendorGetChannelModeCodeLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+  return A2DP_LHDC_CHANNEL_MODE_STEREO;
+}
+
+bool A2DP_VendorGetPacketTimestampLhdcV3(UNUSED_ATTR const uint8_t* p_codec_info,
+                                       const uint8_t* p_data,
+                                       uint32_t* p_timestamp) {
+  // TODO: Is this function really codec-specific?
+  *p_timestamp = *(const uint32_t*)p_data;
+  return true;
+}
+
+int16_t A2DP_VendorGetMaxDatarateLhdcV3(const uint8_t* p_codec_info){
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+/*
+#define A2DP_LHDC_MAX_BIT_RATE_900K       0x00
+#define A2DP_LHDC_MAX_BIT_RATE_500K       0x10
+#define A2DP_LHDC_MAX_BIT_RATE_400K       0x20
+
+#define A2DP_LHDC_QUALITY_HIGH   7  // Equal to LHDCBT_EQMID_HQ 900kbps
+#define A2DP_LHDC_QUALITY_MID    6   // Equal to LHDCBT_EQMID_SQ 500/560kbps
+#define A2DP_LHDC_QUALITY_LOW    5   // Equal to LHDCBT_EQMID_MQ 400kbps
+*/
+  switch (lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) {
+      case A2DP_LHDC_MAX_BIT_RATE_900K:
+      return A2DP_LHDC_QUALITY_HIGH;
+      case A2DP_LHDC_MAX_BIT_RATE_500K:
+      return A2DP_LHDC_QUALITY_MID;
+      case A2DP_LHDC_MAX_BIT_RATE_400K:
+      return A2DP_LHDC_QUALITY_LOW;
+  }
+  return -1;
+}
+
+bool A2DP_VendorGetLowLatencyStateLhdcV3(const uint8_t* p_codec_info){
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+  LOG_DEBUG(LOG_TAG, "%s: isLLSupported =%d", __func__, lhdc_cie.isLLSupported);
+
+  return lhdc_cie.isLLSupported ? true : false;
+}
+
+
+
+
+//Always return newest version.
+uint8_t A2DP_VendorGetVersionLhdcV3(const uint8_t* p_codec_info){
+  tA2DP_LHDC_CIE lhdc_cie;
+  uint8_t result;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+
+  for (result = 0x08; result != 0; ) {
+    if ((lhdc_cie.version & result) != 0) {
+      break;
+    }
+    result >>= 1;
+  }
+  //LOG_DEBUG(LOG_TAG, "%s: version = 0x%02x, result = 0x%02x", __func__, lhdc_cie.version, result);
+
+
+  switch (result) {
+    case A2DP_LHDC_VER3:
+    return 1;
+    case A2DP_LHDC_VER4:
+    return 2;
+    case A2DP_LHDC_VER5:
+    return 3;
+    case A2DP_LHDC_VER6:
+    return 4;
+    default:
+    return -1;
+  }
+}
+
+
+int8_t A2DP_VendorGetChannelSplitModeLhdcV3(const uint8_t* p_codec_info){
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+  LOG_DEBUG(LOG_TAG, "%s: channelSplitMode =%d", __func__, lhdc_cie.channelSplitMode);
+
+  return lhdc_cie.channelSplitMode;
+
+}
+
+bool A2DP_VendorHasV4FlagLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+  if (A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false) != A2DP_SUCCESS)
+    return false;
+
+  return lhdc_cie.hasFeatureLHDCV4;
+}
+
+bool A2DP_VendorHasJASFlagLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+  if (A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false) != A2DP_SUCCESS)
+    return false;
+
+  return lhdc_cie.hasFeatureJAS;
+}
+
+bool A2DP_VendorHasARFlagLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+  if (A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false) != A2DP_SUCCESS)
+    return false;
+
+  return lhdc_cie.hasFeatureAR;
+}
+
+bool A2DP_VendorHasLLACFlagLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+  if (A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false) != A2DP_SUCCESS)
+    return false;
+
+  return lhdc_cie.hasFeatureLLAC;
+}
+
+bool A2DP_VendorHasMETAFlagLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+  if (A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false) != A2DP_SUCCESS)
+    return false;
+
+  return lhdc_cie.hasFeatureMETA;
+}
+
+bool A2DP_VendorHasMinBRFlagLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+  if (A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false) != A2DP_SUCCESS)
+    return false;
+
+  return lhdc_cie.hasFeatureMinBitrate;
+}
+
+bool A2DP_VendorHasLARCFlagLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+  if (A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false) != A2DP_SUCCESS)
+    return false;
+
+  return lhdc_cie.hasFeatureLARC;
+}
+
+bool A2DP_VendorBuildCodecHeaderLhdcV3(UNUSED_ATTR const uint8_t* p_codec_info,
+                                     BT_HDR* p_buf,
+                                     uint16_t frames_per_packet) {
+  uint8_t* p;
+
+  p_buf->offset -= A2DP_LHDC_MPL_HDR_LEN;
+  p = (uint8_t*)(p_buf + 1) + p_buf->offset;
+  p_buf->len += A2DP_LHDC_MPL_HDR_LEN;
+  p[0] = ( uint8_t)( frames_per_packet & 0xff);
+  p[1] = ( uint8_t)( ( frames_per_packet >> 8) & 0xff);
+  //A2DP_BuildMediaPayloadHeaderLhdc(p, frames_per_packet);
+  return true;
+}
+
+void A2DP_VendorDumpCodecInfoLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_STATUS a2dp_status;
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  LOG_DEBUG(LOG_TAG, "%s", __func__);
+
+  a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: A2DP_ParseInfoLhdcV3 fail:%d", __func__, a2dp_status);
+    return;
+  }
+
+  LOG_DEBUG(LOG_TAG, "\tsamp_freq: 0x%x", lhdc_cie.sampleRate);
+  if (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+    LOG_DEBUG(LOG_TAG, "\tsamp_freq: (44100)");
+  }
+  if (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+    LOG_DEBUG(LOG_TAG, "\tsamp_freq: (48000)");
+  }
+  if (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+    LOG_DEBUG(LOG_TAG, "\tsamp_freq: (88200)");
+  }
+  if (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+    LOG_DEBUG(LOG_TAG, "\tsamp_freq: (96000)");
+  }
+}
+
+std::string A2DP_VendorCodecInfoStringLhdcV3(const uint8_t* p_codec_info) {
+  std::stringstream res;
+  std::string field;
+  tA2DP_STATUS a2dp_status;
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    res << "A2DP_ParseInfoLhdcV3 fail: " << loghex(a2dp_status);
+    return res.str();
+  }
+
+  res << "\tname: LHDC\n";
+
+  // Sample frequency
+  field.clear();
+  AppendField(&field, (lhdc_cie.sampleRate == 0), "NONE");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100),
+              "44100");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000),
+              "48000");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200),
+              "88200");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000),
+              "96000");
+  res << "\tsamp_freq: " << field << " (" << loghex(lhdc_cie.sampleRate)
+      << ")\n";
+
+  // Channel mode
+  field.clear();
+  AppendField(&field, 1,
+             "Stereo");
+  res << "\tch_mode: " << field << " (" << "Only support stereo."
+      << ")\n";
+
+  // bits per sample
+  field.clear();
+  AppendField(&field, (lhdc_cie.bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16),
+              "16");
+  AppendField(&field, (lhdc_cie.bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24),
+              "24");
+  res << "\tbits_depth: " << field << " bits (" << loghex((int)lhdc_cie.bits_per_sample)
+      << ")\n";
+
+  // Max data rate...
+  field.clear();
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_900K),
+              "900Kbps");
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_500K),
+              "500Kbps");
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_400K),
+              "400Kbps");
+  res << "\tMax target-rate: " << field << " (" << loghex((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK))
+      << ")\n";
+
+  // Version
+  field.clear();
+  AppendField(&field, (lhdc_cie.version == A2DP_LHDC_VER3),
+              "LHDC V3");
+  res << "\tversion: " << field << " (" << loghex(lhdc_cie.version)
+      << ")\n";
+
+
+  /*
+  field.clear();
+  AppendField(&field, 0, "NONE");
+  AppendField(&field, 0,
+              "Mono");
+  AppendField(&field, 0,
+              "Dual");
+  AppendField(&field, 1,
+              "Stereo");
+  res << "\tch_mode: " << field << " (" << loghex(lhdc_cie.channelMode)
+      << ")\n";
+*/
+  return res.str();
+}
+
+const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterfaceLhdcV3(
+    const uint8_t* p_codec_info) {
+  if (!A2DP_IsVendorSourceCodecValidLhdcV3(p_codec_info)) return NULL;
+
+  return &a2dp_encoder_interface_lhdcv3;
+}
+
+bool A2DP_VendorAdjustCodecLhdcV3(uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE cfg_cie;
+
+  // Nothing to do: just verify the codec info is valid
+  if (A2DP_ParseInfoLhdcV3(&cfg_cie, p_codec_info, true) != A2DP_SUCCESS)
+    return false;
+
+  return true;
+}
+
+btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndexLhdcV3(
+    UNUSED_ATTR const uint8_t* p_codec_info) {
+  return BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3;
+}
+
+const char* A2DP_VendorCodecIndexStrLhdcV3(void) { return "LHDC V3"; }
+
+bool A2DP_VendorInitCodecConfigLhdcV3(AvdtpSepConfig* p_cfg) {
+  if (A2DP_BuildInfoLhdcV3(AVDT_MEDIA_TYPE_AUDIO, &a2dp_lhdc_source_caps,
+                         p_cfg->codec_info) != A2DP_SUCCESS) {
+    return false;
+  }
+
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+  /* Content protection info - support SCMS-T */
+  uint8_t* p = p_cfg->protect_info;
+  *p++ = AVDT_CP_LOSC;
+  UINT16_TO_STREAM(p, AVDT_CP_SCMS_T_ID);
+  p_cfg->num_protect = 1;
+#endif
+
+  return true;
+}
+
+UNUSED_ATTR static void build_codec_config(const tA2DP_LHDC_CIE& config_cie,
+                                           btav_a2dp_codec_config_t* result) {
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+
+  result->bits_per_sample = config_cie.bits_per_sample;
+
+  result->channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+}
+
+A2dpCodecConfigLhdcV3::A2dpCodecConfigLhdcV3(
+    btav_a2dp_codec_priority_t codec_priority)
+    : A2dpCodecConfig(BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3, "LHDC V3",
+                      codec_priority) {
+  // Compute the local capability
+  if (a2dp_lhdc_source_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+  }
+  if (a2dp_lhdc_source_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+  }
+  if (a2dp_lhdc_source_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+  }
+  if (a2dp_lhdc_source_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+  }
+  codec_local_capability_.bits_per_sample = a2dp_lhdc_source_caps.bits_per_sample;
+
+  codec_local_capability_.channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+}
+
+A2dpCodecConfigLhdcV3::~A2dpCodecConfigLhdcV3() {}
+
+bool A2dpCodecConfigLhdcV3::init() {
+  if (!isValid()) return false;
+
+  // Load the encoder
+  if (!A2DP_VendorLoadEncoderLhdcV3()) {
+    LOG_ERROR(LOG_TAG, "%s: cannot load the encoder", __func__);
+    return false;
+  }
+
+  return true;
+}
+
+bool A2dpCodecConfigLhdcV3::useRtpHeaderMarkerBit() const { return false; }
+
+//
+// Selects the best sample rate from |sampleRate|.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_best_sample_rate(uint8_t sampleRate,
+                                    tA2DP_LHDC_CIE* p_result,
+                                    btav_a2dp_codec_config_t* p_codec_config) {
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+    return true;
+  }
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+    return true;
+  }
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    return true;
+  }
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    return true;
+  }
+  return false;
+}
+
+//
+// Selects the audio sample rate from |p_codec_audio_config|.
+// |sampleRate| contains the capability.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_audio_sample_rate(
+    const btav_a2dp_codec_config_t* p_codec_audio_config, uint8_t sampleRate,
+    tA2DP_LHDC_CIE* p_result, btav_a2dp_codec_config_t* p_codec_config) {
+  switch (p_codec_audio_config->sample_rate) {
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
+        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
+        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
+        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_16000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_24000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
+      break;
+  }
+  return false;
+}
+
+//
+// Selects the best bits per sample from |bits_per_sample|.
+// |bits_per_sample| contains the capability.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_best_bits_per_sample(
+    btav_a2dp_codec_bits_per_sample_t bits_per_sample, tA2DP_LHDC_CIE* p_result,
+    btav_a2dp_codec_config_t* p_codec_config) {
+  if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+    p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+    return true;
+  }
+  if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    return true;
+  }
+  return false;
+}
+
+//
+// Selects the audio bits per sample from |p_codec_audio_config|.
+// |bits_per_sample| contains the capability.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_audio_bits_per_sample(
+    const btav_a2dp_codec_config_t* p_codec_audio_config,
+    btav_a2dp_codec_bits_per_sample_t bits_per_sample, tA2DP_LHDC_CIE* p_result,
+    btav_a2dp_codec_config_t* p_codec_config) {
+  switch (p_codec_audio_config->bits_per_sample) {
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+        p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+        p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+        p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+        p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+      break;
+  }
+  return false;
+}
+
+bool A2dpCodecConfigLhdcV3::copySinkCapability(uint8_t * codec_info){
+    std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
+    memcpy(codec_info, ota_codec_peer_capability_, AVDT_CODEC_SIZE);
+    return true;
+}
+
+static bool A2DP_IsFeatureInUserConfigLhdcV3(tA2DP_CODEC_CONFIGS_PACK* cfgsPtr, uint8_t featureCode)
+{
+  switch(featureCode)
+  {
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_JAS.inSpecBank, A2DP_LHDC_JAS_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_AR.inSpecBank, A2DP_LHDC_AR_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_META.inSpecBank, A2DP_LHDC_META_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_LLAC.inSpecBank, A2DP_LHDC_LLAC_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_MBR.inSpecBank, A2DP_LHDC_MBR_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_LARC.inSpecBank, A2DP_LHDC_LARC_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_LHDCV4.inSpecBank, A2DP_LHDC_V4_ENABLED);
+      }
+      break;
+
+  default:
+    break;
+  }
+
+  return false;
+}
+static bool A2DP_IsFeatureInCodecConfigLhdcV3(tA2DP_CODEC_CONFIGS_PACK* cfgsPtr, uint8_t featureCode)
+{
+  switch(featureCode)
+  {
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_JAS.inSpecBank, A2DP_LHDC_JAS_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_AR.inSpecBank, A2DP_LHDC_AR_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_META.inSpecBank, A2DP_LHDC_META_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_LLAC.inSpecBank, A2DP_LHDC_LLAC_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_MBR.inSpecBank, A2DP_LHDC_MBR_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_LARC.inSpecBank, A2DP_LHDC_LARC_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_LHDCV4.inSpecBank, A2DP_LHDC_V4_ENABLED);
+      }
+      break;
+
+  default:
+    break;
+  }
+
+  return false;
+}
+
+static void A2DP_UpdateFeatureToSpecLhdcV3(tA2DP_CODEC_CONFIGS_PACK* cfgsPtr,
+    uint16_t toCodecCfg, bool hasFeature, uint8_t toSpec, int64_t value)
+{
+  if(toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_CONFIG_)
+  {
+    SETUP_A2DP_SPEC(cfgsPtr->_codec_config_, toSpec, hasFeature, value);
+  }
+  if(toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_CAP_)
+  {
+    SETUP_A2DP_SPEC(cfgsPtr->_codec_capability_, toSpec, hasFeature, value);
+  }
+  if(toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_LOCAL_CAP_)
+  {
+    SETUP_A2DP_SPEC(cfgsPtr->_codec_local_capability_, toSpec, hasFeature, value);
+  }
+  if(toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_)
+  {
+    SETUP_A2DP_SPEC(cfgsPtr->_codec_selectable_capability_, toSpec, hasFeature, value);
+  }
+  if(toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_USER_)
+  {
+    SETUP_A2DP_SPEC(cfgsPtr->_codec_user_config_, toSpec, hasFeature, value);
+  }
+  if(toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_AUDIO_)
+  {
+    SETUP_A2DP_SPEC(cfgsPtr->_codec_audio_config_, toSpec, hasFeature, value);
+  }
+}
+
+static void A2DP_UpdateFeatureToA2dpConfigLhdcV3(tA2DP_CODEC_CONFIGS_PACK *cfgsPtr,
+    uint8_t featureCode,  uint16_t toCodecCfg, bool hasFeature)
+{
+
+  //LOG_DEBUG(LOG_TAG, "%s: featureCode:0x%02X toCfgs:0x%04X, toSet:%d", __func__, featureCode, toCodecCfg, hasFeature);
+
+  switch(featureCode)
+  {
+  case LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE:
+    A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdc_source_caps_JAS.inSpecBank, A2DP_LHDC_JAS_ENABLED);
+    break;
+  case LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE:
+    A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdc_source_caps_AR.inSpecBank, A2DP_LHDC_AR_ENABLED);
+    break;
+  case LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE:
+    A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdc_source_caps_META.inSpecBank, A2DP_LHDC_META_ENABLED);
+    break;
+  case LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE:
+    A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdc_source_caps_LLAC.inSpecBank, A2DP_LHDC_LLAC_ENABLED);
+    break;
+  case LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE:
+    A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdc_source_caps_MBR.inSpecBank, A2DP_LHDC_MBR_ENABLED);
+    break;
+  case LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE:
+    A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdc_source_caps_LARC.inSpecBank, A2DP_LHDC_LARC_ENABLED);
+    break;
+  case LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE:
+    A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdc_source_caps_LHDCV4.inSpecBank, A2DP_LHDC_V4_ENABLED);
+    break;
+
+  default:
+    break;
+  }
+}
+
+
+static uint32_t A2DP_MaxBitRatetoQualityLevelLhdcV3(uint8_t maxTargetBitrate)
+{
+	switch (maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK)
+	{
+	case A2DP_LHDC_MAX_BIT_RATE_900K:
+		return A2DP_LHDC_QUALITY_HIGH;
+	case A2DP_LHDC_MAX_BIT_RATE_500K:
+		return A2DP_LHDC_QUALITY_MID;
+	case A2DP_LHDC_MAX_BIT_RATE_400K:
+		return A2DP_LHDC_QUALITY_LOW;
+	default:
+		return (0xFF);
+	}
+}
+
+
+bool A2dpCodecConfigLhdcV3::setCodecConfig(const uint8_t* p_peer_codec_info,
+                                         bool is_capability,
+                                         uint8_t* p_result_codec_config) {
+  std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
+  tA2DP_LHDC_CIE sink_info_cie;
+  tA2DP_LHDC_CIE result_config_cie;
+  uint8_t sampleRate;
+  bool isLLEnabled;
+  bool hasFeature;
+  uint32_t quality_mode, maxBitRate_Qmode;
+  //uint8_t supportedBitrate;
+  btav_a2dp_codec_bits_per_sample_t bits_per_sample;
+
+  // Save the internal state
+  btav_a2dp_codec_config_t saved_codec_config = codec_config_;
+  btav_a2dp_codec_config_t saved_codec_capability = codec_capability_;
+  btav_a2dp_codec_config_t saved_codec_selectable_capability =
+      codec_selectable_capability_;
+  btav_a2dp_codec_config_t saved_codec_user_config = codec_user_config_;
+  btav_a2dp_codec_config_t saved_codec_audio_config = codec_audio_config_;
+  uint8_t saved_ota_codec_config[AVDT_CODEC_SIZE];
+  uint8_t saved_ota_codec_peer_capability[AVDT_CODEC_SIZE];
+  uint8_t saved_ota_codec_peer_config[AVDT_CODEC_SIZE];
+  memcpy(saved_ota_codec_config, ota_codec_config_, sizeof(ota_codec_config_));
+  memcpy(saved_ota_codec_peer_capability, ota_codec_peer_capability_,
+         sizeof(ota_codec_peer_capability_));
+  memcpy(saved_ota_codec_peer_config, ota_codec_peer_config_,
+         sizeof(ota_codec_peer_config_));
+
+  tA2DP_CODEC_CONFIGS_PACK allCfgPack;
+  allCfgPack._codec_config_ = &codec_config_;
+  allCfgPack._codec_capability_ = &codec_capability_;
+  allCfgPack._codec_local_capability_ = &codec_local_capability_;
+  allCfgPack._codec_selectable_capability_ = &codec_selectable_capability_;
+  allCfgPack._codec_user_config_ = &codec_user_config_;
+  allCfgPack._codec_audio_config_ = &codec_audio_config_;
+
+  tA2DP_STATUS status =
+      A2DP_ParseInfoLhdcV3(&sink_info_cie, p_peer_codec_info, is_capability);
+  if (status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: can't parse peer's Sink capabilities: error = %d",
+              __func__, status);
+    goto fail;
+  }
+
+  //
+  // Build the preferred configuration
+  //
+  memset(&result_config_cie, 0, sizeof(result_config_cie));
+  result_config_cie.vendorId = a2dp_lhdc_source_caps.vendorId;
+  result_config_cie.codecId = a2dp_lhdc_source_caps.codecId;
+
+
+  LOG_DEBUG(LOG_TAG, "%s: incoming version: peer(0x%02x), host(0x%02x)",
+            __func__, sink_info_cie.version, a2dp_lhdc_source_caps.version);
+
+  // 2021/08/19: when sink's version is "V3_NotComapatible(version == A2DP_LHDC_VER6(0x8))",
+  //				wrap it to A2DP_LHDC_VER3 to accept and treat as an A2DP_LHDC_VER3 device.
+  if(sink_info_cie.version == A2DP_LHDC_VER6) {
+	  sink_info_cie.version = A2DP_LHDC_VER3;
+	  LOG_DEBUG(LOG_TAG, "%s: wrap V3_NotComapatible sink version to A2DP_LHDC_VER3", __func__);
+  }
+
+  if ((sink_info_cie.version & a2dp_lhdc_source_caps.version) == 0) {
+    LOG_ERROR(LOG_TAG, "%s: Sink versoin unsupported! peer(0x%02x), host(0x%02x)",
+              __func__, sink_info_cie.version, a2dp_lhdc_source_caps.version);
+    goto fail;
+  }
+  result_config_cie.version = sink_info_cie.version;
+
+
+/*
+  if (sink_info_cie.channelSplitMode & A2DP_LHDC_CH_SPLIT_TWS) {
+      result_config_cie.channelSplitMode = A2DP_LHDC_CH_SPLIT_TWS;
+  }else{
+      result_config_cie.channelSplitMode = A2DP_LHDC_CH_SPLIT_NONE;
+  }
+  */
+
+  LOG_DEBUG(LOG_TAG, "%s: Enter User_SP1=(0x%016llX); SP2=(0x%016llX); SP3=(0x%016llX); SP4=(0x%016llX)", __func__,
+		  (unsigned long long)(codec_user_config_.codec_specific_1),
+		  (unsigned long long)(codec_user_config_.codec_specific_2),
+		  (unsigned long long)(codec_user_config_.codec_specific_3),
+		  (unsigned long long)(codec_user_config_.codec_specific_4));
+  LOG_DEBUG(LOG_TAG, "%s: Enter Codec_SP1=(0x%016llX); SP2=(0x%016llX); SP3=(0x%016llX); SP4=(0x%016llX)", __func__,
+		  (unsigned long long)(codec_config_.codec_specific_1),
+		  (unsigned long long)(codec_config_.codec_specific_2),
+		  (unsigned long long)(codec_config_.codec_specific_3),
+		  (unsigned long long)(codec_config_.codec_specific_4));
+
+  /*******************************************
+   * Update Capabilities: LHDC Low Latency
+   * to A2DP specifics 2
+   *******************************************/
+  isLLEnabled = (a2dp_lhdc_source_caps.isLLSupported & sink_info_cie.isLLSupported);
+  result_config_cie.isLLSupported = false;
+  switch (codec_user_config_.codec_specific_2 & A2DP_LHDC_LL_ENABLED) {
+    case A2DP_LHDC_LL_ENABLE:
+    if (isLLEnabled) {
+      result_config_cie.isLLSupported = true;
+      codec_config_.codec_specific_2 |= A2DP_LHDC_LL_ENABLED;
+    }
+    break;
+    case A2DP_LHDC_LL_DISABLE:
+    if (!isLLEnabled) {
+      result_config_cie.isLLSupported = false;
+      codec_config_.codec_specific_2 &= ~A2DP_LHDC_LL_ENABLED;
+    }
+    break;
+  }
+  if (isLLEnabled) {
+    codec_selectable_capability_.codec_specific_2 |= A2DP_LHDC_LL_ENABLED;
+    codec_capability_.codec_specific_2 |= A2DP_LHDC_LL_ENABLED;
+  }
+  //result_config_cie.isLLSupported = sink_info_cie.isLLSupported;
+  LOG_DEBUG(LOG_TAG, "%s: isLLSupported, Sink(0x%02x) Set(0x%08x), result(0x%02x)", __func__,
+                                sink_info_cie.isLLSupported,
+                                (uint32_t)codec_user_config_.codec_specific_2,
+                                result_config_cie.isLLSupported);
+
+  //
+  // Select the sample frequency
+  //
+  sampleRate = a2dp_lhdc_source_caps.sampleRate & sink_info_cie.sampleRate;
+  LOG_DEBUG(LOG_TAG, "%s: sampleRate src:0x%x sink:0x%x matched:0x%x", __func__,
+		  a2dp_lhdc_source_caps.sampleRate, sink_info_cie.sampleRate, sampleRate);
+
+  codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+  switch (codec_user_config_.sample_rate) {
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
+        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+        codec_config_.sample_rate = codec_user_config_.sample_rate;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+        codec_config_.sample_rate = codec_user_config_.sample_rate;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
+        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+        codec_config_.sample_rate = codec_user_config_.sample_rate;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
+        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+        codec_config_.sample_rate = codec_user_config_.sample_rate;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_16000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_24000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
+      codec_capability_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+      codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+      break;
+  }
+
+  // Select the sample frequency if there is no user preference
+  do {
+    // Compute the selectable capability
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+      codec_selectable_capability_.sample_rate |=
+          BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    }
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+      codec_selectable_capability_.sample_rate |=
+          BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    }
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+      codec_selectable_capability_.sample_rate |=
+          BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+    }
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+      codec_selectable_capability_.sample_rate |=
+          BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+    }
+
+    //Above Parts: if codec_config is setup successfully(ie., sampleRate in codec_user_config_ is valid), ignore following parts.
+    if (codec_config_.sample_rate != BTAV_A2DP_CODEC_SAMPLE_RATE_NONE) {
+    	LOG_DEBUG(LOG_TAG, "%s: setup sample_rate:0x%x from user_config", __func__, codec_config_.sample_rate);
+    	break;
+    }
+    //Below Parts: if codec_config is still not setup successfully, test default sample rate or use the best match
+
+    // Compute the common capability
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+
+    // No user preference - try the codec audio config
+    if (select_audio_sample_rate(&codec_audio_config_, sampleRate,
+                                 &result_config_cie, &codec_config_)) {
+      LOG_DEBUG(LOG_TAG, "%s: select audio sample rate:(0x%x)", __func__, result_config_cie.sampleRate);
+      break;
+    }
+
+    // No user preference - try the default config
+    if (sink_info_cie.hasFeatureLLAC) {
+      if (select_best_sample_rate(
+              a2dp_lhdc_default_config.llac_sampleRate & sink_info_cie.sampleRate,
+              &result_config_cie, &codec_config_)) {
+    	LOG_DEBUG(LOG_TAG, "%s: select best sample rate(LLAC default):0x%x", __func__, result_config_cie.sampleRate);
+        break;
+      }
+    } else {
+      if (select_best_sample_rate(
+              a2dp_lhdc_default_config.sampleRate & sink_info_cie.sampleRate,
+              &result_config_cie, &codec_config_)) {
+        LOG_DEBUG(LOG_TAG, "%s: select best sample rate(LHDC default):0x%x", __func__, result_config_cie.sampleRate);
+        break;
+      }
+    }
+
+    // No user preference - use the best match
+    if (select_best_sample_rate(sampleRate, &result_config_cie,
+                                &codec_config_)) {
+      LOG_DEBUG(LOG_TAG, "%s: select best sample rate(best):0x%x", __func__, result_config_cie.sampleRate);
+      break;
+    }
+  } while (false);
+  if (codec_config_.sample_rate == BTAV_A2DP_CODEC_SAMPLE_RATE_NONE) {
+    LOG_ERROR(LOG_TAG,
+              "%s: cannot match sample frequency: source caps = 0x%x "
+              "sink info = 0x%x",
+              __func__, a2dp_lhdc_source_caps.sampleRate, sink_info_cie.sampleRate);
+    goto fail;
+  }
+
+  //
+  // Select the bits per sample
+  //
+  // NOTE: this information is NOT included in the LHDC A2DP codec description
+  // that is sent OTA.
+  bits_per_sample = a2dp_lhdc_source_caps.bits_per_sample & sink_info_cie.bits_per_sample;
+  LOG_DEBUG(LOG_TAG, "%s: bits_per_sample src:0x%02x sink:0x%02x matched:0x%02x", __func__,
+		  a2dp_lhdc_source_caps.bits_per_sample, sink_info_cie.bits_per_sample, bits_per_sample);
+  codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+  switch (codec_user_config_.bits_per_sample) {
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+        result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+        codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
+        codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
+      }
+      break;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+        result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+        codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
+        codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
+      }
+      break;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+      result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+      codec_capability_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+      codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+      break;
+  }
+
+  // Select the bits per sample if there is no user preference
+  do {
+    // Compute the selectable capability
+      // Compute the selectable capability
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)
+        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24)
+        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+
+    if (codec_config_.bits_per_sample != BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE){
+    	LOG_DEBUG(LOG_TAG, "%s: setup bit_per_sample:0x%02x user_config", __func__, codec_config_.bits_per_sample);
+    	break;
+    }
+
+    // Compute the common capability
+    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)
+      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24)
+      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+
+    // No user preference - the the codec audio config
+    if (select_audio_bits_per_sample(&codec_audio_config_, bits_per_sample,
+                                     &result_config_cie, &codec_config_)) {
+      LOG_DEBUG(LOG_TAG, "%s: select audio bits_per_sample:0x%x", __func__, result_config_cie.bits_per_sample);
+      break;
+    }
+
+    // No user preference - try the default config
+    if (select_best_bits_per_sample(a2dp_lhdc_default_config.bits_per_sample & sink_info_cie.bits_per_sample,
+                                    &result_config_cie, &codec_config_)) {
+      LOG_DEBUG(LOG_TAG, "%s: select best bits_per_sample(default):0x%x", __func__, result_config_cie.bits_per_sample);
+      break;
+    }
+
+    // No user preference - use the best match
+    if (select_best_bits_per_sample(bits_per_sample,
+                                    &result_config_cie, &codec_config_)) {
+      LOG_DEBUG(LOG_TAG, "%s: select best bits_per_sample(best):0x%x", __func__, result_config_cie.bits_per_sample);
+      break;
+    }
+  } while (false);
+  if (codec_config_.bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE) {
+    LOG_ERROR(LOG_TAG,
+              "%s: cannot match bits per sample: default = 0x%x "
+              "user preference = 0x%x",
+              __func__, a2dp_lhdc_default_config.bits_per_sample,
+              codec_user_config_.bits_per_sample);
+    goto fail;
+  }
+
+  //
+  // Select the channel mode
+  //
+  LOG_DEBUG(LOG_TAG, "%s: channelMode = Only supported stereo", __func__);
+  codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
+  switch (codec_user_config_.channel_mode) {
+    case BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO:
+      codec_capability_.channel_mode = codec_user_config_.channel_mode;
+      codec_config_.channel_mode = codec_user_config_.channel_mode;
+      break;
+    case BTAV_A2DP_CODEC_CHANNEL_MODE_MONO:
+    case BTAV_A2DP_CODEC_CHANNEL_MODE_NONE:
+      codec_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
+      codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
+      break;
+  }
+  codec_selectable_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  codec_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  if (codec_config_.channel_mode == BTAV_A2DP_CODEC_CHANNEL_MODE_NONE) {
+    LOG_ERROR(LOG_TAG,
+              "%s: codec_config_.channel_mode != BTAV_A2DP_CODEC_CHANNEL_MODE_NONE or BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO "
+              , __func__);
+    goto fail;
+  }
+
+  /*******************************************
+   * Update maxTargetBitrate
+   *
+   *******************************************/
+  result_config_cie.maxTargetBitrate = sink_info_cie.maxTargetBitrate;
+
+  LOG_DEBUG(LOG_TAG, "%s: Config Max bitrate result(0x%02x)", __func__, result_config_cie.maxTargetBitrate);
+
+  /*******************************************
+   * Update channelSplitMode
+   *
+   *******************************************/
+  result_config_cie.channelSplitMode = sink_info_cie.channelSplitMode;
+  LOG_DEBUG(LOG_TAG,"%s: channelSplitMode = %d", __func__, result_config_cie.channelSplitMode);
+
+
+  /*******************************************
+   * quality mode: magic num check and reconfigure
+   * to specific 1
+   *******************************************/
+  if ((codec_user_config_.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) != A2DP_LHDC_QUALITY_MAGIC_NUM) {
+      codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_ABR;
+      LOG_DEBUG(LOG_TAG,"%s: use default quality_mode:ABR", __func__);
+  }
+  quality_mode = codec_user_config_.codec_specific_1 & 0xff;
+
+  // filter non-supported quality modes(those supported in LHDCV5 or higher version) for internal use
+  if (quality_mode == A2DP_LHDC_QUALITY_HIGH1) {
+    codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_HIGH;
+    quality_mode = A2DP_LHDC_QUALITY_HIGH;
+    LOG_DEBUG(LOG_TAG,"%s: reset non-supported quality_mode to %s", __func__,
+        lhdcV3_QualityModeBitRate_toString(quality_mode).c_str());
+  }
+
+  /*******************************************
+   * LHDC features: safety tag check
+   * to specific 3
+   *******************************************/
+  if ((codec_user_config_.codec_specific_3 & A2DP_LHDC_VENDOR_FEATURE_MASK) != A2DP_LHDC_FEATURE_MAGIC_NUM)
+  {
+      LOG_DEBUG(LOG_TAG, "%s: LHDC feature tag not matched! use old feature settings", __func__);
+
+      /* *
+       * Magic num does not match:
+       * 1. add tag
+       * 2. Re-adjust previous feature(which refers to codec_user_config)'s state(in codec_config_) to codec_user_config_:
+       * 	AR(has UI), Meta(no UI yet), LARC(no UI yet)
+       * */
+      // clean entire specific and set safety tag
+      codec_user_config_.codec_specific_3 = A2DP_LHDC_FEATURE_MAGIC_NUM;
+
+      // Feature: AR
+      if( A2DP_IsFeatureInCodecConfigLhdcV3(&allCfgPack, LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE) )
+      {
+    	    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+    	        &allCfgPack,
+				LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE,
+    	        A2DP_LHDC_TO_A2DP_CODEC_USER_,
+    	        true);
+    	    LOG_DEBUG(LOG_TAG, "%s: restore user_cfg to previous AR status => ON", __func__);
+      }
+      else
+      {
+			A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+				&allCfgPack,
+				LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE,
+				A2DP_LHDC_TO_A2DP_CODEC_USER_,
+				false);
+			LOG_DEBUG(LOG_TAG, "%s: restore user_cfg to previous AR status => OFF", __func__);
+      }
+      // Feature: META
+      if( A2DP_IsFeatureInCodecConfigLhdcV3(&allCfgPack, LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE) )
+      {
+    	    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+    	        &allCfgPack,
+				LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE,
+    	        A2DP_LHDC_TO_A2DP_CODEC_USER_,
+    	        true);
+    	    LOG_DEBUG(LOG_TAG, "%s: restore user_cfg to previous META status => ON", __func__);
+      }
+      else
+      {
+			A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+				&allCfgPack,
+				LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE,
+				A2DP_LHDC_TO_A2DP_CODEC_USER_,
+				false);
+			LOG_DEBUG(LOG_TAG, "%s: restore user_cfg to previous META status => OFF", __func__);
+      }
+      // Feature: LARC
+      if( A2DP_IsFeatureInCodecConfigLhdcV3(&allCfgPack, LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE) )
+      {
+    	    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+    	        &allCfgPack,
+				LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE,
+    	        A2DP_LHDC_TO_A2DP_CODEC_USER_,
+    	        true);
+    	    LOG_DEBUG(LOG_TAG, "%s: restore user_cfg to previous LARC status => ON", __func__);
+      }
+      else
+      {
+			A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+				&allCfgPack,
+				LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE,
+				A2DP_LHDC_TO_A2DP_CODEC_USER_,
+				false);
+			LOG_DEBUG(LOG_TAG, "%s: restore user_cfg to previous LARC status => OFF", __func__);
+      }
+  }
+  else
+  {
+	  LOG_DEBUG(LOG_TAG, "%s: LHDC feature tag matched!", __func__);
+  }
+
+
+  /**
+  *LHDC V4 modify
+  */
+
+  /*******************************************
+   * Update Feature/Capabilities: LLAC
+   * to A2DP specifics
+   *******************************************/
+  //result_config_cie.hasFeatureLLAC = sink_info_cie.hasFeatureLLAC;
+  hasFeature = (a2dp_lhdc_source_caps.hasFeatureLLAC & sink_info_cie.hasFeatureLLAC);
+  result_config_cie.hasFeatureLLAC = false;
+
+  /* *
+   * reset bit in A2DP configs
+   *     codec_config_.codec_specific_3 &= ~A2DP_LHDC_LLAC_ENABLED;
+   *     codec_selectable_capability_.codec_specific_3 &= ~A2DP_LHDC_LLAC_ENABLED;
+   *     codec_capability_.codec_specific_3 &= ~ A2DP_LHDC_LLAC_ENABLED;
+   * */
+  A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+      &allCfgPack,
+      LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE,
+      (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_|A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_|A2DP_LHDC_TO_A2DP_CODEC_CAP_),
+      false);
+
+  if (hasFeature /*&& 
+      (
+       (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_48000 && (quality_mode <= A2DP_LHDC_QUALITY_LOW || quality_mode == A2DP_LHDC_QUALITY_ABR)) ||
+       (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_44100 && (quality_mode <= A2DP_LHDC_QUALITY_LOW || quality_mode == A2DP_LHDC_QUALITY_ABR))
+      )*/
+     ) {
+    result_config_cie.hasFeatureLLAC = true;
+    //codec_config_.codec_specific_3 |= A2DP_LHDC_LLAC_ENABLED;
+    //codec_user_config_.codec_specific_3 |= A2DP_LHDC_LLAC_ENABLED;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_| A2DP_LHDC_TO_A2DP_CODEC_USER_),
+        true);
+  }
+
+  if(hasFeature)
+  {
+    //codec_selectable_capability_.codec_specific_3 |= A2DP_LHDC_LLAC_ENABLED;
+    //codec_capability_.codec_specific_3 |= A2DP_LHDC_LLAC_ENABLED;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE,
+        (A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
+        true);
+  }
+
+  LOG_DEBUG(LOG_TAG, "%s: Has LLAC feature?(0x%02x) Src(0x%02x) Sink(0x%02x) result(0x%02x)", __func__,
+                                hasFeature,
+                                a2dp_lhdc_source_caps.hasFeatureLLAC,
+                                sink_info_cie.hasFeatureLLAC,
+                                result_config_cie.hasFeatureLLAC);
+  LOG_DEBUG(LOG_TAG, "%s: LLAC update:[config:(0x%016llX) cap:(0x%016llX) selcap:(0x%016llX) user:(0x%016llX)] ", __func__,
+                                (codec_config_.codec_specific_3 & A2DP_LHDC_LLAC_ENABLED),
+                                (codec_capability_.codec_specific_3 & A2DP_LHDC_LLAC_ENABLED),
+                                (codec_selectable_capability_.codec_specific_3 & A2DP_LHDC_LLAC_ENABLED),
+                                (codec_user_config_.codec_specific_3 & A2DP_LHDC_LLAC_ENABLED));
+
+  /*******************************************
+   * Update Feature/Capabilities: LHDCV4
+   * to A2DP specifics
+   *******************************************/
+  //result_config_cie.hasFeatureLHDCV4 = sink_info_cie.hasFeatureLHDCV4;
+  hasFeature = (a2dp_lhdc_source_caps.hasFeatureLHDCV4 & sink_info_cie.hasFeatureLHDCV4);
+  result_config_cie.hasFeatureLHDCV4 = false;
+
+  /* *
+   * reset bit in A2DP configs
+   *     codec_config_.codec_specific_3 &= ~A2DP_LHDC_V4_ENABLED;
+   *     codec_selectable_capability_.codec_specific_3 &= ~A2DP_LHDC_V4_ENABLED;
+   *     codec_capability_.codec_specific_3 &= ~ A2DP_LHDC_V4_ENABLED;
+   * */
+  A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+      &allCfgPack,
+      LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE,
+      (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_|A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_|A2DP_LHDC_TO_A2DP_CODEC_CAP_),
+      false);
+
+  if (hasFeature /*&& 
+      (
+       (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) ||
+       (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_48000 && (quality_mode > A2DP_LHDC_QUALITY_LOW && quality_mode != A2DP_LHDC_QUALITY_ABR)) ||
+       (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_44100 && (quality_mode > A2DP_LHDC_QUALITY_LOW && quality_mode != A2DP_LHDC_QUALITY_ABR))
+      )*/
+     ) {
+    result_config_cie.hasFeatureLHDCV4 = true;
+    //codec_config_.codec_specific_3 |= A2DP_LHDC_V4_ENABLED;
+    //codec_user_config_.codec_specific_3 |= A2DP_LHDC_V4_ENABLED;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_| A2DP_LHDC_TO_A2DP_CODEC_USER_),
+        true);
+  }
+  if (hasFeature) {
+    //codec_selectable_capability_.codec_specific_3 |= A2DP_LHDC_V4_ENABLED;
+    //codec_capability_.codec_specific_3 |= A2DP_LHDC_V4_ENABLED;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE,
+        (A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
+        true);
+  }
+
+  LOG_DEBUG(LOG_TAG, "%s: Has V4 feature?(0x%02x) Src(0x%02x) Sink(0x%02x) result(0x%02x)", __func__,
+                                hasFeature,
+                                a2dp_lhdc_source_caps.hasFeatureLHDCV4,
+                                sink_info_cie.hasFeatureLHDCV4,
+                                result_config_cie.hasFeatureLHDCV4);
+  LOG_DEBUG(LOG_TAG, "%s: V4 update:[config:(0x%016llX) cap:(0x%016llX) selcap:(0x%016llX) user:(0x%016llX)] ", __func__,
+                                (codec_config_.codec_specific_3 & A2DP_LHDC_V4_ENABLED),
+                                (codec_capability_.codec_specific_3 & A2DP_LHDC_V4_ENABLED),
+                                (codec_selectable_capability_.codec_specific_3 & A2DP_LHDC_V4_ENABLED),
+                                (codec_user_config_.codec_specific_3 & A2DP_LHDC_V4_ENABLED));
+
+  /*******************************************
+   * Update Feature/Capabilities: JAS
+   * to A2DP specifics
+   *******************************************/
+  {
+    //result_config_cie.hasFeatureJAS = sink_info_cie.hasFeatureJAS;
+    hasFeature = (a2dp_lhdc_source_caps.hasFeatureJAS & sink_info_cie.hasFeatureJAS);
+    result_config_cie.hasFeatureJAS = false;
+
+    /* *
+     * reset bit in A2DP configs
+     *     codec_config_.codec_specific_3 &= ~A2DP_LHDC_JAS_ENABLED;
+     *     codec_selectable_capability_.codec_specific_3 &= ~A2DP_LHDC_JAS_ENABLED;
+     *     codec_capability_.codec_specific_3 &= ~ A2DP_LHDC_JAS_ENABLED;
+     * */
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_|A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_|A2DP_LHDC_TO_A2DP_CODEC_CAP_),
+        false);
+
+    //if ((codec_user_config_.codec_specific_3 & A2DP_LHDC_JAS_ENABLED) && hasFeature) {
+    /*  06/02/2021: enable JAS without UI control */
+    //if( hasFeature && A2DP_IsFeatureInUserConfigLhdcV3(&allCfgPack, LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE) )
+    if( hasFeature )
+    {
+      result_config_cie.hasFeatureJAS = true;
+      //codec_config_.codec_specific_3 |= A2DP_LHDC_JAS_ENABLED;
+      A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+          &allCfgPack,
+          LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE,
+          A2DP_LHDC_TO_A2DP_CODEC_CONFIG_,
+          true);
+    }
+
+    if(hasFeature)
+    {
+      //codec_selectable_capability_.codec_specific_3 |= A2DP_LHDC_JAS_ENABLED;
+      //codec_capability_.codec_specific_3 |= A2DP_LHDC_JAS_ENABLED;
+      A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+          &allCfgPack,
+          LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
+          true);
+    }
+    LOG_DEBUG(LOG_TAG, "%s: Has JAS feature?(0x%02x) Src(0x%02x) Sink(0x%02x) result(0x%02x)", __func__,
+                                  hasFeature,
+                                  a2dp_lhdc_source_caps.hasFeatureJAS,
+                                  sink_info_cie.hasFeatureJAS,
+                                  result_config_cie.hasFeatureJAS);
+    LOG_DEBUG(LOG_TAG, "%s: JAS update:[config:(0x%016llX) cap:(0x%016llX) selcap:(0x%016llX) user:(0x%016llX)] ", __func__,
+                                  (codec_config_.codec_specific_3 & A2DP_LHDC_JAS_ENABLED),
+                                  (codec_capability_.codec_specific_3 & A2DP_LHDC_JAS_ENABLED),
+                                  (codec_selectable_capability_.codec_specific_3 & A2DP_LHDC_JAS_ENABLED),
+                                  (codec_user_config_.codec_specific_3 & A2DP_LHDC_JAS_ENABLED));
+  }
+
+  /*******************************************
+   * Update Feature/Capabilities: AR
+   * to A2DP specifics
+   *******************************************/
+  //result_config_cie.hasFeatureAR = sink_info_cie.hasFeatureAR;
+  hasFeature = (a2dp_lhdc_source_caps.hasFeatureAR & sink_info_cie.hasFeatureAR);
+  result_config_cie.hasFeatureAR = false;
+
+  /* *
+   * reset bit in A2DP configs
+   *     codec_config_.codec_specific_3 &= ~A2DP_LHDC_AR_ENABLED;
+   *     codec_selectable_capability_.codec_specific_3 &= ~A2DP_LHDC_AR_ENABLED;
+   *     codec_capability_.codec_specific_3 &= ~ A2DP_LHDC_AR_ENABLED;
+   * */
+  A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+      &allCfgPack,
+      LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE,
+      (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_|A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_|A2DP_LHDC_TO_A2DP_CODEC_CAP_),
+      false);
+
+  //if ((codec_user_config_.codec_specific_3 & A2DP_LHDC_AR_ENABLED) && hasFeature) {
+  if( hasFeature && A2DP_IsFeatureInUserConfigLhdcV3(&allCfgPack, LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE) ){
+    result_config_cie.hasFeatureAR = true;
+    //codec_config_.codec_specific_3 |= A2DP_LHDC_AR_ENABLED;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE,
+        A2DP_LHDC_TO_A2DP_CODEC_CONFIG_,
+        true);
+    /* 06/02/2021: When AR function is turned ON, downgrade the sample rate to 48KHz if needed.
+     * 	Reason: prevent high CPU loading of AR engine running on higher sample rate(ex:96KHz)
+     */
+    if(codec_user_config_.sample_rate > BTAV_A2DP_CODEC_SAMPLE_RATE_48000)
+    {
+    	LOG_DEBUG(LOG_TAG, "%s: Limit current sample rate(0x%02X) to 48Khz when AR feature turnned on", __func__,
+    			codec_user_config_.sample_rate);
+		codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+		codec_user_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+		result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+    }
+  }
+
+  if (hasFeature) {
+    //codec_selectable_capability_.codec_specific_3 |= A2DP_LHDC_AR_ENABLED;
+    //codec_capability_.codec_specific_3 |= A2DP_LHDC_AR_ENABLED;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE,
+        (A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
+        true);
+  }
+
+  LOG_DEBUG(LOG_TAG, "%s: Has AR feature?(0x%02x) Src(0x%02x) Sink(0x%02x) result(0x%02x)", __func__,
+                                hasFeature,
+                                a2dp_lhdc_source_caps.hasFeatureAR,
+                                sink_info_cie.hasFeatureAR,
+                                result_config_cie.hasFeatureAR);
+  LOG_DEBUG(LOG_TAG, "%s: AR update:[config:(0x%016llX) cap:(0x%016llX) selcap:(0x%016llX) user:(0x%016llX)] ", __func__,
+                                (codec_config_.codec_specific_3 & A2DP_LHDC_AR_ENABLED),
+                                (codec_capability_.codec_specific_3 & A2DP_LHDC_AR_ENABLED),
+                                (codec_selectable_capability_.codec_specific_3 & A2DP_LHDC_AR_ENABLED),
+                                (codec_user_config_.codec_specific_3 & A2DP_LHDC_AR_ENABLED));
+
+  /*******************************************
+   * Update Feature/Capabilities: META
+   * to A2DP specifics
+   *******************************************/
+  //result_config_cie.hasFeatureMETA = sink_info_cie.hasFeatureMETA;
+  hasFeature = (a2dp_lhdc_source_caps.hasFeatureMETA & sink_info_cie.hasFeatureMETA);
+  result_config_cie.hasFeatureMETA = false;
+
+  /* *
+   * reset bit in A2DP configs
+   *     codec_config_.codec_specific_3 &= ~A2DP_LHDC_META_ENABLED;
+   *     codec_selectable_capability_.codec_specific_3 &= ~A2DP_LHDC_META_ENABLED;
+   *     codec_capability_.codec_specific_3 &= ~ A2DP_LHDC_META_ENABLED;
+   * */
+  A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+      &allCfgPack,
+      LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE,
+      (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_|A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_|A2DP_LHDC_TO_A2DP_CODEC_CAP_),
+      false);
+
+  //if ((codec_user_config_.codec_specific_3 & A2DP_LHDC_META_ENABLED) && hasFeature) {
+  if( hasFeature && A2DP_IsFeatureInUserConfigLhdcV3(&allCfgPack, LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE) ){
+    result_config_cie.hasFeatureMETA = true;
+    //codec_config_.codec_specific_3 |= A2DP_LHDC_META_ENABLED;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE,
+        A2DP_LHDC_TO_A2DP_CODEC_CONFIG_,
+        true);
+  }
+
+  if (hasFeature) {
+    //codec_selectable_capability_.codec_specific_3 |= A2DP_LHDC_META_ENABLED;
+    //codec_capability_.codec_specific_3 |= A2DP_LHDC_META_ENABLED;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE,
+        (A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
+        true);
+  }
+
+  LOG_DEBUG(LOG_TAG, "%s: Has META feature?(0x%02x) Src(0x%02x) Sink(0x%02x) result(0x%02x)", __func__,
+                                hasFeature,
+                                a2dp_lhdc_source_caps.hasFeatureMETA,
+                                sink_info_cie.hasFeatureMETA,
+                                result_config_cie.hasFeatureMETA);
+  LOG_DEBUG(LOG_TAG, "%s: META update:[config:(0x%016llX) cap:(0x%016llX) selcap:(0x%016llX) user:(0x%016llX)] ", __func__,
+                                (codec_config_.codec_specific_3 & A2DP_LHDC_META_ENABLED),
+                                (codec_capability_.codec_specific_3 & A2DP_LHDC_META_ENABLED),
+                                (codec_selectable_capability_.codec_specific_3 & A2DP_LHDC_META_ENABLED),
+                                (codec_user_config_.codec_specific_3 & A2DP_LHDC_META_ENABLED));
+
+  /*******************************************
+   * Update Feature/Capabilities: MBR
+   * to A2DP specifics
+   *******************************************/
+  //result_config_cie.hasFeatureMinBitrate = sink_info_cie.hasFeatureMinBitrate;
+  hasFeature = (a2dp_lhdc_source_caps.hasFeatureMinBitrate & sink_info_cie.hasFeatureMinBitrate);
+  result_config_cie.hasFeatureMinBitrate = false;
+
+  /* *
+   * reset bit in A2DP configs
+   *     codec_config_.codec_specific_3 &= ~A2DP_LHDC_MBR_ENABLED;
+   *     codec_selectable_capability_.codec_specific_3 &= ~A2DP_LHDC_MBR_ENABLED;
+   *     codec_capability_.codec_specific_3 &= ~ A2DP_LHDC_MBR_ENABLED;
+   * */
+  A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+      &allCfgPack,
+      LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE,
+      (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_|A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_|A2DP_LHDC_TO_A2DP_CODEC_CAP_),
+      false);
+
+  if (hasFeature) {
+    result_config_cie.hasFeatureMinBitrate = true;
+    //codec_config_.codec_specific_3 |= A2DP_LHDC_MBR_ENABLED;
+    //codec_selectable_capability_.codec_specific_3 |= A2DP_LHDC_MBR_ENABLED;
+    //codec_capability_.codec_specific_3 |= A2DP_LHDC_MBR_ENABLED;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ | A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
+        true);
+  }
+
+  LOG_DEBUG(LOG_TAG, "%s: Has MBR feature?(0x%02x) Src(0x%02x) Sink(0x%02x) result(0x%02x)", __func__,
+                                hasFeature,
+                                a2dp_lhdc_source_caps.hasFeatureMinBitrate,
+                                sink_info_cie.hasFeatureMinBitrate,
+                                result_config_cie.hasFeatureMinBitrate);
+  LOG_DEBUG(LOG_TAG, "%s: MBR update:[config:(0x%016llX) cap:(0x%016llX) selcap:(0x%016llX) user:(0x%016llX)] ", __func__,
+                                (codec_config_.codec_specific_3 & A2DP_LHDC_MBR_ENABLED),
+                                (codec_capability_.codec_specific_3 & A2DP_LHDC_MBR_ENABLED),
+                                (codec_selectable_capability_.codec_specific_3 & A2DP_LHDC_MBR_ENABLED),
+                                (codec_user_config_.codec_specific_3 & A2DP_LHDC_MBR_ENABLED));
+
+
+  /*******************************************
+   * Update Feature/Capabilities: LARC
+   * to A2DP specifics
+   *******************************************/
+  //result_config_cie.hasFeatureLARC = sink_info_cie.hasFeatureLARC;
+  hasFeature = (a2dp_lhdc_source_caps.hasFeatureLARC & sink_info_cie.hasFeatureLARC);
+  result_config_cie.hasFeatureLARC = false;
+
+  /* *
+   * reset bit in A2DP configs
+   *     codec_config_.codec_specific_3 &= ~A2DP_LHDC_LARC_ENABLED;
+   *     codec_selectable_capability_.codec_specific_3 &= ~A2DP_LHDC_LARC_ENABLED;
+   *     codec_capability_.codec_specific_3 &= ~ A2DP_LHDC_LARC_ENABLED;
+   * */
+  A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+      &allCfgPack,
+      LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE,
+      (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_|A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_|A2DP_LHDC_TO_A2DP_CODEC_CAP_),
+      false);
+
+  //if ((codec_user_config_.codec_specific_3 & A2DP_LHDC_LARC_ENABLED) && hasFeature) {
+  //if( hasFeature && A2DP_IsFeatureInUserConfigLhdcV3(&allCfgPack, LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE) ){
+  if( hasFeature ){
+    result_config_cie.hasFeatureLARC = true;
+    //codec_config_.codec_specific_3 |= A2DP_LHDC_LARC_ENABLED;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE,
+        A2DP_LHDC_TO_A2DP_CODEC_CONFIG_,
+        true);
+  }
+
+  if (hasFeature) {
+    //codec_selectable_capability_.codec_specific_3 |= A2DP_LHDC_LARC_ENABLED;
+    //codec_capability_.codec_specific_3 |= A2DP_LHDC_LARC_ENABLED;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE,
+        (A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
+        true);
+  }
+
+  LOG_DEBUG(LOG_TAG, "%s: Has LARC feature?(0x%02x) Src(0x%02x) Sink(0x%02x) result(0x%02x)", __func__,
+                                hasFeature,
+                                a2dp_lhdc_source_caps.hasFeatureLARC,
+                                sink_info_cie.hasFeatureLARC,
+                                result_config_cie.hasFeatureLARC);
+  LOG_DEBUG(LOG_TAG, "%s: LARC update:[config:(0x%016llX) cap:(0x%016llX) selcap:(0x%016llX) user:(0x%016llX)] ", __func__,
+                                (codec_config_.codec_specific_3 & A2DP_LHDC_LARC_ENABLED),
+                                (codec_capability_.codec_specific_3 & A2DP_LHDC_LARC_ENABLED),
+                                (codec_selectable_capability_.codec_specific_3 & A2DP_LHDC_LARC_ENABLED),
+                                (codec_user_config_.codec_specific_3 & A2DP_LHDC_LARC_ENABLED));
+
+
+  /*******************************************
+   * quality mode: re-adjust according to maxTargetBitrate(smaller one adopted)
+   *******************************************/
+  if ( (result_config_cie.hasFeatureLLAC && result_config_cie.hasFeatureLHDCV4) &&
+	   (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) &&
+	   (quality_mode != A2DP_LHDC_QUALITY_ABR))
+  {
+	  //In this case, max bit rate mechanism is disabled(set to 900k)
+	  result_config_cie.maxTargetBitrate = A2DP_LHDC_MAX_BIT_RATE_900K;
+	  LOG_DEBUG(LOG_TAG,"%s: [LLAC + LHDC V4]: set MBR (0x%x)", __func__, result_config_cie.maxTargetBitrate);
+
+	  //dont re-adjust quality mode in this case
+	  LOG_DEBUG(LOG_TAG,"%s: do not adjust quality_mode in this case", __func__);
+  }
+  else
+  {
+	  maxBitRate_Qmode = A2DP_MaxBitRatetoQualityLevelLhdcV3(result_config_cie.maxTargetBitrate);
+	  if(maxBitRate_Qmode < 0xFF) {
+		  if(quality_mode != A2DP_LHDC_QUALITY_ABR && quality_mode > maxBitRate_Qmode){
+			  LOG_DEBUG(LOG_TAG,"%s: adjust quality_mode:0x%x to 0x%x by maxTargetBitrate:0x%x", __func__,
+					  quality_mode, maxBitRate_Qmode, result_config_cie.maxTargetBitrate);
+			  quality_mode = maxBitRate_Qmode;
+			  codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | quality_mode;
+		  }
+	  }
+  }
+
+  /*
+   * Final Custom Rules of resolving conflict between capabilities and version
+   */
+  if (result_config_cie.hasFeatureLLAC && result_config_cie.hasFeatureLHDCV4) {
+    //LHDCV4 + LLAC
+    if (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) {
+
+      if (quality_mode == A2DP_LHDC_QUALITY_ABR) {
+		result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+		codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+		codec_user_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;	//also set UI settings
+		result_config_cie.hasFeatureLHDCV4 = false;
+		codec_config_.codec_specific_3 &= ~A2DP_LHDC_V4_ENABLED;
+		LOG_DEBUG(LOG_TAG,"%s: [LLAC + LHDC V4]: LLAC, reset sampleRate (0x%x)", __func__, result_config_cie.sampleRate);
+      } else {
+        result_config_cie.hasFeatureLLAC = false;
+        codec_config_.codec_specific_3 &= ~A2DP_LHDC_LLAC_ENABLED;
+        LOG_DEBUG(LOG_TAG,"%s: [LLAC + LHDC V4]: LHDC", __func__);
+
+  	    //result_config_cie.maxTargetBitrate = A2DP_LHDC_MAX_BIT_RATE_900K;
+  	    //LOG_DEBUG(LOG_TAG,"%s: [LLAC + LHDC V4]: set MBR (0x%x)", __func__, result_config_cie.maxTargetBitrate);
+
+      	if (result_config_cie.hasFeatureMinBitrate) {
+          if (quality_mode < A2DP_LHDC_QUALITY_MID) {
+            codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_MID;
+            quality_mode = A2DP_LHDC_QUALITY_MID;
+            LOG_DEBUG(LOG_TAG,"%s: [LLAC + LHDC V4]: LHDC 96KSR, reset Qmode (0x%x)", __func__, quality_mode);
+          }
+      	} else {
+    	  if (quality_mode < A2DP_LHDC_QUALITY_LOW) {
+		    codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
+		    quality_mode = A2DP_LHDC_QUALITY_LOW;
+		    LOG_DEBUG(LOG_TAG,"%s: [LLAC + LHDC V4]: LHDC 96KSR, reset Qmode (0x%x)", __func__, quality_mode);
+		  }
+      	}
+      }
+    } else if (
+        (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_48000 && (quality_mode > A2DP_LHDC_QUALITY_LOW && quality_mode != A2DP_LHDC_QUALITY_ABR)) ||
+        (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_44100 && (quality_mode > A2DP_LHDC_QUALITY_LOW && quality_mode != A2DP_LHDC_QUALITY_ABR))
+       ) {
+      result_config_cie.hasFeatureLLAC = false;
+      codec_config_.codec_specific_3 &= ~A2DP_LHDC_LLAC_ENABLED;
+      LOG_DEBUG(LOG_TAG,"%s: [LLAC + LHDC V4]: LHDC", __func__);
+    } else if (
+       (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_48000 && (quality_mode <= A2DP_LHDC_QUALITY_LOW || quality_mode == A2DP_LHDC_QUALITY_ABR)) ||
+       (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_44100 && (quality_mode <= A2DP_LHDC_QUALITY_LOW || quality_mode == A2DP_LHDC_QUALITY_ABR))
+      ) {
+      result_config_cie.hasFeatureLHDCV4 = false;
+      codec_config_.codec_specific_3 &= ~A2DP_LHDC_V4_ENABLED;
+      LOG_DEBUG(LOG_TAG,"%s: [LLAC + LHDC V4]: LLAC", __func__);
+
+      /* LLAC: prevent quality mode using 64kbps */
+      if (result_config_cie.hasFeatureMinBitrate) {
+    	if (quality_mode < A2DP_LHDC_QUALITY_LOW1) {
+    	  codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW1;
+    	  quality_mode = A2DP_LHDC_QUALITY_LOW1;
+    	  LOG_DEBUG(LOG_TAG,"%s: [LLAC + LHDC V4]: LLAC, reset Qmode (0x%x)", __func__, quality_mode);
+    	}
+      }
+    } else {
+      LOG_ERROR(LOG_TAG,"%s: [LLAC + LHDC V4]: format incorrect.", __func__);
+      goto fail;
+    }
+
+  } else if (!result_config_cie.hasFeatureLLAC && result_config_cie.hasFeatureLHDCV4) {
+    //LHDC V4 only
+    LOG_DEBUG(LOG_TAG, "%s: [LHDCV4 only]", __func__);
+	if (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) {
+		if (result_config_cie.hasFeatureMinBitrate) {
+			if (quality_mode < A2DP_LHDC_QUALITY_LOW) {
+				codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
+				quality_mode = A2DP_LHDC_QUALITY_LOW;
+				LOG_DEBUG(LOG_TAG,"%s: [LHDC only]: reset Qmode (0x%x)", __func__, quality_mode);
+			}
+		}
+	} else {
+		if (result_config_cie.hasFeatureMinBitrate) {
+			if (quality_mode < A2DP_LHDC_QUALITY_LOW4) {
+				codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW4;
+				quality_mode = A2DP_LHDC_QUALITY_LOW4;
+				LOG_DEBUG(LOG_TAG,"%s: [LHDC only]: reset Qmode (0x%x), ", __func__, quality_mode);
+			}
+		}
+	}
+
+  } else if (result_config_cie.hasFeatureLLAC && !result_config_cie.hasFeatureLHDCV4) {
+    //LLAC only
+    LOG_DEBUG(LOG_TAG, "%s: [LLAC only]", __func__);
+    if (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) {
+      result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+      codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+      codec_user_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;	//also set UI settings
+      LOG_DEBUG(LOG_TAG,"%s: [LLAC only]: reset SampleRate (0x%x)", __func__, result_config_cie.sampleRate);
+    }
+
+    if (quality_mode > A2DP_LHDC_QUALITY_LOW && quality_mode != A2DP_LHDC_QUALITY_ABR) {
+      codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
+      quality_mode = A2DP_LHDC_QUALITY_LOW;
+      LOG_DEBUG(LOG_TAG,"%s: [LLAC only]: reset Qmode (0x%x)", __func__, quality_mode);
+    }
+    
+    /* LLAC: prevent quality mode using 64kbps */
+    if (result_config_cie.hasFeatureMinBitrate) {
+		if (quality_mode < A2DP_LHDC_QUALITY_LOW1) {
+		  codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW1;
+		  quality_mode = A2DP_LHDC_QUALITY_LOW1;
+		  LOG_DEBUG(LOG_TAG,"%s: [LLAC only]: reset Qmode (0x%x)", __func__, quality_mode);
+		}
+    }
+
+  } else if (!result_config_cie.hasFeatureLLAC && !result_config_cie.hasFeatureLHDCV4) {
+    //LHDC V3 only
+    LOG_DEBUG(LOG_TAG, "%s: [LHDCV3 only]", __func__);
+	if (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) {
+		if (result_config_cie.hasFeatureMinBitrate) {
+			if (quality_mode < A2DP_LHDC_QUALITY_LOW) {
+				codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
+				quality_mode = A2DP_LHDC_QUALITY_LOW;
+				LOG_DEBUG(LOG_TAG,"%s: [LHDCV3 only]: reset Qmode (0x%x)", __func__, quality_mode);
+			}
+		}
+	} else {
+		if (result_config_cie.hasFeatureMinBitrate) {
+			if (quality_mode < A2DP_LHDC_QUALITY_LOW4) {
+				codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW4;
+				quality_mode = A2DP_LHDC_QUALITY_LOW4;
+				LOG_DEBUG(LOG_TAG,"%s: [LHDCV3 only]: reset Qmode (0x%x), ", __func__, quality_mode);
+			}
+		}
+	}
+  }
+
+  LOG_DEBUG(LOG_TAG,"%s: Final quality_mode = (%d) %s", __func__,
+      quality_mode,
+      lhdcV3_QualityModeBitRate_toString(quality_mode).c_str());
+
+  //
+  // Copy the codec-specific fields if they are not zero
+  //
+  if (codec_user_config_.codec_specific_1 != 0)
+    codec_config_.codec_specific_1 = codec_user_config_.codec_specific_1;
+  if (codec_user_config_.codec_specific_2 != 0)
+    codec_config_.codec_specific_2 = codec_user_config_.codec_specific_2;
+  if (codec_user_config_.codec_specific_3 != 0)
+    codec_config_.codec_specific_3 = codec_user_config_.codec_specific_3;
+  if (codec_user_config_.codec_specific_4 != 0)
+    codec_config_.codec_specific_4 = codec_user_config_.codec_specific_4;
+  
+  /* Setup final nego result codec config to peer */
+  if (int ret = A2DP_BuildInfoLhdcV3(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
+                         p_result_codec_config) != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG,"%s: A2DP_BuildInfoLhdcV3 fail(0x%x)", __func__, ret);
+    goto fail;
+  }
+
+
+  // Create a local copy of the peer codec capability, and the
+  // result codec config.
+    LOG_ERROR(LOG_TAG,"%s: is_capability = %d", __func__, is_capability);
+  if (is_capability) {
+    status = A2DP_BuildInfoLhdcV3(AVDT_MEDIA_TYPE_AUDIO, &sink_info_cie,
+                                ota_codec_peer_capability_);
+  } else {
+    status = A2DP_BuildInfoLhdcV3(AVDT_MEDIA_TYPE_AUDIO, &sink_info_cie,
+                                ota_codec_peer_config_);
+  }
+  CHECK(status == A2DP_SUCCESS);
+
+  status = A2DP_BuildInfoLhdcV3(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
+                              ota_codec_config_);
+  CHECK(status == A2DP_SUCCESS);
+
+  LOG_DEBUG(LOG_TAG, "%s: Final User_SP1=(0x%016llX); SP2=(0x%016llX); SP3=(0x%016llX); SP4=(0x%016llX)", __func__,
+		  (unsigned long long)codec_user_config_.codec_specific_1,
+		  (unsigned long long)codec_user_config_.codec_specific_2,
+		  (unsigned long long)codec_user_config_.codec_specific_3,
+		  (unsigned long long)codec_user_config_.codec_specific_4);
+  LOG_DEBUG(LOG_TAG, "%s: Final Codec_SP1=(0x%016llX); SP2=(0x%016llX); SP3=(0x%016llX); SP4=(0x%016llX)", __func__,
+		  (unsigned long long)(codec_config_.codec_specific_1),
+		  (unsigned long long)(codec_config_.codec_specific_2),
+		  (unsigned long long)(codec_config_.codec_specific_3),
+		  (unsigned long long)(codec_config_.codec_specific_4));
+
+  return true;
+
+fail:
+  // Restore the internal state
+  codec_config_ = saved_codec_config;
+  codec_capability_ = saved_codec_capability;
+  codec_selectable_capability_ = saved_codec_selectable_capability;
+  codec_user_config_ = saved_codec_user_config;
+  codec_audio_config_ = saved_codec_audio_config;
+  memcpy(ota_codec_config_, saved_ota_codec_config, sizeof(ota_codec_config_));
+  memcpy(ota_codec_peer_capability_, saved_ota_codec_peer_capability,
+         sizeof(ota_codec_peer_capability_));
+  memcpy(ota_codec_peer_config_, saved_ota_codec_peer_config,
+         sizeof(ota_codec_peer_config_));
+  return false;
+}
+
+
+
+bool A2dpCodecConfigLhdcV3::setPeerCodecCapabilities(
+                                                   const uint8_t* p_peer_codec_capabilities) {
+    std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
+    tA2DP_LHDC_CIE peer_info_cie;
+    uint8_t sampleRate;
+    uint8_t bits_per_sample;
+
+    // Save the internal state
+    btav_a2dp_codec_config_t saved_codec_selectable_capability =
+    codec_selectable_capability_;
+    uint8_t saved_ota_codec_peer_capability[AVDT_CODEC_SIZE];
+    memcpy(saved_ota_codec_peer_capability, ota_codec_peer_capability_,
+           sizeof(ota_codec_peer_capability_));
+
+    tA2DP_STATUS status =
+    A2DP_ParseInfoLhdcV3(&peer_info_cie, p_peer_codec_capabilities, true);
+    if (status != A2DP_SUCCESS) {
+        LOG_ERROR(LOG_TAG, "%s: can't parse peer's capabilities: error = %d",
+                  __func__, status);
+        goto fail;
+    }
+/*
+    if (peer_info_cie.version > a2dp_lhdc_source_caps.version) {
+        LOG_ERROR(LOG_TAG, "%s: can't parse peer's capabilities: Missmatch version(%u:%u)",
+                  __func__, a2dp_lhdc_source_caps.version, peer_info_cie.version);
+        goto fail;
+    }
+*/
+
+    // Compute the selectable capability - bits per sample
+    //codec_selectable_capability_.bits_per_sample =
+    //a2dp_lhdc_source_caps.bits_per_sample;
+    bits_per_sample = a2dp_lhdc_source_caps.bits_per_sample & peer_info_cie.bits_per_sample;
+    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    }
+    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+    }
+
+
+    // Compute the selectable capability - sample rate
+    sampleRate = a2dp_lhdc_source_caps.sampleRate & peer_info_cie.sampleRate;
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+        codec_selectable_capability_.sample_rate |=
+        BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    }
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+        codec_selectable_capability_.sample_rate |=
+        BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    }
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+        codec_selectable_capability_.sample_rate |=
+        BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+    }
+
+
+    // Compute the selectable capability - channel mode
+    codec_selectable_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+
+    status = A2DP_BuildInfoLhdcV3(AVDT_MEDIA_TYPE_AUDIO, &peer_info_cie,
+                                ota_codec_peer_capability_);
+    CHECK(status == A2DP_SUCCESS);
+    return true;
+
+fail:
+    // Restore the internal state
+    codec_selectable_capability_ = saved_codec_selectable_capability;
+    memcpy(ota_codec_peer_capability_, saved_ota_codec_peer_capability,
+           sizeof(ota_codec_peer_capability_));
+    return false;
+}
+
+
diff --git a/system/bt/stack/a2dp/a2dp_vendor_lhdcv3_dec.cc b/system/bt/stack/a2dp/a2dp_vendor_lhdcv3_dec.cc
new file mode 100755
index 00000000..ef9dbb0e
--- /dev/null
+++ b/system/bt/stack/a2dp/a2dp_vendor_lhdcv3_dec.cc
@@ -0,0 +1,744 @@
+/******************************************************************************
+ *
+ *  Copyright 2002-2012 Broadcom Corporation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ *  Utility functions to help build and parse SBC Codec Information Element
+ *  and Media Payload.
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "a2dp_vendor_lhdcv3_dec"
+
+#include "bt_target.h"
+
+#include "a2dp_vendor_lhdcv3_dec.h"
+
+#include <string.h>
+
+#include <base/logging.h>
+#include "a2dp_vendor.h"
+#include "a2dp_vendor_lhdcv3_decoder.h"
+#include "bt_utils.h"
+#include "osi/include/log.h"
+#include "osi/include/osi.h"
+
+
+// data type for the LHDC Codec Information Element */
+// NOTE: bits_per_sample is needed only for LHDC encoder initialization.
+typedef struct {
+  uint32_t vendorId;
+  uint16_t codecId;    /* Codec ID for LHDC */
+  uint8_t sampleRate;  /* Sampling Frequency */
+  btav_a2dp_codec_bits_per_sample_t bits_per_sample;
+  uint8_t channelSplitMode;
+  uint8_t version;
+  uint8_t maxTargetBitrate;
+  bool isLLSupported;
+  //uint8_t supportedBitrate;
+  bool hasFeatureJAS;
+  bool hasFeatureAR;
+  bool hasFeatureLLAC;
+  bool hasFeatureMETA;
+  bool hasFeatureMinBitrate;
+  bool hasFeatureLARC;
+  bool hasFeatureLHDCV4;
+} tA2DP_LHDCV3_SINK_CIE;
+
+/* LHDC Sink codec capabilities */
+static const tA2DP_LHDCV3_SINK_CIE a2dp_lhdcv3_sink_caps = {
+    A2DP_LHDC_VENDOR_ID,  // vendorId
+    A2DP_LHDCV3_CODEC_ID,   // codecId
+    // sampleRate
+    //(A2DP_LHDC_SAMPLING_FREQ_48000),
+    (A2DP_LHDC_SAMPLING_FREQ_44100 | A2DP_LHDC_SAMPLING_FREQ_48000 | A2DP_LHDC_SAMPLING_FREQ_88200 | A2DP_LHDC_SAMPLING_FREQ_96000),
+    // bits_per_sample
+    (BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16 | BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24),
+    //Channel Separation
+    //A2DP_LHDC_CH_SPLIT_NONE | A2DP_LHDC_CH_SPLIT_TWS,
+	A2DP_LHDC_CH_SPLIT_NONE,
+    //Version number
+    A2DP_LHDC_VER3,
+    //Target bit Rate
+    A2DP_LHDC_MAX_BIT_RATE_900K,
+    //LL supported ?
+    true,
+
+    /*******************************
+     *  LHDC features/capabilities:
+     *  hasFeatureJAS
+     *  hasFeatureAR
+     *  hasFeatureLLAC
+     *  hasFeatureMETA
+     *  hasFeatureMinBitrate
+     *  hasFeatureLARC
+     *  hasFeatureLHDCV4
+     *******************************/
+    //bool hasFeatureJAS;
+    true,
+
+    //bool hasFeatureAR;
+    true,
+
+    //bool hasFeatureLLAC;
+    true,
+
+    //bool hasFeatureMETA;
+    true,
+
+    //bool hasFeatureMinBitrate;
+    true,
+
+    //bool hasFeatureLARC;
+    false,
+
+    //bool hasFeatureLHDCV4;
+    true,
+};
+
+/* Default LHDC codec configuration */
+static const tA2DP_LHDCV3_SINK_CIE a2dp_lhdcv3_sink_default_config = {
+    A2DP_LHDC_VENDOR_ID,                // vendorId
+    A2DP_LHDCV3_CODEC_ID,                 // codecId
+    A2DP_LHDC_SAMPLING_FREQ_96000,      // sampleRate
+    BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24,  // bits_per_sample
+    A2DP_LHDC_CH_SPLIT_NONE,
+    A2DP_LHDC_VER3,
+    A2DP_LHDC_MAX_BIT_RATE_900K,
+    false,
+
+    //bool hasFeatureJAS;
+    false,
+
+    //bool hasFeatureAR;
+    false,
+
+    //bool hasFeatureLLAC;
+    true,
+
+    //bool hasFeatureMETA;
+    false,
+
+    //bool hasFeatureMinBitrate;
+    true,
+
+    //bool hasFeatureLARC;
+    false,
+
+    //bool hasFeatureLHDCV4;
+    true,
+};
+
+static const tA2DP_DECODER_INTERFACE a2dp_decoder_interface_lhdcv3 = {
+    a2dp_vendor_lhdcv3_decoder_init,
+    a2dp_vendor_lhdcv3_decoder_cleanup,
+    a2dp_vendor_lhdcv3_decoder_decode_packet,
+};
+
+static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV3Sink(
+    const tA2DP_LHDCV3_SINK_CIE* p_cap, const uint8_t* p_codec_info,
+    bool is_capability);
+
+
+// Builds the LHDC Media Codec Capabilities byte sequence beginning from the
+// LOSC octet. |media_type| is the media type |AVDT_MEDIA_TYPE_*|.
+// |p_ie| is a pointer to the LHDC Codec Information Element information.
+// The result is stored in |p_result|. Returns A2DP_SUCCESS on success,
+// otherwise the corresponding A2DP error status code.
+static tA2DP_STATUS A2DP_BuildInfoLhdcV3Sink(uint8_t media_type,
+                                       const tA2DP_LHDCV3_SINK_CIE* p_ie,
+                                       uint8_t* p_result) {
+
+  const uint8_t* tmpInfo = p_result;
+  if (p_ie == NULL || p_result == NULL) {
+    return A2DP_INVALID_PARAMS;
+  }
+
+  *p_result++ = A2DP_LHDCV3_CODEC_LEN;    //0
+  *p_result++ = (media_type << 4);      //1
+  *p_result++ = A2DP_MEDIA_CT_NON_A2DP; //2
+
+  // Vendor ID and Codec ID
+  *p_result++ = (uint8_t)(p_ie->vendorId & 0x000000FF); //3
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0x0000FF00) >> 8);  //4
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0x00FF0000) >> 16); //5
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0xFF000000) >> 24); //6
+  *p_result++ = (uint8_t)(p_ie->codecId & 0x00FF);  //7
+  *p_result++ = (uint8_t)((p_ie->codecId & 0xFF00) >> 8);   //8
+
+  // Sampling Frequency & Bits per sample
+  uint8_t para = 0;
+
+  // sample rate bit0 ~ bit2
+  para = (uint8_t)(p_ie->sampleRate & A2DP_LHDC_SAMPLING_FREQ_MASK);
+
+  if (p_ie->bits_per_sample == (BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24 | BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)) {
+      para = para | (A2DP_LHDC_BIT_FMT_24 | A2DP_LHDC_BIT_FMT_16);
+  }else if(p_ie->bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24){
+      para = para | A2DP_LHDC_BIT_FMT_24;
+  }else if(p_ie->bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16){
+      para = para | A2DP_LHDC_BIT_FMT_16;
+  }
+
+  if (p_ie->hasFeatureJAS)
+  {
+    para |= A2DP_LHDC_FEATURE_JAS;
+  }
+
+  if (p_ie->hasFeatureAR)
+  {
+    para |= A2DP_LHDC_FEATURE_AR;
+  }
+
+  // Save octet 9
+  *p_result++ = para;   //9
+
+  para = p_ie->version;
+
+  para |= p_ie->maxTargetBitrate;
+
+  para |= p_ie->isLLSupported ? A2DP_LHDC_LL_SUPPORTED : A2DP_LHDC_LL_NONE;
+
+  if (p_ie->hasFeatureLLAC)
+  {
+    para |= A2DP_LHDC_FEATURE_LLAC;
+  }
+
+  // Save octet 10
+  *p_result++ = para;   //a
+
+  //Save octet 11
+  para = p_ie->channelSplitMode;
+
+  if (p_ie->hasFeatureMETA)
+  {
+    para |= A2DP_LHDC_FEATURE_META;
+  }
+
+  if (p_ie->hasFeatureMinBitrate)
+  {
+    para |= A2DP_LHDC_FEATURE_MIN_BR;
+  }
+
+  if (p_ie->hasFeatureLARC)
+  {
+    para |= A2DP_LHDC_FEATURE_LARC;
+  }
+
+  if (p_ie->hasFeatureLHDCV4)
+  {
+    para |= A2DP_LHDC_FEATURE_LHDCV4;
+  }
+
+  *p_result++ = para;   //b
+
+  //Save octet 12
+  //para = p_ie->supportedBitrate;
+  //*p_result++ = para;   //c
+
+  LOG_DEBUG(LOG_TAG, "%s: Info build result = [0]:0x%x, [1]:0x%x, [2]:0x%x, [3]:0x%x, "
+                     "[4]:0x%x, [5]:0x%x, [6]:0x%x, [7]:0x%x, [8]:0x%x, [9]:0x%x, [10]:0x%x, [11]:0x%x",
+     __func__, tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3],
+                    tmpInfo[4], tmpInfo[5], tmpInfo[6], tmpInfo[7], tmpInfo[8], tmpInfo[9], tmpInfo[10], tmpInfo[11]);
+  return A2DP_SUCCESS;
+}
+
+// Parses the LHDC Media Codec Capabilities byte sequence beginning from the
+// LOSC octet. The result is stored in |p_ie|. The byte sequence to parse is
+// |p_codec_info|. If |is_capability| is true, the byte sequence is
+// codec capabilities, otherwise is codec configuration.
+// Returns A2DP_SUCCESS on success, otherwise the corresponding A2DP error
+// status code.
+static tA2DP_STATUS A2DP_ParseInfoLhdcV3Sink(tA2DP_LHDCV3_SINK_CIE* p_ie,
+                                       const uint8_t* p_codec_info,
+                                       bool is_capability) {
+  uint8_t losc;
+  uint8_t media_type;
+  tA2DP_CODEC_TYPE codec_type;
+  const uint8_t* tmpInfo = p_codec_info;
+  const uint8_t* p_codec_Info_save = p_codec_info;
+
+  //LOG_DEBUG(LOG_TAG, "%s: p_ie = %p, p_codec_info = %p", __func__, p_ie, p_codec_info);
+  if (p_ie == NULL || p_codec_info == NULL) return A2DP_INVALID_PARAMS;
+
+  // Check the codec capability length
+  losc = *p_codec_info++;
+
+  if (losc != A2DP_LHDCV3_CODEC_LEN) return A2DP_WRONG_CODEC;
+
+  media_type = (*p_codec_info++) >> 4;
+  codec_type = *p_codec_info++;
+    //LOG_DEBUG(LOG_TAG, "%s: media_type = %d, codec_type = %d", __func__, media_type, codec_type);
+  /* Check the Media Type and Media Codec Type */
+  if (media_type != AVDT_MEDIA_TYPE_AUDIO ||
+      codec_type != A2DP_MEDIA_CT_NON_A2DP) {
+    return A2DP_WRONG_CODEC;
+  }
+
+  // Check the Vendor ID and Codec ID */
+  p_ie->vendorId = (*p_codec_info & 0x000000FF) |
+                   (*(p_codec_info + 1) << 8 & 0x0000FF00) |
+                   (*(p_codec_info + 2) << 16 & 0x00FF0000) |
+                   (*(p_codec_info + 3) << 24 & 0xFF000000);
+  p_codec_info += 4;
+  p_ie->codecId =
+      (*p_codec_info & 0x00FF) | (*(p_codec_info + 1) << 8 & 0xFF00);
+  p_codec_info += 2;
+  LOG_DEBUG(LOG_TAG, "%s:Vendor(0x%08x), Codec(0x%04x)", __func__, p_ie->vendorId, p_ie->codecId);
+  if (p_ie->vendorId != A2DP_LHDC_VENDOR_ID ||
+      p_ie->codecId != A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_WRONG_CODEC;
+  }
+
+  p_ie->sampleRate = *p_codec_info & A2DP_LHDC_SAMPLING_FREQ_MASK;
+  if ((*p_codec_info & A2DP_LHDC_BIT_FMT_MASK) == 0) {
+    return A2DP_WRONG_CODEC;
+  }
+
+  p_ie->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+  if (*p_codec_info & A2DP_LHDC_BIT_FMT_24)
+    p_ie->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+  if (*p_codec_info & A2DP_LHDC_BIT_FMT_16) {
+    p_ie->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+  }
+
+
+  p_codec_info += 1;
+
+  p_ie->version = (*p_codec_info) & A2DP_LHDC_VERSION_MASK;
+  //p_ie->version = 1;
+
+  p_ie->maxTargetBitrate = (*p_codec_info) & A2DP_LHDC_MAX_BIT_RATE_MASK;
+  //p_ie->maxTargetBitrate = A2DP_LHDC_MAX_BIT_RATE_900K;
+
+  p_ie->isLLSupported = ((*p_codec_info & A2DP_LHDC_LL_MASK) != 0)? true : false;
+  //p_ie->isLLSupported = false;
+
+  p_codec_info += 1;
+
+  p_ie->channelSplitMode = (*p_codec_info) & A2DP_LHDC_CH_SPLIT_MSK;
+
+  //p_codec_info += 1;
+
+  //p_ie->supportedBitrate = (*p_codec_info);
+
+
+
+
+    LOG_DEBUG(LOG_TAG, "%s: codec info = [0]:0x%x, [1]:0x%x, [2]:0x%x, [3]:0x%x, [4]:0x%x, [5]:0x%x, [6]:0x%x, [7]:0x%x, [8]:0x%x, [9]:0x%x, [10]:0x%x, [11]:0x%x",
+            __func__, tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3], tmpInfo[4], tmpInfo[5], tmpInfo[6],
+                        tmpInfo[7], tmpInfo[8], tmpInfo[9], tmpInfo[10], tmpInfo[11]);
+
+  if (is_capability) return A2DP_SUCCESS;
+
+  if (A2DP_BitsSet(p_ie->sampleRate) != A2DP_SET_ONE_BIT)
+    return A2DP_BAD_SAMP_FREQ;
+
+  save_codec_info (p_codec_Info_save);
+
+  return A2DP_SUCCESS;
+}
+
+const char* A2DP_VendorCodecNameLhdcV3Sink(UNUSED_ATTR const uint8_t* p_codec_info) {
+  return "LHDC V3";
+}
+
+bool A2DP_IsVendorSinkCodecValidLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV3_SINK_CIE cfg_cie;
+
+  /* Use a liberal check when parsing the codec info */
+  return (A2DP_ParseInfoLhdcV3Sink(&cfg_cie, p_codec_info, false) == A2DP_SUCCESS) ||
+         (A2DP_ParseInfoLhdcV3Sink(&cfg_cie, p_codec_info, true) == A2DP_SUCCESS);
+}
+
+
+bool A2DP_IsVendorPeerSourceCodecValidLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV3_SINK_CIE cfg_cie;
+
+  /* Use a liberal check when parsing the codec info */
+  return (A2DP_ParseInfoLhdcV3Sink(&cfg_cie, p_codec_info, false) == A2DP_SUCCESS) ||
+         (A2DP_ParseInfoLhdcV3Sink(&cfg_cie, p_codec_info, true) == A2DP_SUCCESS);
+}
+
+
+bool A2DP_IsVendorSinkCodecSupportedLhdcV3(const uint8_t* p_codec_info) {
+  return (A2DP_CodecInfoMatchesCapabilityLhdcV3Sink(&a2dp_lhdcv3_sink_caps, p_codec_info,
+                                             false) == A2DP_SUCCESS);
+}
+
+bool A2DP_IsPeerSourceCodecSupportedLhdcV3(const uint8_t* p_codec_info) {
+  return (A2DP_CodecInfoMatchesCapabilityLhdcV3Sink(&a2dp_lhdcv3_sink_caps, p_codec_info,
+                                             true) == A2DP_SUCCESS);
+}
+
+void A2DP_InitDefaultCodecLhdcV3Sink(uint8_t* p_codec_info) {
+  LOG_DEBUG(LOG_TAG, "%s: enter", __func__);
+  if (A2DP_BuildInfoLhdcV3Sink(AVDT_MEDIA_TYPE_AUDIO, &a2dp_lhdcv3_sink_default_config,
+                        p_codec_info) != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: A2DP_BuildInfoSbc failed", __func__);
+  }
+}
+
+// Checks whether A2DP SBC codec configuration matches with a device's codec
+// capabilities. |p_cap| is the SBC codec configuration. |p_codec_info| is
+// the device's codec capabilities. |is_capability| is true if
+// |p_codec_info| contains A2DP codec capability.
+// Returns A2DP_SUCCESS if the codec configuration matches with capabilities,
+// otherwise the corresponding A2DP error status code.
+static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV3Sink(
+    const tA2DP_LHDCV3_SINK_CIE* p_cap, const uint8_t* p_codec_info,
+    bool is_capability) {
+  tA2DP_STATUS status;
+  tA2DP_LHDCV3_SINK_CIE cfg_cie;
+
+  /* parse configuration */
+  status = A2DP_ParseInfoLhdcV3Sink(&cfg_cie, p_codec_info, is_capability);
+  if (status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: parsing failed %d", __func__, status);
+    return status;
+  }
+
+  /* verify that each parameter is in range */
+
+  LOG_DEBUG(LOG_TAG, "%s: FREQ peer: 0x%x, capability 0x%x", __func__,
+            cfg_cie.sampleRate, p_cap->sampleRate);
+
+  LOG_DEBUG(LOG_TAG, "%s: BIT_FMT peer: 0x%x, capability 0x%x", __func__,
+            cfg_cie.bits_per_sample, p_cap->bits_per_sample);
+
+  /* sampling frequency */
+  if ((cfg_cie.sampleRate & p_cap->sampleRate) == 0) return A2DP_NS_SAMP_FREQ;
+
+  /* bit per sample */
+  if ((cfg_cie.bits_per_sample & p_cap->bits_per_sample) == 0) return A2DP_NS_CH_MODE;
+
+  return A2DP_SUCCESS;
+}
+
+bool A2DP_VendorCodecTypeEqualsLhdcV3Sink(const uint8_t* p_codec_info_a,
+                                    const uint8_t* p_codec_info_b) {
+  tA2DP_LHDCV3_SINK_CIE lhdc_cie_a;
+  tA2DP_LHDCV3_SINK_CIE lhdc_cie_b;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status =
+      A2DP_ParseInfoLhdcV3Sink(&lhdc_cie_a, p_codec_info_a, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return false;
+  }
+  a2dp_status = A2DP_ParseInfoLhdcV3Sink(&lhdc_cie_b, p_codec_info_b, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return false;
+  }
+
+  return true;
+}
+
+bool A2DP_VendorCodecEqualsLhdcV3Sink(const uint8_t* p_codec_info_a,
+                                const uint8_t* p_codec_info_b) {
+  tA2DP_LHDCV3_SINK_CIE lhdc_cie_a;
+  tA2DP_LHDCV3_SINK_CIE lhdc_cie_b;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status =
+      A2DP_ParseInfoLhdcV3Sink(&lhdc_cie_a, p_codec_info_a, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return false;
+  }
+  a2dp_status = A2DP_ParseInfoLhdcV3Sink(&lhdc_cie_b, p_codec_info_b, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return false;
+  }
+
+  return (lhdc_cie_a.sampleRate == lhdc_cie_b.sampleRate) &&
+         (lhdc_cie_a.bits_per_sample == lhdc_cie_b.bits_per_sample) &&
+         /*(lhdc_cie_a.supportedBitrate == lhdc_cie_b.supportedBitrate) &&*/
+         (lhdc_cie_a.isLLSupported == lhdc_cie_b.isLLSupported);
+}
+
+
+int A2DP_VendorGetTrackSampleRateLhdcV3Sink(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV3_SINK_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3Sink(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+  switch (lhdc_cie.sampleRate) {
+    case A2DP_LHDC_SAMPLING_FREQ_44100:
+      return 44100;
+    case A2DP_LHDC_SAMPLING_FREQ_48000:
+      return 48000;
+    case A2DP_LHDC_SAMPLING_FREQ_88200:
+      return 88200;
+    case A2DP_LHDC_SAMPLING_FREQ_96000:
+      return 96000;
+  }
+
+  return -1;
+}
+
+int A2DP_VendorGetSinkTrackChannelTypeLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV3_SINK_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3Sink(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+  return A2DP_LHDC_CHANNEL_MODE_STEREO;
+}
+
+int A2DP_VendorGetChannelModeCodeLhdcV3Sink(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV3_SINK_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3Sink(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+  return A2DP_LHDC_CHANNEL_MODE_STEREO;
+}
+
+bool A2DP_VendorGetPacketTimestampLhdcV3Sink(UNUSED_ATTR const uint8_t* p_codec_info,
+                                       const uint8_t* p_data,
+                                       uint32_t* p_timestamp) {
+  // TODO: Is this function really codec-specific?
+  *p_timestamp = *(const uint32_t*)p_data;
+  return true;
+}
+/*
+bool A2DP_VendorBuildCodecHeaderLhdcV3Sink(UNUSED_ATTR const uint8_t* p_codec_info,
+                              BT_HDR* p_buf, uint16_t frames_per_packet) {
+  uint8_t* p;
+
+  p_buf->offset -= A2DP_SBC_MPL_HDR_LEN;
+  p = (uint8_t*)(p_buf + 1) + p_buf->offset;
+  p_buf->len += A2DP_SBC_MPL_HDR_LEN;
+  A2DP_BuildMediaPayloadHeaderSbc(p, false, false, false,
+                                  (uint8_t)frames_per_packet);
+
+  return true;
+}
+*/
+std::string A2DP_VendorCodecInfoStringLhdcV3Sink(const uint8_t* p_codec_info) {
+  std::stringstream res;
+  std::string field;
+  tA2DP_STATUS a2dp_status;
+  tA2DP_LHDCV3_SINK_CIE lhdc_cie;
+
+  a2dp_status = A2DP_ParseInfoLhdcV3Sink(&lhdc_cie, p_codec_info, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    res << "A2DP_ParseInfoLhdcV3Sink fail: " << loghex(a2dp_status);
+    return res.str();
+  }
+
+  res << "\tname: LHDC\n";
+
+  // Sample frequency
+  field.clear();
+  AppendField(&field, (lhdc_cie.sampleRate == 0), "NONE");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100),
+              "44100");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000),
+              "48000");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200),
+              "88200");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000),
+              "96000");
+  res << "\tsamp_freq: " << field << " (" << loghex(lhdc_cie.sampleRate)
+      << ")\n";
+
+  // Channel mode
+  field.clear();
+  AppendField(&field, 1,
+             "Stereo");
+  res << "\tch_mode: " << field << " (" << "Only support stereo."
+      << ")\n";
+
+  // bits per sample
+  field.clear();
+  AppendField(&field, (lhdc_cie.bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16),
+              "16");
+  AppendField(&field, (lhdc_cie.bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24),
+              "24");
+  res << "\tbits_depth: " << field << " bits (" << loghex((int)lhdc_cie.bits_per_sample)
+      << ")\n";
+
+  // Max data rate...
+  field.clear();
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_900K),
+              "900Kbps");
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_500K),
+              "500Kbps");
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_400K),
+              "400Kbps");
+  res << "\tMax target-rate: " << field << " (" << loghex((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK))
+      << ")\n";
+
+  // Version
+  field.clear();
+  AppendField(&field, (lhdc_cie.version == A2DP_LHDC_VER3),
+              "LHDC V3");
+  res << "\tversion: " << field << " (" << loghex(lhdc_cie.version)
+      << ")\n";
+
+
+  /*
+  field.clear();
+  AppendField(&field, 0, "NONE");
+  AppendField(&field, 0,
+              "Mono");
+  AppendField(&field, 0,
+              "Dual");
+  AppendField(&field, 1,
+              "Stereo");
+  res << "\tch_mode: " << field << " (" << loghex(lhdc_cie.channelMode)
+      << ")\n";
+*/
+  return res.str();
+}
+
+const tA2DP_DECODER_INTERFACE* A2DP_VendorGetDecoderInterfaceLhdcV3(
+    const uint8_t* p_codec_info) {
+  if (!A2DP_IsVendorSinkCodecValidLhdcV3(p_codec_info)) return NULL;
+
+  return &a2dp_decoder_interface_lhdcv3;
+}
+
+bool A2DP_VendorAdjustCodecLhdcV3Sink(uint8_t* p_codec_info) {
+  tA2DP_LHDCV3_SINK_CIE cfg_cie;
+
+  // Nothing to do: just verify the codec info is valid
+  if (A2DP_ParseInfoLhdcV3Sink(&cfg_cie, p_codec_info, true) != A2DP_SUCCESS)
+    return false;
+
+  return true;
+}
+
+btav_a2dp_codec_index_t A2DP_VendorSinkCodecIndexLhdcV3(
+    UNUSED_ATTR const uint8_t* p_codec_info) {
+  return BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3;
+}
+
+const char* A2DP_VendorCodecIndexStrLhdcV3Sink(void) { return "LHDC V3 SINK"; }
+
+bool A2DP_VendorInitCodecConfigLhdcV3Sink(AvdtpSepConfig* p_cfg) {
+  LOG_DEBUG(LOG_TAG, "%s: enter", __func__);
+  if (A2DP_BuildInfoLhdcV3Sink(AVDT_MEDIA_TYPE_AUDIO, &a2dp_lhdcv3_sink_caps,
+                        p_cfg->codec_info) != A2DP_SUCCESS) {
+    return false;
+  }
+
+  return true;
+}
+
+UNUSED_ATTR static void build_codec_config(const tA2DP_LHDCV3_SINK_CIE& config_cie,
+                                           btav_a2dp_codec_config_t* result) {
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+
+  result->bits_per_sample = config_cie.bits_per_sample;
+
+  result->channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+}
+
+
+
+
+
+A2dpCodecConfigLhdcV3Sink::A2dpCodecConfigLhdcV3Sink(
+    btav_a2dp_codec_priority_t codec_priority)
+    : A2dpCodecConfigLhdcV3Base(BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3,
+                             A2DP_VendorCodecIndexStrLhdcV3Sink(), codec_priority,
+                             false) {}
+
+A2dpCodecConfigLhdcV3Sink::~A2dpCodecConfigLhdcV3Sink() {}
+
+bool A2dpCodecConfigLhdcV3Sink::init() {
+  if (!isValid()) return false;
+
+  // Load the decoder
+  if (!A2DP_VendorLoadDecoderLhdcV3()) {
+    LOG_ERROR(LOG_TAG, "%s: cannot load the decoder", __func__);
+    return false;
+  }
+
+  return true;
+}
+
+bool A2dpCodecConfigLhdcV3Sink::useRtpHeaderMarkerBit() const {
+  // TODO: This method applies only to Source codecs
+  return false;
+}
+
+bool A2dpCodecConfigLhdcV3Sink::updateEncoderUserConfig(
+    UNUSED_ATTR const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+    UNUSED_ATTR bool* p_restart_input, UNUSED_ATTR bool* p_restart_output,
+    UNUSED_ATTR bool* p_config_updated) {
+  // TODO: This method applies only to Source codecs
+  return false;
+}
+
+uint64_t A2dpCodecConfigLhdcV3Sink::encoderIntervalMs() const {
+  // TODO: This method applies only to Source codecs
+  return 0;
+}
+
+int A2dpCodecConfigLhdcV3Sink::getEffectiveMtu() const {
+  // TODO: This method applies only to Source codecs
+  return 0;
+}
+
+
+bool A2dpCodecConfigLhdcV3Base::setCodecConfig(const uint8_t* p_peer_codec_info, bool is_capability,
+                      uint8_t* p_result_codec_config) {
+  is_source_ = false;
+  return true;
+}
+
+bool A2dpCodecConfigLhdcV3Base::setPeerCodecCapabilities(
+      const uint8_t* p_peer_codec_capabilities) {
+  is_source_ = false;
+  return true;
+}
+
+
diff --git a/system/bt/stack/a2dp/a2dp_vendor_lhdcv3_decoder.cc b/system/bt/stack/a2dp/a2dp_vendor_lhdcv3_decoder.cc
new file mode 100755
index 00000000..5a792fc8
--- /dev/null
+++ b/system/bt/stack/a2dp/a2dp_vendor_lhdcv3_decoder.cc
@@ -0,0 +1,550 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "a2dp_vendor_lhdcv3_decoder"
+
+#include "a2dp_vendor_lhdcv3_decoder.h"
+
+#include <dlfcn.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <lhdcBT_dec.h>
+
+#include "bt_common.h"
+#include "common/time_util.h"
+#include "osi/include/log.h"
+#include "osi/include/osi.h"
+
+
+
+#define A2DP_LHDC_FUNC_DISABLE		0
+#define A2DP_LHDC_FUNC_ENABLE		1
+
+#define LHDCV3_DEC_MAX_SAMPLES_PER_FRAME  256
+#define LHDCV3_DEC_MAX_CHANNELS           2
+#define LHDCV3_DEC_MAX_BIT_DEPTH          32
+#define LHDCV3_DEC_FRAME_NUM              16
+#define LHDCV3_DEC_BUF_BYTES              (LHDCV3_DEC_FRAME_NUM * LHDCV3_DEC_MAX_SAMPLES_PER_FRAME * LHDCV3_DEC_MAX_CHANNELS * (LHDCV3_DEC_MAX_BIT_DEPTH >> 3))
+#define LHDCV3_DEC_PACKET_NUM             8
+
+#define LHDCV3_DEC_INPUT_BUF_BYTES        1024
+
+#define LHDCV3_DEC_PKT_HDR_BYTES          2
+
+typedef struct {
+  lhdc_ver_t  version;
+  uint32_t    sample_rate;
+  uint8_t     bits_per_sample;
+  uint8_t     func_ch_split;
+  uint8_t     func_ar;
+  uint8_t     func_jas;
+  uint8_t     func_meta;
+
+  uint32_t    timestamp;        // Timestamp for the A2DP frames
+  uint8_t     decode_buf[LHDCV3_DEC_PACKET_NUM][LHDCV3_DEC_BUF_BYTES];
+  uint32_t    dec_buf_idx;
+
+  uint8_t     dec_input_buf[LHDCV3_DEC_INPUT_BUF_BYTES];
+  uint32_t    dec_input_buf_bytes;
+
+  decoded_data_callback_t decode_callback;
+} tA2DP_LHDCV3_DECODER_CB;
+
+static tA2DP_LHDCV3_DECODER_CB a2dp_lhdcv3_decoder_cb;
+
+
+#define _DEC_REC_FILE_
+#if defined(_DEC_REC_FILE_)
+#define RAW_FILE_NAME "/sdcard/Download/lhdcdec.raw"
+#define PCM_FILE_NAME "/sdcard/Download/decoded.pcm"
+static FILE *rawFile = NULL;
+static FILE *pcmFile = NULL;
+#endif
+
+//
+// Decoder for LHDC Sink Codec
+//
+
+//
+// The LHDC decoder shared library, and the functions to use
+//
+static const char* LHDC_DECODER_LIB_NAME = "liblhdcBT_dec.so";
+static void* lhdc_decoder_lib_handle = NULL;
+
+
+static const char* LHDCDEC_INIT_DECODER_NAME = "lhdcBT_dec_init_decoder";
+typedef int (*tLHDCDEC_INIT_DECODER)(tLHDCV3_DEC_CONFIG *config);
+
+static const char* LHDCDEC_CHECK_FRAME_DATA_ENOUGH_NAME = "lhdcBT_dec_check_frame_data_enough";
+typedef int (*tLHDCDEC_CHECK_FRAME_DATA_ENOUGH)(const uint8_t *frameData, uint32_t frameBytes, uint32_t *packetBytes);
+
+static const char* LHDCDEC_DECODE_NAME = "lhdcBT_dec_decode";
+typedef int (*tLHDCDEC_DECODE)(const uint8_t *frameData, uint32_t frameBytes, uint8_t* pcmData, uint32_t* pcmBytes, uint32_t bits_depth);
+
+static const char* LHDCDEC_DEINIT_DECODER_NAME = "lhdcBT_dec_deinit_decoder";
+typedef int (*tLHDCDEC_DEINIT_DECODER)(void);
+
+
+static tLHDCDEC_INIT_DECODER lhdcdec_init_decoder;
+static tLHDCDEC_CHECK_FRAME_DATA_ENOUGH lhdcdec_check_frame_data_enough;
+static tLHDCDEC_DECODE lhdcdec_decode;
+static tLHDCDEC_DEINIT_DECODER lhdcdec_deinit_decoder;
+
+
+
+
+// LHDC v4 Extend flags
+#define A2DP_LHDC_FLAG_JAS            0x40
+#define A2DP_LHDC_FLAG_AR             0x80
+
+#define A2DP_LHDC_FLAG_LLAC           0x80
+
+#define A2DP_LHDC_FLAG_META           0x10
+#define A2DP_LHDC_FLAG_MBR            0x20
+#define A2DP_LHDC_FLAG_LARC           0x40
+#define A2DP_LHDC_FLAG_V4             0x80
+
+
+
+// offset  0		1B	codec capability length (11 Bytes)
+// offset  1		1B	[7:4] media type
+// offset  2		1B  codec type
+// offset  3		4B	Vendor ID
+// offset  7		2B	Codec ID
+// offset  9		3B 	LHDC specific capability
+#define A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1	9
+#define A2DP_LHDCV3_CODEC_INFO_SPECIFIC_2	10
+#define A2DP_LHDCV3_CODEC_INFO_SPECIFIC_3	11
+
+
+bool save_codec_info (const uint8_t* p_codec_info)
+{
+  if (p_codec_info == NULL)
+  {
+    return false;
+  }
+
+
+  if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1] & 
+      A2DP_LHDC_SAMPLING_FREQ_44100)
+  {
+    a2dp_lhdcv3_decoder_cb.sample_rate = 44100;
+  }
+  else if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1] & 
+           A2DP_LHDC_SAMPLING_FREQ_48000)
+  {
+	a2dp_lhdcv3_decoder_cb.sample_rate = 48000;
+  }
+  else if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1] & 
+           A2DP_LHDC_SAMPLING_FREQ_96000)
+  {
+	a2dp_lhdcv3_decoder_cb.sample_rate = 96000;
+  }
+  else
+  {
+    return false;
+  }
+
+
+  if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1] & 
+      A2DP_LHDC_BIT_FMT_16)
+  {
+    a2dp_lhdcv3_decoder_cb.bits_per_sample = 16;
+  }
+  else if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1] & 
+           A2DP_LHDC_BIT_FMT_24)
+  {
+	a2dp_lhdcv3_decoder_cb.bits_per_sample = 24;
+  }
+  else
+  {
+    return false;
+  }
+
+  if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_2] & A2DP_LHDC_FLAG_LLAC)
+  {
+    //LLAC only 
+    a2dp_lhdcv3_decoder_cb.version = VERSION_LLAC;
+    LOG_DEBUG(LOG_TAG, "%s: LLAC only", __func__);
+  }
+  else if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_3] & A2DP_LHDC_FLAG_V4) 
+  {
+    //LHDCV4 only 
+    a2dp_lhdcv3_decoder_cb.version = VERSION_4;
+    LOG_DEBUG(LOG_TAG, "%s: LHDC V4 only", __func__);
+  }
+  else
+  {
+    //LHDCV3 only 
+	a2dp_lhdcv3_decoder_cb.version = VERSION_3;
+    LOG_DEBUG(LOG_TAG, "%s: LHDC V3 only", __func__);
+  }
+
+  if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_3] & A2DP_LHDC_CH_SPLIT_NONE)
+  {
+    a2dp_lhdcv3_decoder_cb.func_ch_split = A2DP_LHDC_FUNC_DISABLE;
+  }
+  else if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_3] & A2DP_LHDC_CH_SPLIT_TWS)
+  {
+	a2dp_lhdcv3_decoder_cb.func_ch_split = A2DP_LHDC_FUNC_ENABLE;
+  }
+  else
+  {
+    return false;
+  }
+
+  // AR
+  if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1] & A2DP_LHDC_FLAG_AR)
+  {
+	a2dp_lhdcv3_decoder_cb.func_ar = A2DP_LHDC_FUNC_ENABLE;
+  }
+  else
+  {
+    a2dp_lhdcv3_decoder_cb.func_ar = A2DP_LHDC_FUNC_DISABLE;
+  }
+
+  // JAS
+  if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1] & A2DP_LHDC_FLAG_JAS)
+  {
+	a2dp_lhdcv3_decoder_cb.func_jas = A2DP_LHDC_FUNC_ENABLE;
+  }
+  else
+  {
+    a2dp_lhdcv3_decoder_cb.func_jas = A2DP_LHDC_FUNC_DISABLE;
+  }
+
+  // META
+  if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_3] & A2DP_LHDC_FLAG_META)
+  {
+	a2dp_lhdcv3_decoder_cb.func_meta = A2DP_LHDC_FUNC_ENABLE;
+  }
+  else
+  {
+    a2dp_lhdcv3_decoder_cb.func_meta = A2DP_LHDC_FUNC_DISABLE;
+  }
+
+  return true;
+
+}
+
+
+static void* load_func(const char* func_name) {
+
+  void* func_ptr = NULL;
+
+  if ((func_name == NULL) ||
+      (lhdc_decoder_lib_handle == NULL))  {
+
+    return NULL;
+  }
+
+  func_ptr = dlsym(lhdc_decoder_lib_handle, func_name);
+
+  if (func_ptr == NULL) {
+    LOG_ERROR(LOG_TAG,
+              "%s: cannot find function '%s' in the encoder library: %s",
+              __func__, func_name, dlerror());
+    A2DP_VendorUnloadDecoderLhdcV3();
+    return NULL;
+  }
+
+  return func_ptr;
+}
+
+
+bool A2DP_VendorLoadDecoderLhdcV3(void) {
+
+  if (lhdc_decoder_lib_handle != NULL) return true;  // Already loaded
+
+  memset(&a2dp_lhdcv3_decoder_cb, 0, sizeof(a2dp_lhdcv3_decoder_cb));
+
+  // Open the encoder library
+  lhdc_decoder_lib_handle = dlopen(LHDC_DECODER_LIB_NAME, RTLD_NOW);
+  if (lhdc_decoder_lib_handle == NULL) {
+    LOG_ERROR(LOG_TAG, "%s: cannot open LHDC decoder library %s: %s", __func__,
+              LHDC_DECODER_LIB_NAME, dlerror());
+    return false;
+  }
+
+
+  // Load all functions
+  lhdcdec_init_decoder = (tLHDCDEC_INIT_DECODER)load_func(LHDCDEC_INIT_DECODER_NAME);
+  if (lhdcdec_init_decoder == NULL) return false;
+
+  lhdcdec_check_frame_data_enough = (tLHDCDEC_CHECK_FRAME_DATA_ENOUGH)load_func(LHDCDEC_CHECK_FRAME_DATA_ENOUGH_NAME);
+  if (lhdcdec_check_frame_data_enough == NULL) return false;
+
+  lhdcdec_decode = (tLHDCDEC_DECODE)load_func(LHDCDEC_DECODE_NAME);
+  if (lhdcdec_decode == NULL) return false;
+
+  lhdcdec_deinit_decoder = (tLHDCDEC_DEINIT_DECODER)load_func(LHDCDEC_DEINIT_DECODER_NAME);
+  if (lhdcdec_deinit_decoder == NULL) return false;
+
+  return true;
+}
+
+
+void A2DP_VendorUnloadDecoderLhdcV3(void) {
+  a2dp_vendor_lhdcv3_decoder_cleanup();
+}
+
+
+bool a2dp_vendor_lhdcv3_decoder_init(decoded_data_callback_t decode_callback) {
+  LOG_ERROR(LOG_TAG, "%s: A2DP Sink", __func__);
+
+  tLHDCV3_DEC_CONFIG  lhdcdec_config;
+  int  fn_ret;
+
+
+  if ((lhdc_decoder_lib_handle == NULL) ||
+      (lhdcdec_init_decoder == NULL) ||
+	  (lhdcdec_deinit_decoder == NULL)) {
+
+	return false;
+  }
+
+  lhdcdec_deinit_decoder ();
+
+  lhdcdec_config.version = a2dp_lhdcv3_decoder_cb.version;
+  lhdcdec_config.sample_rate = a2dp_lhdcv3_decoder_cb.sample_rate;
+  lhdcdec_config.bits_depth = a2dp_lhdcv3_decoder_cb.bits_per_sample;
+
+  fn_ret = lhdcdec_init_decoder (&lhdcdec_config);
+
+  if (fn_ret != LHDCBT_DEC_FUNC_SUCCEED) {
+
+    return false;
+  }
+
+  a2dp_lhdcv3_decoder_cb.dec_buf_idx = 0;
+  a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes = 0;
+  a2dp_lhdcv3_decoder_cb.decode_callback = decode_callback;
+
+#if defined(_DEC_REC_FILE_)
+  if (rawFile == NULL) {
+    rawFile = fopen(RAW_FILE_NAME,"wb");
+    LOG_DEBUG(LOG_TAG, "%s: Create recode file = %p", __func__, rawFile);
+  }
+  if (pcmFile == NULL) {
+    pcmFile = fopen(PCM_FILE_NAME,"wb");
+    LOG_DEBUG(LOG_TAG, "%s: Create recode file = %p", __func__, pcmFile);
+  }
+#endif
+  return true;
+}
+
+
+void a2dp_vendor_lhdcv3_decoder_cleanup(void) {
+  // Cleanup any LHDC-related state
+
+  LOG_DEBUG(LOG_TAG, "%s: lhdc_decoder_lib_handle = %p", __func__, lhdc_decoder_lib_handle);
+
+  if (lhdc_decoder_lib_handle == NULL) {
+
+	return;
+  }
+
+  if (lhdcdec_deinit_decoder != NULL) {
+
+    lhdcdec_deinit_decoder ();
+  }
+
+  memset(&a2dp_lhdcv3_decoder_cb, 0, sizeof(a2dp_lhdcv3_decoder_cb));
+
+  dlclose(lhdc_decoder_lib_handle);
+  lhdc_decoder_lib_handle = NULL;
+
+#if defined(_DEC_REC_FILE_)
+  if (rawFile != NULL) {
+    fclose(rawFile);
+    rawFile = NULL;
+    remove(RAW_FILE_NAME);
+  }
+  if (pcmFile != NULL) {
+    fclose(pcmFile);
+    pcmFile = NULL;
+    remove(PCM_FILE_NAME);
+  }
+#endif
+}
+
+bool a2dp_vendor_lhdcv3_decoder_decode_packet(BT_HDR* p_buf) {
+  uint8_t* data;
+  size_t data_size;
+  uint32_t out_used = 0;
+  int fn_ret;
+  uint32_t dec_buf_idx;
+  uint8_t *ptr_src;
+  uint8_t *ptr_dst;
+  uint32_t packet_bytes;
+  uint32_t i;
+
+
+  if (p_buf == NULL) {
+
+	return false;
+  }
+
+  data = p_buf->data + p_buf->offset;
+  data_size = p_buf->len;
+
+  dec_buf_idx = a2dp_lhdcv3_decoder_cb.dec_buf_idx++;
+  if (a2dp_lhdcv3_decoder_cb.dec_buf_idx >= LHDCV3_DEC_PACKET_NUM)
+  {
+	a2dp_lhdcv3_decoder_cb.dec_buf_idx = 0;
+  }
+
+
+  if (data_size == 0) {
+    LOG_ERROR(LOG_TAG, "%s: Empty packet", __func__);
+    return false;
+  }
+
+  if ((lhdc_decoder_lib_handle == NULL) ||
+      (lhdcdec_decode == NULL)) {
+
+    LOG_ERROR(LOG_TAG, "%s: Invalid handle!", __func__);
+    return false;
+  }
+
+#if defined(_DEC_REC_FILE_)
+  if (rawFile != NULL && data_size > 0) {
+    fwrite(data + LHDCV3_DEC_PKT_HDR_BYTES, sizeof(uint8_t), data_size - LHDCV3_DEC_PKT_HDR_BYTES, rawFile);
+  }
+#endif
+
+  if ((a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes + data_size) > LHDCV3_DEC_INPUT_BUF_BYTES)
+  {
+	// the data queued is useless
+	// discard them
+    a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes = 0;
+
+	if (data_size > LHDCV3_DEC_INPUT_BUF_BYTES)
+	{
+	  // input data is too big (more than buffer size)!!
+	  // just ingore it, and do nothing
+	  return true;
+	}
+  }
+
+  memcpy (&(a2dp_lhdcv3_decoder_cb.dec_input_buf[a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes]), 
+          data, 
+          data_size);
+  a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes += data_size;
+
+  packet_bytes = 0;
+  fn_ret = lhdcdec_check_frame_data_enough (a2dp_lhdcv3_decoder_cb.dec_input_buf, 
+                                            a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes,
+											&packet_bytes);
+
+  if (fn_ret == LHDCBT_DEC_FUNC_INPUT_NOT_ENOUGH) {
+    LOG_ERROR(LOG_TAG, "%s: Input buffer is NOT enough!, but return true", __func__);
+    return true;
+  }
+  else if (fn_ret != LHDCBT_DEC_FUNC_SUCCEED) {
+
+    LOG_ERROR(LOG_TAG, "%s: fail to check frame data!", __func__);
+
+    // clear the data in the input buffer
+    a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes = 0;
+    return false;
+  }
+
+  if (packet_bytes != (a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes - LHDCV3_DEC_PKT_HDR_BYTES))
+  {
+	// strange!
+	// queued data is NOT exactly equal to one packet!
+	// maybe wrong data in buffer
+	// discard data queued previously, and save input data
+	LOG_ERROR(LOG_TAG, "%s: queued data is NOT exactly equal to one packet! packet (%d),  input (%d)", __func__, packet_bytes, a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes);
+
+	a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes = 0;
+	memcpy (&(a2dp_lhdcv3_decoder_cb.dec_input_buf[a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes]), 
+            data, 
+            data_size);
+    a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes += data_size;
+	return true;
+  }
+
+  out_used = sizeof(a2dp_lhdcv3_decoder_cb.decode_buf[dec_buf_idx]);
+  fn_ret = lhdcdec_decode (a2dp_lhdcv3_decoder_cb.dec_input_buf, 
+                           a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes, 
+                           a2dp_lhdcv3_decoder_cb.decode_buf[dec_buf_idx],
+						   &out_used,
+						   a2dp_lhdcv3_decoder_cb.bits_per_sample);
+
+  // finish decoding
+  // clear the data in the input buffer
+  a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes = 0;
+
+  if (fn_ret != LHDCBT_DEC_FUNC_SUCCEED) {
+
+    LOG_ERROR(LOG_TAG, "%s: fail to decode lhdc stream!", __func__);
+    return false;
+  }
+
+  if (a2dp_lhdcv3_decoder_cb.bits_per_sample == 24) {
+    ptr_src = a2dp_lhdcv3_decoder_cb.decode_buf[dec_buf_idx];
+	ptr_dst = a2dp_lhdcv3_decoder_cb.decode_buf[dec_buf_idx];
+
+    for (i = 0; i < (out_used >> 2) ; i++) {
+	  *ptr_dst++ = *ptr_src++;
+	  *ptr_dst++ = *ptr_src++;
+	  *ptr_dst++ = *ptr_src++;
+	  ptr_src++;
+    }
+	
+	out_used = (out_used >> 2) * 3;
+  }
+
+#if defined(_DEC_REC_FILE_)
+  if (pcmFile != NULL && out_used > 0 && out_used <= sizeof(a2dp_lhdcv3_decoder_cb.decode_buf[dec_buf_idx])) {
+    int write_bytes;
+
+    write_bytes = fwrite(a2dp_lhdcv3_decoder_cb.decode_buf[dec_buf_idx], sizeof(uint8_t), out_used, pcmFile);
+  }
+#endif
+
+  a2dp_lhdcv3_decoder_cb.decode_callback(
+      reinterpret_cast<uint8_t*>(a2dp_lhdcv3_decoder_cb.decode_buf[dec_buf_idx]), out_used);
+
+  return true;
+}
+
+void a2dp_vendor_lhdcv3_decoder_start(void) {
+  LOG_INFO(LOG_TAG, "%s", __func__);
+  // do nothing
+}
+
+void a2dp_vendor_lhdcv3_decoder_suspend(void) {
+  LOG_INFO(LOG_TAG, "%s", __func__);
+  // do nothing
+}
+
+void a2dp_vendor_lhdcv3_decoder_configure(const uint8_t* p_codec_info) {
+  //int32_t sample_rate;
+  //int32_t bits_per_sample;
+  //int32_t channel_mode;
+
+  if (p_codec_info == NULL) {
+    LOG_ERROR(LOG_TAG, "%s: p_codec_info is NULL", __func__);
+    return;
+  }
+
+  LOG_ERROR(LOG_TAG, "%s", __func__);
+}
diff --git a/system/bt/stack/a2dp/a2dp_vendor_lhdcv3_encoder.cc b/system/bt/stack/a2dp/a2dp_vendor_lhdcv3_encoder.cc
new file mode 100755
index 00000000..b1a9b945
--- /dev/null
+++ b/system/bt/stack/a2dp/a2dp_vendor_lhdcv3_encoder.cc
@@ -0,0 +1,1035 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "a2dp_vendor_lhdcv3_encoder"
+#define ATRACE_TAG ATRACE_TAG_AUDIO
+
+#include "a2dp_vendor_lhdcv3_encoder.h"
+
+#ifndef OS_GENERIC
+#include <cutils/trace.h>
+#endif
+#include <dlfcn.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <lhdcBT.h>
+
+#include "a2dp_vendor.h"
+#include "a2dp_vendor_lhdcv3.h"
+#include "bt_common.h"
+#include "common/time_util.h"
+#include "osi/include/log.h"
+#include "osi/include/osi.h"
+
+//
+// Encoder for LHDC Source Codec
+//
+
+//
+// The LHDC encoder shared library, and the functions to use
+//
+static const char* LHDC_ENCODER_LIB_NAME = "liblhdcBT_enc.so";
+static void* lhdc_encoder_lib_handle = NULL;
+
+static const char* LHDC_GET_HANDLE_NAME = "lhdcBT_get_handle";
+typedef HANDLE_LHDC_BT (*tLHDC_GET_HANDLE)(int version);
+
+static const char* LHDC_FREE_HANDLE_NAME = "lhdcBT_free_handle";
+typedef void (*tLHDC_FREE_HANDLE)(HANDLE_LHDC_BT hLhdcParam);
+
+static const char* LHDC_GET_BITRATE_NAME = "lhdcBT_get_bitrate";
+typedef int (*tLHDC_GET_BITRATE)(HANDLE_LHDC_BT hLhdcParam);
+static const char* LHDC_SET_BITRATE_NAME = "lhdcBT_set_bitrate";
+typedef int (*tLHDC_SET_BITRATE)(HANDLE_LHDC_BT hLhdcParam, int index);
+
+static const char* LHDC_INIT_ENCODER_NAME = "lhdcBT_init_encoder";
+typedef int (*tLHDC_INIT_ENCODER)(HANDLE_LHDC_BT hLhdcParam,int sampling_freq, int bitPerSample, int bitrate_inx, int dualChannels, int need_padding, int mtu_size, int interval);
+
+static const char* LHDC_AUTO_ADJUST_BITRATE_NAME = "lhdcBT_adjust_bitrate";
+typedef int (*tLHDC_AUTO_ADJUST_BITRATE)(HANDLE_LHDC_BT hLhdcParam, size_t queueLength);
+
+
+static const char* LHDC_ENCODE_NAME = "lhdcBT_encodeV3";
+typedef int (*tLHDC_ENCODE)(HANDLE_LHDC_BT hLhdcParam, void* p_pcm, unsigned char* out_put, uint32_t * written, uint32_t * out_fraems);
+
+static const char* LHDC_SET_LIMIT_BITRATE_ENABLED_NAME = "lhdcBT_set_max_bitrate";
+typedef void (*tLHDC_SET_LIMIT_BITRATE_ENABLED)(HANDLE_LHDC_BT hLhdcParam, int max_rate_index);
+
+static const char* LHDC_GET_BLOCK_SIZE = "lhdcBT_get_block_Size";
+typedef int (*tLHDC_GET_BLOCK_SIZE)(HANDLE_LHDC_BT hLhdcParam);
+
+
+static const char* LHDC_SET_EXT_FUNC = "lhdcBT_set_ext_func_state";
+typedef int (*tLHDC_SET_EXT_FUNC)(HANDLE_LHDC_BT handle, lhdcBT_ext_func_field_t field, bool enabled, void * priv, int priv_data_len);
+
+
+static const char* LHDC_SET_MBR_FUNC = "lhdcBT_set_hasMinBitrateLimit";
+typedef int (*tLHDC_SET_MBR_FUNC)(HANDLE_LHDC_BT handle, bool enabled);
+//int lhdcBT_set_hasMinBitrateLimit(HANDLE_LHDC_BT handle, bool enabled )
+//int lhdcBT_set_ext_func_state(HANDLE_LHDC_BT handle, lhdcBT_ext_func_field_t field, bool enabled, void * priv, int priv_data_len)
+/*leo set_gyro_pos */
+//static const char* LHDC_SET_GYRO_POS_NAME = "lhdcBT_set_gyro_pos";
+//typedef int (*tLHDC_SET_GYRO_POS)(HANDLE_LHDC_BT hLhdcParam, uint32_t world_coordinate_x, uint32_t world_coordinate_y, uint32_t world_coordinate_z);
+
+/**************************************/
+/*   LHDC extend function API Lib     */
+/**************************************/
+static const char* LHDC_GET_USER_EXAPIVER_NAME = "lhdcBT_get_user_exApiver";
+typedef int (*tLHDC_GET_USER_EXAPIVER)(HANDLE_LHDC_BT hLhdcParam, const char* userConfig, const int clen);
+
+static const char* LHDC_GET_USER_EXCONFIG_NAME = "lhdcBT_get_user_exconfig";
+typedef int (*tLHDC_GET_USER_EXCONFIG)(HANDLE_LHDC_BT hLhdcParam, const char* userConfig, const int clen);
+
+static const char* LHDC_SET_USER_EXCONFIG_NAME = "lhdcBT_set_user_exconfig";
+typedef int (*tLHDC_SET_USER_EXCONFIG)(HANDLE_LHDC_BT hLhdcParam, const char* userConfig, const int clen);
+
+static const char* LHDC_SET_USER_EXDATA_NAME = "lhdcBT_set_user_exdata";
+typedef void (*tLHDC_SET_USER_EXDATA)(HANDLE_LHDC_BT hLhdcParam, const char* userConfig, const int clen);
+
+static tLHDC_GET_HANDLE lhdc_get_handle;
+static tLHDC_FREE_HANDLE lhdc_free_handle;
+static tLHDC_GET_BITRATE lhdc_get_bitrate;
+static tLHDC_SET_BITRATE lhdc_set_bitrate;
+static tLHDC_INIT_ENCODER lhdc_init_encoder;
+static tLHDC_ENCODE lhdc_encode_func;
+static tLHDC_AUTO_ADJUST_BITRATE lhdc_auto_adjust_bitrate;
+static tLHDC_SET_LIMIT_BITRATE_ENABLED lhdc_set_limit_bitrate;
+static tLHDC_GET_BLOCK_SIZE lhdc_get_block_size;
+static tLHDC_SET_EXT_FUNC lhdc_set_ext_func;
+static tLHDC_SET_MBR_FUNC lhdc_set_mbr_func;
+
+//static tLHDC_SET_GYRO_POS lhdc_set_gyro_pos_func;   /*leo set_gyro_pos */
+
+static tLHDC_GET_USER_EXAPIVER lhdcBT_get_user_exApiVer_func;
+static tLHDC_GET_USER_EXCONFIG lhdcBT_get_user_exconfig_func;
+static tLHDC_SET_USER_EXCONFIG lhdcBT_set_user_exconfig_func;
+static tLHDC_SET_USER_EXDATA lhdcBT_set_user_exdata_func;
+
+// A2DP LHDC encoder interval in milliseconds
+#define A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS 10
+#define A2DP_LHDC_ENCODER_INTERVAL_MS 20
+
+// offset
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+#define A2DP_LHDC_OFFSET (AVDT_MEDIA_OFFSET + A2DP_LHDC_MPL_HDR_LEN + 1)
+#else
+#define A2DP_LHDC_OFFSET (AVDT_MEDIA_OFFSET + A2DP_LHDC_MPL_HDR_LEN)
+#endif
+
+//#define A2DP_LHDC_OFFSET (AVDT_MEDIA_OFFSET + 0)
+
+typedef struct {
+  uint32_t sample_rate;
+  uint8_t channel_mode;
+  uint8_t bits_per_sample;
+  int quality_mode_index;
+  //int latency_mode_index;
+  int pcm_wlength;
+  LHDCBT_SMPL_FMT_T pcm_fmt;
+  int8_t channelSplitMode;
+  int8_t maxTargetBitrate;
+  bool isLLEnabled;
+} tA2DP_LHDC_ENCODER_PARAMS;
+
+typedef struct {
+  uint32_t counter;
+  uint32_t bytes_per_tick; /* pcm bytes read each media task tick */
+  uint64_t last_frame_us;
+} tA2DP_LHDC_FEEDING_STATE;
+
+typedef struct {
+  uint64_t session_start_us;
+
+  size_t media_read_total_expected_packets;
+  size_t media_read_total_expected_reads_count;
+  size_t media_read_total_expected_read_bytes;
+
+  size_t media_read_total_dropped_packets;
+  size_t media_read_total_actual_reads_count;
+  size_t media_read_total_actual_read_bytes;
+} a2dp_lhdc_encoder_stats_t;
+
+typedef struct {
+  a2dp_source_read_callback_t read_callback;
+  a2dp_source_enqueue_callback_t enqueue_callback;
+  uint16_t TxAaMtuSize;
+  size_t TxQueueLength;
+
+  bool use_SCMS_T;
+  bool is_peer_edr;          // True if the peer device supports EDR
+  bool peer_supports_3mbps;  // True if the peer device supports 3Mbps EDR
+  uint16_t peer_mtu;         // MTU of the A2DP peer
+  uint32_t timestamp;        // Timestamp for the A2DP frames
+
+  HANDLE_LHDC_BT lhdc_handle;
+  bool has_lhdc_handle;  // True if lhdc_handle is valid
+  uint8_t version;
+
+  tA2DP_FEEDING_PARAMS feeding_params;
+  tA2DP_LHDC_ENCODER_PARAMS lhdc_encoder_params;
+  tA2DP_LHDC_FEEDING_STATE lhdc_feeding_state;
+
+  a2dp_lhdc_encoder_stats_t stats;
+  uint32_t buf_seq;
+  uint32_t bytes_read;
+} tA2DP_LHDC_ENCODER_CB;
+
+//static bool lhdc_abr_loaded = false;
+
+
+
+typedef struct _lhdc_frame_Info {
+    uint32_t frame_len;
+    uint32_t isSplit;
+    uint32_t isLeft;
+
+} lhdc_frame_Info_t;
+
+
+#define _RECODER_FILE_
+#if defined(_RECODER_FILE_)
+#define ENCODED_FILE_NAME "/sdcard/Download/lhdc.raw"
+#define PCM_FILE_NAME     "/sdcard/Download/source.pcm"
+static FILE  *RecFile = NULL;
+static FILE *pcmFile = NULL;
+#endif
+
+static tA2DP_LHDC_ENCODER_CB a2dp_lhdc_encoder_cb;
+
+static void a2dp_vendor_lhdcv3_encoder_update(uint16_t peer_mtu,
+                                            A2dpCodecConfig* a2dp_codec_config,
+                                            bool* p_restart_input,
+                                            bool* p_restart_output,
+                                            bool* p_config_updated);
+static void a2dp_lhdcv3_get_num_frame_iteration(uint8_t* num_of_iterations,
+                                              uint8_t* num_of_frames,
+                                              uint64_t timestamp_us);
+
+static void a2dp_lhdcV3_encode_frames(uint8_t nb_frame);
+static bool a2dp_lhdcv3_read_feeding(uint8_t* read_buffer, uint32_t *bytes_read);
+static std::string quality_mode_index_to_name(int quality_mode_index);
+//static std::string latency_mode_index_to_name(int latency_mode_index);
+
+static void* load_func(const char* func_name) {
+  void* func_ptr = dlsym(lhdc_encoder_lib_handle, func_name);
+  if (func_ptr == NULL) {
+    LOG_ERROR(LOG_TAG,
+              "%s: cannot find function '%s' in the encoder library: %s",
+              __func__, func_name, dlerror());
+    A2DP_VendorUnloadEncoderLhdcV3();
+    return NULL;
+  }
+  return func_ptr;
+}
+
+bool A2DP_VendorLoadEncoderLhdcV3(void) {
+  if (lhdc_encoder_lib_handle != NULL) return true;  // Already loaded
+
+  // Initialize the control block
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+
+  // Open the encoder library
+  lhdc_encoder_lib_handle = dlopen(LHDC_ENCODER_LIB_NAME, RTLD_NOW);
+  if (lhdc_encoder_lib_handle == NULL) {
+    LOG_ERROR(LOG_TAG, "%s: cannot open LHDC encoder library %s: %s", __func__,
+              LHDC_ENCODER_LIB_NAME, dlerror());
+    return false;
+  }
+
+
+  // Load all functions
+  lhdc_get_handle = (tLHDC_GET_HANDLE)load_func(LHDC_GET_HANDLE_NAME);
+  if (lhdc_get_handle == NULL) return false;
+  lhdc_free_handle = (tLHDC_FREE_HANDLE)load_func(LHDC_FREE_HANDLE_NAME);
+  if (lhdc_free_handle == NULL) return false;
+  lhdc_get_bitrate = (tLHDC_GET_BITRATE)load_func(LHDC_GET_BITRATE_NAME);
+  if (lhdc_get_bitrate == NULL) return false;
+  lhdc_set_bitrate = (tLHDC_SET_BITRATE)load_func(LHDC_SET_BITRATE_NAME);
+  if (lhdc_set_bitrate == NULL) return false;
+  lhdc_init_encoder = (tLHDC_INIT_ENCODER)load_func(LHDC_INIT_ENCODER_NAME);
+  if (lhdc_init_encoder == NULL) return false;
+  lhdc_encode_func = (tLHDC_ENCODE)load_func(LHDC_ENCODE_NAME);
+  if (lhdc_encode_func == NULL) return false;
+  lhdc_auto_adjust_bitrate = (tLHDC_AUTO_ADJUST_BITRATE)load_func(LHDC_AUTO_ADJUST_BITRATE_NAME);
+  if (lhdc_auto_adjust_bitrate == NULL) return false;
+
+
+  lhdc_set_limit_bitrate = (tLHDC_SET_LIMIT_BITRATE_ENABLED)load_func(LHDC_SET_LIMIT_BITRATE_ENABLED_NAME);
+  if (lhdc_set_limit_bitrate == NULL) return false;
+  lhdc_get_block_size = (tLHDC_GET_BLOCK_SIZE)load_func(LHDC_GET_BLOCK_SIZE);
+  if (lhdc_get_block_size == NULL) return false;
+  lhdc_set_ext_func = (tLHDC_SET_EXT_FUNC)load_func(LHDC_SET_EXT_FUNC);
+  if (lhdc_set_ext_func == NULL) return false;
+  lhdc_set_mbr_func = (tLHDC_SET_MBR_FUNC)load_func(LHDC_SET_MBR_FUNC);
+  if (lhdc_set_mbr_func == NULL) return false;
+
+  /*leo set_gyro_pos */
+//  lhdc_set_gyro_pos_func = (tLHDC_SET_GYRO_POS)load_func(LHDC_SET_GYRO_POS_NAME);
+//  if (lhdc_set_gyro_pos_func == NULL) return false;
+
+  lhdcBT_get_user_exApiVer_func = (tLHDC_GET_USER_EXAPIVER)load_func(LHDC_GET_USER_EXAPIVER_NAME);
+  if (lhdcBT_get_user_exApiVer_func == NULL) {
+      LOG_ERROR(LOG_TAG, "%s:cannot load %s", __func__, LHDC_GET_USER_EXAPIVER_NAME);
+      return false;
+  }
+
+  lhdcBT_get_user_exconfig_func = (tLHDC_GET_USER_EXCONFIG)load_func(LHDC_GET_USER_EXCONFIG_NAME);
+  if (lhdcBT_get_user_exconfig_func == NULL) {
+    LOG_ERROR(LOG_TAG, "%s:cannot load %s", __func__, LHDC_GET_USER_EXCONFIG_NAME);
+    return false;
+  }
+
+  lhdcBT_set_user_exconfig_func = (tLHDC_SET_USER_EXCONFIG)load_func(LHDC_SET_USER_EXCONFIG_NAME);
+  if (lhdcBT_set_user_exconfig_func == NULL)  {
+    LOG_ERROR(LOG_TAG, "%s:cannot load %s", __func__, LHDC_SET_USER_EXCONFIG_NAME);
+    return false;
+  }
+
+  lhdcBT_set_user_exdata_func = (tLHDC_SET_USER_EXDATA)load_func(LHDC_SET_USER_EXDATA_NAME);
+  if (lhdcBT_set_user_exdata_func == NULL)  {
+    LOG_ERROR(LOG_TAG, "%s:cannot load %s", __func__, LHDC_SET_USER_EXDATA_NAME);
+    return false;
+  }
+
+  return true;
+}
+
+void A2DP_VendorUnloadEncoderLhdcV3(void) {
+  // Cleanup any LHDC-related state
+
+    LOG_DEBUG(LOG_TAG, "%s: a2dp_lhdc_encoder_cb.has_lhdc_handle = %d, lhdc_free_handle = %p",
+              __func__, a2dp_lhdc_encoder_cb.has_lhdc_handle, lhdc_free_handle);
+  if (a2dp_lhdc_encoder_cb.has_lhdc_handle && lhdc_free_handle != NULL)
+    lhdc_free_handle(a2dp_lhdc_encoder_cb.lhdc_handle);
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+
+  lhdc_get_handle = NULL;
+  lhdc_free_handle = NULL;
+  lhdc_get_bitrate = NULL;
+  lhdc_set_bitrate = NULL;
+  lhdc_init_encoder = NULL;
+  lhdc_encode_func = NULL;
+  lhdc_auto_adjust_bitrate = NULL;
+  lhdc_set_limit_bitrate = NULL;
+  lhdc_get_block_size = NULL;
+  lhdc_set_ext_func = NULL;
+  lhdc_set_mbr_func = NULL;
+//  lhdc_set_gyro_pos_func = NULL;    /*leo set_gyro_pos */
+
+  lhdcBT_get_user_exApiVer_func = NULL;
+  lhdcBT_get_user_exconfig_func = NULL;
+  lhdcBT_set_user_exconfig_func = NULL;
+  lhdcBT_set_user_exdata_func = NULL;
+
+
+  if (lhdc_encoder_lib_handle != NULL) {
+    dlclose(lhdc_encoder_lib_handle);
+    lhdc_encoder_lib_handle = NULL;
+  }
+}
+
+void a2dp_vendor_lhdcv3_encoder_init(
+    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+    A2dpCodecConfig* a2dp_codec_config,
+    a2dp_source_read_callback_t read_callback,
+    a2dp_source_enqueue_callback_t enqueue_callback) {
+  if (a2dp_lhdc_encoder_cb.has_lhdc_handle)
+    lhdc_free_handle(a2dp_lhdc_encoder_cb.lhdc_handle);
+
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+
+  a2dp_lhdc_encoder_cb.stats.session_start_us = bluetooth::common::time_get_os_boottime_us();
+
+  a2dp_lhdc_encoder_cb.read_callback = read_callback;
+  a2dp_lhdc_encoder_cb.enqueue_callback = enqueue_callback;
+  a2dp_lhdc_encoder_cb.is_peer_edr = p_peer_params->is_peer_edr;
+  a2dp_lhdc_encoder_cb.peer_supports_3mbps = p_peer_params->peer_supports_3mbps;
+  a2dp_lhdc_encoder_cb.peer_mtu = p_peer_params->peer_mtu;
+  a2dp_lhdc_encoder_cb.timestamp = 0;
+
+
+  a2dp_lhdc_encoder_cb.use_SCMS_T = false;  // TODO: should be a parameter
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+  a2dp_lhdc_encoder_cb.use_SCMS_T = true;
+#endif
+
+  // NOTE: Ignore the restart_input / restart_output flags - this initization
+  // happens when the connection is (re)started.
+  bool restart_input = false;
+  bool restart_output = false;
+  bool config_updated = false;
+  a2dp_vendor_lhdcv3_encoder_update(a2dp_lhdc_encoder_cb.peer_mtu,
+                                  a2dp_codec_config, &restart_input,
+                                  &restart_output, &config_updated);
+}
+
+
+int A2dpCodecConfigLhdcV3::getEncoderExtendFuncUserApiVer(const char* version, const int clen)
+{
+  if(lhdcBT_get_user_exApiVer_func)
+  {
+    //LOG_DEBUG(LOG_TAG, "%s: get API VERSION, clen:%d", __func__, clen);
+    return lhdcBT_get_user_exApiVer_func(a2dp_lhdc_encoder_cb.lhdc_handle, version, clen);
+  }
+  else
+  {
+    LOG_DEBUG(LOG_TAG, "%s: lib func not found", __func__);
+    return BT_STATUS_FAIL;
+  }
+}
+
+int A2dpCodecConfigLhdcV3::getEncoderExtendFuncUserConfig(const char* userConfig, const int clen)
+{
+  if(lhdcBT_get_user_exconfig_func)
+  {
+    //LOG_DEBUG(LOG_TAG, "%s: get API CONFIG, clen:%d", __func__, clen);
+    return lhdcBT_get_user_exconfig_func(a2dp_lhdc_encoder_cb.lhdc_handle, userConfig, clen);
+  }
+  else
+  {
+    LOG_DEBUG(LOG_TAG, "%s: lib func not found", __func__);
+    return BT_STATUS_FAIL;
+  }
+}
+
+int A2dpCodecConfigLhdcV3::setEncoderExtendFuncUserConfig(const char* userConfig, const int clen)
+{
+  if(lhdcBT_set_user_exconfig_func)
+  {
+    //LOG_DEBUG(LOG_TAG, "%s: set API CONFIG, clen:%d", __func__, clen);
+    return lhdcBT_set_user_exconfig_func(a2dp_lhdc_encoder_cb.lhdc_handle, userConfig, clen);
+  }
+  else
+  {
+    LOG_DEBUG(LOG_TAG, "%s: lib func not found", __func__);
+    return BT_STATUS_FAIL;
+  }
+}
+
+bool A2dpCodecConfigLhdcV3::setEncoderExtendFuncUserData(const char* codecData, const int clen)
+{
+  if(lhdcBT_set_user_exdata_func)
+  {
+    //LOG_DEBUG(LOG_TAG, "%s: set API DATA, clen:%d", __func__, clen);
+    lhdcBT_set_user_exdata_func(a2dp_lhdc_encoder_cb.lhdc_handle, codecData, clen);
+    return true;
+  }
+  else
+  {
+    LOG_DEBUG(LOG_TAG, "%s: lib func not found", __func__);
+    return false;
+  }
+}
+
+
+bool A2dpCodecConfigLhdcV3::updateEncoderUserConfig(
+    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params, bool* p_restart_input,
+    bool* p_restart_output, bool* p_config_updated) {
+  a2dp_lhdc_encoder_cb.is_peer_edr = p_peer_params->is_peer_edr;
+  a2dp_lhdc_encoder_cb.peer_supports_3mbps = p_peer_params->peer_supports_3mbps;
+  a2dp_lhdc_encoder_cb.peer_mtu = p_peer_params->peer_mtu;
+  a2dp_lhdc_encoder_cb.timestamp = 0;
+
+  if (a2dp_lhdc_encoder_cb.peer_mtu == 0) {
+    LOG_ERROR(LOG_TAG,
+              "%s: Cannot update the codec encoder for %s: "
+              "invalid peer MTU",
+              __func__, name().c_str());
+    return false;
+  }
+
+  a2dp_vendor_lhdcv3_encoder_update(a2dp_lhdc_encoder_cb.peer_mtu, this,
+                                  p_restart_input, p_restart_output,
+                                  p_config_updated);
+  return true;
+}
+
+// Update the A2DP LHDC encoder.
+// |peer_mtu| is the peer MTU.
+// |a2dp_codec_config| is the A2DP codec to use for the update.
+static void a2dp_vendor_lhdcv3_encoder_update(uint16_t peer_mtu,
+                                            A2dpCodecConfig* a2dp_codec_config,
+                                            bool* p_restart_input,
+                                            bool* p_restart_output,
+                                            bool* p_config_updated) {
+  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params =
+      &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+  uint8_t codec_info[AVDT_CODEC_SIZE];
+
+  *p_restart_input = false;
+  *p_restart_output = false;
+  *p_config_updated = false;
+
+  //Example for limit bit rate
+  //lhdc_set_limit_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, 0);
+
+
+  if (!a2dp_codec_config->copyOutOtaCodecConfig(codec_info)) {
+    LOG_ERROR(LOG_TAG,
+              "%s: Cannot update the codec encoder for %s: "
+              "invalid codec config",
+              __func__, a2dp_codec_config->name().c_str());
+    return;
+  }
+  const uint8_t* p_codec_info = codec_info;
+  btav_a2dp_codec_config_t codec_config = a2dp_codec_config->getCodecConfig();
+  //btav_a2dp_codec_config_t codec_config_user = a2dp_codec_config->getCodecUserConfig();
+
+  uint32_t verCode = A2DP_VendorGetVersionLhdcV3(p_codec_info);  //LHDC V3 should 1!
+
+  bool isLLAC = A2DP_VendorHasLLACFlagLhdcV3(p_codec_info);
+
+  bool isLHDCV4 = A2DP_VendorHasV4FlagLhdcV3(p_codec_info);
+
+
+  LOG_DEBUG(LOG_TAG, "%s:codec_config.codec_specific_1 = %d, codec_config.codec_specific_2 = %d", __func__, (int32_t)codec_config.codec_specific_1, (int32_t)codec_config.codec_specific_2);
+  if ((codec_config.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) == A2DP_LHDC_QUALITY_MAGIC_NUM) {
+      int newValue = codec_config.codec_specific_1 & 0xff;
+
+      // adjust non-supported quality modes and wrap to internal library used index
+      if (newValue == A2DP_LHDC_QUALITY_ABR) {
+        newValue = LHDCBT_QUALITY_AUTO; //9->8
+      }
+
+      if (newValue != p_encoder_params->quality_mode_index) {
+        p_encoder_params->quality_mode_index = newValue;
+        LOG_DEBUG(LOG_TAG, "%s: setting internal quality mode index: %s(%d)", __func__,
+                  quality_mode_index_to_name(p_encoder_params->quality_mode_index)
+                      .c_str(), p_encoder_params->quality_mode_index);
+      }
+  }else {
+      p_encoder_params->quality_mode_index = LHDCBT_QUALITY_AUTO;
+      LOG_DEBUG(LOG_TAG, "%s: setting default quality mode to ABR", __func__);
+  }
+
+  if (!a2dp_lhdc_encoder_cb.has_lhdc_handle) {
+      uint32_t versionSetup = 2;
+      if(isLLAC && !isLHDCV4 && verCode == 1){
+        //LLAC Only
+        versionSetup = 4;
+        LOG_DEBUG(LOG_TAG, "%s: init to LLAC : %d",__func__, versionSetup);
+      }else if(!isLLAC && isLHDCV4 && verCode == 1) {
+        //LHDCV4 Only
+        versionSetup = 3;
+        LOG_DEBUG(LOG_TAG, "%s: init to LHDC V4 : %d",__func__, versionSetup);
+      }else if(!isLLAC && !isLHDCV4 && verCode == 1) {
+        //LHDCV3 Only
+        versionSetup = 2;
+        LOG_DEBUG(LOG_TAG, "%s: init to LHDC V3 : %d",__func__, versionSetup);
+      }else {
+        LOG_DEBUG(LOG_TAG, "%s: Flags check incorrect. So init to LHDCV3 only : %d",__func__, versionSetup);
+      }
+
+
+      a2dp_lhdc_encoder_cb.lhdc_handle = lhdc_get_handle(versionSetup);
+      if (a2dp_lhdc_encoder_cb.lhdc_handle == NULL) {
+        LOG_ERROR(LOG_TAG, "%s: Cannot get LHDC encoder handle", __func__);
+        return;  // TODO: Return an error?
+      }
+      a2dp_lhdc_encoder_cb.has_lhdc_handle = true;
+  }
+  a2dp_lhdc_encoder_cb.version = A2DP_VendorGetVersionLhdcV3(p_codec_info);
+
+
+  // The feeding parameters
+  tA2DP_FEEDING_PARAMS* p_feeding_params = &a2dp_lhdc_encoder_cb.feeding_params;
+  p_feeding_params->sample_rate =
+      A2DP_VendorGetTrackSampleRateLhdcV3(p_codec_info);
+  p_feeding_params->bits_per_sample =
+      a2dp_codec_config->getAudioBitsPerSample();
+  p_feeding_params->channel_count =
+      A2DP_VendorGetTrackChannelCountLhdcV3(p_codec_info);
+  LOG_DEBUG(LOG_TAG, "%s:(feeding) sample_rate=%u bits_per_sample=%u channel_count=%u",
+            __func__, p_feeding_params->sample_rate,
+            p_feeding_params->bits_per_sample, p_feeding_params->channel_count);
+
+  // The codec parameters
+  p_encoder_params->sample_rate =
+      a2dp_lhdc_encoder_cb.feeding_params.sample_rate;
+
+  uint16_t mtu_size =
+      BT_DEFAULT_BUFFER_SIZE - A2DP_LHDC_OFFSET - sizeof(BT_HDR);
+
+  a2dp_lhdc_encoder_cb.TxAaMtuSize = (mtu_size < peer_mtu) ? mtu_size : peer_mtu;
+
+  //get separation feature.
+  p_encoder_params->channelSplitMode = A2DP_VendorGetChannelSplitModeLhdcV3(p_codec_info);
+  // Set the quality mode index
+  //int old_quality_mode_index = p_encoder_params->quality_mode_index;
+
+  p_encoder_params->maxTargetBitrate = A2DP_VendorGetMaxDatarateLhdcV3(p_codec_info);
+
+
+  p_encoder_params->isLLEnabled = (codec_config.codec_specific_2 & 1ULL) != 0 ? true :false; //A2DP_VendorGetLowLatencyState(p_codec_info);
+
+
+  p_encoder_params->pcm_wlength =
+      a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample >> 3;
+  // Set the Audio format from pcm_wlength
+  p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S16;
+  if (p_encoder_params->pcm_wlength == 2)
+    p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S16;
+  else if (p_encoder_params->pcm_wlength == 3)
+    p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S24;
+ // else if (p_encoder_params->pcm_wlength == 4)
+//    p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S32;
+
+  LOG_DEBUG(LOG_TAG, "%s: MTU=%d, peer_mtu=%d", __func__,
+            a2dp_lhdc_encoder_cb.TxAaMtuSize, peer_mtu);
+  LOG_DEBUG(LOG_TAG,
+            "%s: sample_rate: %d "
+            "quality_mode_index: %d pcm_wlength: %d pcm_fmt: %d",
+            __func__, p_encoder_params->sample_rate,
+            p_encoder_params->quality_mode_index, p_encoder_params->pcm_wlength,
+            p_encoder_params->pcm_fmt);
+
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN - 1);
+#else
+    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN);
+#endif
+  
+  LOG_DEBUG(LOG_TAG, "%s:AR Flag = %d", __func__, A2DP_VendorHasARFlagLhdcV3(p_codec_info));
+  lhdc_set_ext_func(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCBT_EXT_FUNC_AR, A2DP_VendorHasARFlagLhdcV3(p_codec_info), NULL, 0);
+  lhdc_set_ext_func(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCBT_EXT_FUNC_JAS, A2DP_VendorHasJASFlagLhdcV3(p_codec_info), NULL, 0);
+  lhdc_set_ext_func(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCBT_EXT_FUNC_LARC, A2DP_VendorHasLARCFlagLhdcV3(p_codec_info), NULL, 0);
+  lhdc_set_mbr_func(a2dp_lhdc_encoder_cb.lhdc_handle, A2DP_VendorHasMinBRFlagLhdcV3(p_codec_info));
+  // Initialize the encoder.
+  // NOTE: MTU in the initialization must include the AVDT media header size.
+  int result = lhdc_init_encoder(
+      a2dp_lhdc_encoder_cb.lhdc_handle,
+      p_encoder_params->sample_rate,
+      p_encoder_params->pcm_fmt,
+      p_encoder_params->quality_mode_index,
+      p_encoder_params->channelSplitMode > A2DP_LHDC_CH_SPLIT_NONE ? 1 : 0,
+      0 /* This parameter alaways is 0 in A2DP */ ,
+      max_mtu_len,
+      a2dp_vendor_lhdcv3_get_encoder_interval_ms()
+  );
+  lhdc_set_limit_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, p_encoder_params->maxTargetBitrate);
+
+  lhdc_set_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, p_encoder_params->quality_mode_index);
+
+#if defined(_RECODER_FILE_)
+  if (RecFile == NULL) {
+    RecFile = fopen(ENCODED_FILE_NAME,"wb");
+    LOG_DEBUG(LOG_TAG, "%s: Create recode file = %p", __func__, RecFile);
+  }
+  if (pcmFile == NULL) {
+    pcmFile = fopen(PCM_FILE_NAME,"wb");
+    LOG_DEBUG(LOG_TAG, "%s: Create recode file = %p", __func__, pcmFile);
+  }
+#endif
+  if (result != 0) {
+    LOG_ERROR(LOG_TAG, "%s: error initializing the LHDC encoder: %d", __func__,
+              result);
+  }
+}
+
+void a2dp_vendor_lhdcv3_encoder_cleanup(void) {
+  if (a2dp_lhdc_encoder_cb.has_lhdc_handle)
+    lhdc_free_handle(a2dp_lhdc_encoder_cb.lhdc_handle);
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+#if defined(_RECODER_FILE_)
+  if (RecFile != NULL) {
+    fclose(RecFile);
+    RecFile = NULL;
+    remove(ENCODED_FILE_NAME);
+  }
+  if (pcmFile != NULL) {
+    fclose(pcmFile);
+    pcmFile = NULL;
+    remove(PCM_FILE_NAME);
+  }
+#endif
+}
+
+void a2dp_vendor_lhdcv3_feeding_reset(void) {
+  /* By default, just clear the entire state */
+  memset(&a2dp_lhdc_encoder_cb.lhdc_feeding_state, 0,
+         sizeof(a2dp_lhdc_encoder_cb.lhdc_feeding_state));
+
+  int encoder_interval = a2dp_vendor_lhdcv3_get_encoder_interval_ms();
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick =
+      (a2dp_lhdc_encoder_cb.feeding_params.sample_rate *
+       a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8 *
+       a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+       encoder_interval) /
+      1000;
+  a2dp_lhdc_encoder_cb.buf_seq = 0;
+  a2dp_lhdc_encoder_cb.bytes_read = 0;
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us = 0;
+  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params = &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+  if (p_encoder_params->quality_mode_index == LHDCBT_QUALITY_AUTO) {
+    if(lhdc_set_bitrate != NULL && a2dp_lhdc_encoder_cb.has_lhdc_handle) {
+      LOG_DEBUG(LOG_TAG, "%s: reset ABR!", __func__);
+      lhdc_set_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCBT_QUALITY_RESET_AUTO);
+    }
+  }
+  LOG_DEBUG(LOG_TAG, "%s: PCM bytes per tick %u, reset timestamp", __func__,
+            a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick);
+}
+
+void a2dp_vendor_lhdcv3_feeding_flush(void) {
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter = 0;
+  LOG_DEBUG(LOG_TAG, "%s", __func__);
+}
+
+uint64_t a2dp_vendor_lhdcv3_get_encoder_interval_ms(void) {
+  LOG_DEBUG(LOG_TAG, "%s: A2DP_LHDC_ENCODER_INTERVAL_MS %u",
+              __func__, a2dp_lhdc_encoder_cb.lhdc_encoder_params.isLLEnabled ? A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS : A2DP_LHDC_ENCODER_INTERVAL_MS);
+  if (a2dp_lhdc_encoder_cb.lhdc_encoder_params.isLLEnabled){
+      return A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS;
+  }else{
+      return A2DP_LHDC_ENCODER_INTERVAL_MS;
+  }
+}
+
+void a2dp_vendor_lhdcv3_send_frames(uint64_t timestamp_us) {
+  uint8_t nb_frame = 0;
+  uint8_t nb_iterations = 0;
+
+  a2dp_lhdcv3_get_num_frame_iteration(&nb_iterations, &nb_frame, timestamp_us);
+  LOG_DEBUG(LOG_TAG, "%s: Sending %d frames per iteration, %d iterations",
+              __func__, nb_frame, nb_iterations);
+
+  if (nb_frame == 0) return;
+
+  for (uint8_t counter = 0; counter < nb_iterations; counter++) {
+    // Transcode frame and enqueue
+    a2dp_lhdcV3_encode_frames(nb_frame);
+  }
+}
+
+// Obtains the number of frames to send and number of iterations
+// to be used. |num_of_iterations| and |num_of_frames| parameters
+// are used as output param for returning the respective values.
+static void a2dp_lhdcv3_get_num_frame_iteration(uint8_t* num_of_iterations,
+                                              uint8_t* num_of_frames,
+                                              uint64_t timestamp_us) {
+  uint32_t result = 0;
+  uint8_t nof = 0;
+  uint8_t noi = 1;
+
+  *num_of_iterations = 0;
+  *num_of_frames = 0;
+
+  int32_t pcm_bytes_per_frame = lhdc_get_block_size(a2dp_lhdc_encoder_cb.lhdc_handle);
+  if (pcm_bytes_per_frame <= 0) {
+    LOG_DEBUG(LOG_TAG, "%s: lhdc_get_block_size error!", __func__);
+    return;
+  }
+
+  pcm_bytes_per_frame = pcm_bytes_per_frame *
+  a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+  a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
+  LOG_DEBUG(LOG_TAG, "%s: pcm_bytes_per_frame %u", __func__, pcm_bytes_per_frame);
+
+  int encoder_interval = a2dp_vendor_lhdcv3_get_encoder_interval_ms();
+  uint32_t us_this_tick = encoder_interval * 1000;
+  uint64_t now_us = timestamp_us;
+  if (a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us != 0)
+    us_this_tick =
+        (now_us - a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us);
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us = now_us;
+
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter +=
+      a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick * us_this_tick /
+      (encoder_interval * 1000);
+
+  result =
+      a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter / pcm_bytes_per_frame;
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter -=
+      result * pcm_bytes_per_frame;
+  nof = result;
+
+  LOG_DEBUG(LOG_TAG, "%s: effective num of frames %u, iterations %u", __func__, nof, noi);
+
+  *num_of_frames = nof;
+  *num_of_iterations = noi;
+}
+
+static BT_HDR *bt_buf_new( void) {
+    BT_HDR *p_buf = ( BT_HDR*)osi_malloc( BT_DEFAULT_BUFFER_SIZE);
+    if ( p_buf == NULL) {
+        // LeoKu(C): should not happen
+        LOG_ERROR( LOG_TAG, "%s: bt_buf_new failed!", __func__);
+        return  NULL;
+    }
+
+    p_buf->offset = A2DP_LHDC_OFFSET;
+    p_buf->len = 0;
+    p_buf->layer_specific = 0;
+    return  p_buf;
+}
+
+static void a2dp_lhdcV3_encode_frames(uint8_t nb_frame){
+  //tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params =
+  //    &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+  int32_t samples_per_frame = lhdc_get_block_size(a2dp_lhdc_encoder_cb.lhdc_handle);
+  if (samples_per_frame <= 0) {
+    LOG_ERROR (LOG_TAG, "%s: lhdc_get_block_size error!", __func__);
+    return;
+  }
+
+  uint32_t pcm_bytes_per_frame = samples_per_frame *
+                                 a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+                                 a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
+
+
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+  uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN - 1);
+#else
+  uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN);
+#endif
+
+  static float mtu_usage = 0;
+  static int mtu_usage_cnt = 0;
+  static uint32_t time_prev = bluetooth::common::time_get_os_boottime_ms();
+  static uint32_t allSendbytes = 0;
+  uint8_t read_buffer[samples_per_frame * 2 * 4];
+  uint8_t latency =0; // p_encoder_params->latency_mode_index;
+  int32_t out_frames = 0, remain_nb_frame = nb_frame;
+  int32_t written = 0;
+  uint32_t bytes_read = 0;
+  uint8_t* packet;
+  BT_HDR * p_buf = NULL;
+
+  while (nb_frame) {
+      if ((p_buf = bt_buf_new()) == NULL) {
+          LOG_ERROR (LOG_TAG, "%s: ERROR", __func__);
+          return;
+      }
+    uint32_t written_frame = 0;
+    do {
+      uint32_t temp_bytes_read = 0;
+      if (a2dp_lhdcv3_read_feeding(read_buffer, &temp_bytes_read)) {
+        a2dp_lhdc_encoder_cb.bytes_read += temp_bytes_read;
+        packet = (uint8_t*)(p_buf + 1) + p_buf->offset + p_buf->len;
+
+        //int result =
+
+      #if defined(_RECODER_FILE_)
+        if (pcmFile != NULL) {
+          fwrite(read_buffer, sizeof(uint8_t), pcm_bytes_per_frame, pcmFile);
+        }
+      #endif
+        lhdc_encode_func(a2dp_lhdc_encoder_cb.lhdc_handle, read_buffer, packet, (uint32_t*)&written, (uint32_t*)&out_frames);
+
+        #if defined(_RECODER_FILE_)
+        if (RecFile != NULL && written > 0) {
+            fwrite(packet, sizeof(uint8_t), written, RecFile);
+        }
+        #endif
+
+        p_buf->len += written;
+        allSendbytes += written;
+        nb_frame--;
+        written_frame += out_frames;  // added a frame to the buffer
+        LOG_DEBUG (LOG_TAG, "%s: nb_frame:%d, written:%d, out_frames:%d", __func__, nb_frame, written, out_frames);
+
+      }else{
+    	LOG_DEBUG (LOG_TAG, "%s: underflow %d", __func__, nb_frame);
+        a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter +=
+                        nb_frame * samples_per_frame *
+                        a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+                        a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
+
+        // no more pcm to read
+        nb_frame = 0;
+      }
+    } while ((written == 0) && nb_frame);
+
+    if (p_buf->len) {
+      /*
+       * Timestamp of the media packet header represent the TS of the
+       * first frame, i.e the timestamp before including this frame.
+       */
+      p_buf->layer_specific = a2dp_lhdc_encoder_cb.buf_seq++;
+      p_buf->layer_specific <<= 8;
+      p_buf->layer_specific |= ( latency | ( written_frame << A2DP_LHDC_HDR_NUM_SHIFT));
+
+      *( ( uint32_t*)( p_buf + 1)) = a2dp_lhdc_encoder_cb.timestamp;
+      LOG_DEBUG (LOG_TAG, "%s: Timestamp (%d)", __func__, a2dp_lhdc_encoder_cb.timestamp);
+
+      a2dp_lhdc_encoder_cb.timestamp += ( written_frame * samples_per_frame);
+
+      uint8_t done_nb_frame = remain_nb_frame - nb_frame;
+      remain_nb_frame = nb_frame;
+      LOG_DEBUG(LOG_TAG, "%s: nb_frame:%d, remain_nb_frame:%d, done_nb_frame:%d", __func__, nb_frame, remain_nb_frame, done_nb_frame);
+
+      mtu_usage += ((float)p_buf->len) / max_mtu_len;
+      mtu_usage_cnt++;
+
+      LOG_DEBUG (LOG_TAG, "%s: Read bytes(%d)", __func__, a2dp_lhdc_encoder_cb.bytes_read);
+      LOG_DEBUG (LOG_TAG, "%s: Send Frame(%d), length(%d)", __func__, written_frame, p_buf->len);
+      bytes_read = a2dp_lhdc_encoder_cb.bytes_read;
+      a2dp_lhdc_encoder_cb.bytes_read = 0;
+
+      if (!a2dp_lhdc_encoder_cb.enqueue_callback(p_buf, 1, bytes_read))
+        return;
+    } else {
+      // NOTE: Unlike the execution path for other codecs, it is normal for
+      // LHDC to NOT write encoded data to the last buffer if there wasn't
+      // enough data to write to. That data is accumulated internally by
+      // the codec and included in the next iteration. Therefore, here we
+      // don't increment the "media_read_total_dropped_packets" counter.
+    	LOG_DEBUG (LOG_TAG, "%s: free buffer len(%d)", __func__, p_buf->len);
+      osi_free(p_buf);
+    }
+  }
+  uint32_t now_ms = bluetooth::common::time_get_os_boottime_ms();
+  if (now_ms - time_prev >= 1000 ) {
+	  LOG_DEBUG (LOG_TAG, "%s: Current data rate about %d kbps, packet usage %.2f%%", __func__, (allSendbytes * 8) / 1000, (mtu_usage * 100)/mtu_usage_cnt);
+      allSendbytes = 0;
+      mtu_usage_cnt = 0;
+      mtu_usage = 0;
+      time_prev = now_ms;
+  }
+}
+
+static bool a2dp_lhdcv3_read_feeding(uint8_t* read_buffer, uint32_t *bytes_read) {
+    uint32_t bytes_per_sample = a2dp_lhdc_encoder_cb.feeding_params.channel_count * a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
+  uint32_t read_size = 0;
+  int32_t read_size_tmp = lhdc_get_block_size(a2dp_lhdc_encoder_cb.lhdc_handle);
+  if (read_size_tmp <= 0) {
+    LOG_ERROR (LOG_TAG, "%s: lhdc_get_block_size error!", __func__);
+    return false;
+  }
+  read_size = read_size_tmp * bytes_per_sample;
+
+  a2dp_lhdc_encoder_cb.stats.media_read_total_expected_reads_count++;
+  a2dp_lhdc_encoder_cb.stats.media_read_total_expected_read_bytes += read_size;
+
+  /* Read Data from UIPC channel */
+  uint32_t nb_byte_read =
+      a2dp_lhdc_encoder_cb.read_callback(read_buffer, read_size);
+  LOG_DEBUG(LOG_TAG, "%s: want to read size %u, read byte number %u",
+                    __func__, read_size, nb_byte_read);
+  if ((nb_byte_read % bytes_per_sample) != 0) {
+	  LOG_DEBUG(LOG_TAG, "%s: PCM data not alignment. The audio sample is shfit %d bytes.", __func__,(nb_byte_read % bytes_per_sample));
+  }
+  a2dp_lhdc_encoder_cb.stats.media_read_total_actual_read_bytes += nb_byte_read;
+
+  if (nb_byte_read < read_size) {
+    if (nb_byte_read == 0) return false;
+
+    /* Fill the unfilled part of the read buffer with silence (0) */
+    memset(((uint8_t*)read_buffer) + nb_byte_read, 0, read_size - nb_byte_read);
+    nb_byte_read = read_size;
+  }
+  a2dp_lhdc_encoder_cb.stats.media_read_total_actual_reads_count++;
+
+    *bytes_read = nb_byte_read;
+
+  return true;
+}
+
+// library index mapping: quality mode index
+static std::string quality_mode_index_to_name(int quality_mode_index) {
+  switch (quality_mode_index) {
+    case LHDCBT_QUALITY_AUTO:
+      return "ABR";
+    case LHDCBT_QUALITY_HIGH:
+      return "HIGH";
+    case LHDCBT_QUALITY_MID:
+      return "MID";
+    case LHDCBT_QUALITY_LOW:
+      return "LOW";
+    case LHDCBT_QUALITY_LOW4:
+      return "LOW_320";
+    case LHDCBT_QUALITY_LOW3:
+      return "LOW_256";
+    case LHDCBT_QUALITY_LOW2:
+      return "LOW_192";
+    case LHDCBT_QUALITY_LOW1:
+      return "LOW_128";
+    case LHDCBT_QUALITY_LOW0:
+      return "LOW_64";
+    default:
+      return "Unknown";
+  }
+}
+
+void a2dp_vendor_lhdcv3_set_transmit_queue_length(size_t transmit_queue_length) {
+  a2dp_lhdc_encoder_cb.TxQueueLength = transmit_queue_length;
+  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params = &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+  LOG_DEBUG(LOG_TAG, "%s: transmit_queue_length %zu", __func__, transmit_queue_length);
+  if (p_encoder_params->quality_mode_index == LHDCBT_QUALITY_AUTO) {
+	  LOG_DEBUG(LOG_TAG, "%s: Auto Bitrate Enabled!", __func__);
+      if (lhdc_auto_adjust_bitrate != NULL) {
+          lhdc_auto_adjust_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, transmit_queue_length);
+      }
+  }
+}
+
+uint64_t A2dpCodecConfigLhdcV3::encoderIntervalMs() const {
+  return a2dp_vendor_lhdcv3_get_encoder_interval_ms();
+}
+
+int A2dpCodecConfigLhdcV3::getEffectiveMtu() const {
+  return a2dp_lhdc_encoder_cb.TxAaMtuSize;
+}
+
+void A2dpCodecConfigLhdcV3::debug_codec_dump(int fd) {
+  a2dp_lhdc_encoder_stats_t* stats = &a2dp_lhdc_encoder_cb.stats;
+  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params =
+      &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+
+  A2dpCodecConfig::debug_codec_dump(fd);
+
+  dprintf(fd,
+          "  Packet counts (expected/dropped)                        : %zu / "
+          "%zu\n",
+          stats->media_read_total_expected_packets,
+          stats->media_read_total_dropped_packets);
+
+  dprintf(fd,
+          "  PCM read counts (expected/actual)                       : %zu / "
+          "%zu\n",
+          stats->media_read_total_expected_reads_count,
+          stats->media_read_total_actual_reads_count);
+
+  dprintf(fd,
+          "  PCM read bytes (expected/actual)                        : %zu / "
+          "%zu\n",
+          stats->media_read_total_expected_read_bytes,
+          stats->media_read_total_actual_read_bytes);
+
+  dprintf(
+      fd, "  LHDC quality mode                                       : %s\n",
+      quality_mode_index_to_name(p_encoder_params->quality_mode_index).c_str());
+
+  dprintf(fd,
+          "  LHDC transmission bitrate (Kbps)                        : %d\n",
+          lhdc_get_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle));
+
+  dprintf(fd,
+          "  LHDC saved transmit queue length                        : %zu\n",
+          a2dp_lhdc_encoder_cb.TxQueueLength);
+/*
+  if (a2dp_lhdc_encoder_cb.has_lhdc_abr_handle) {
+    dprintf(fd,
+            "  LHDC adaptive bit rate encode quality mode index        : %d\n",
+            a2dp_lhdc_encoder_cb.last_lhdc_abr_eqmid);
+    dprintf(fd,
+            "  LHDC adaptive bit rate adjustments                      : %zu\n",
+            a2dp_lhdc_encoder_cb.lhdc_abr_adjustments);
+  }
+  */
+}
diff --git a/system/bt/stack/a2dp/a2dp_vendor_lhdcv5.cc b/system/bt/stack/a2dp/a2dp_vendor_lhdcv5.cc
new file mode 100755
index 00000000..6964f6c3
--- /dev/null
+++ b/system/bt/stack/a2dp/a2dp_vendor_lhdcv5.cc
@@ -0,0 +1,2880 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/******************************************************************************
+ *
+ *  Utility functions to help build and parse the LHDCV5 Codec Information
+ *  Element and Media Payload.
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "a2dp_vendor_lhdcv5"
+
+#include "bt_target.h"
+
+#include "a2dp_vendor_lhdcv5.h"
+
+#include <string.h>
+
+#include <base/logging.h>
+#include "a2dp_vendor.h"
+#include "a2dp_vendor_lhdcv5_encoder.h"
+#include "a2dp_vendor_lhdcv5_decoder.h"
+#include "bt_utils.h"
+#include "btif_av_co.h"
+#include "osi/include/log.h"
+#include "osi/include/osi.h"
+
+// data type for the LHDC Codec Information Element
+typedef struct {
+  uint32_t vendorId;                                    /* Vendor ID */
+  uint16_t codecId;                                     /* Codec ID */
+  uint8_t sampleRate;                                   /* Sampling Frequency Type */
+  uint8_t bitsPerSample;                                /* Bits Per Sample Type */
+  uint8_t channelMode;                                  /* Channel Mode */
+  uint8_t version;                                      /* Codec SubVersion Number */
+  uint8_t frameLenType;                                 /* Frame Length Type */
+  uint8_t maxTargetBitrate;                             /* Max Target Bit Rate Type */
+  uint8_t minTargetBitrate;                             /* Min Target Bit Rate Type */
+  bool hasFeatureAR;                                    /* FeatureSupported: AR */
+  bool hasFeatureJAS;                                   /* FeatureSupported: JAS */
+  bool hasFeatureMETA;                                  /* FeatureSupported: META */
+  bool hasFeatureLL;                                    /* FeatureSupported: Low Latency */
+  bool hasFeatureLLESS;                                 /* FeatureSupported: Lossless */
+  //for runtime feature switch on/off, not caps
+  bool featureOnAR;                                     /* Feature TurnOn: AR */
+} tA2DP_LHDCV5_CIE;
+
+// source capabilities
+static const tA2DP_LHDCV5_CIE a2dp_lhdcv5_source_caps = {
+    A2DP_LHDC_VENDOR_ID,  // vendorId
+    A2DP_LHDCV5_CODEC_ID, // codecId
+    // Sampling Frequency
+    (A2DP_LHDCV5_SAMPLING_FREQ_44100 | A2DP_LHDCV5_SAMPLING_FREQ_48000 | A2DP_LHDCV5_SAMPLING_FREQ_96000 | A2DP_LHDCV5_SAMPLING_FREQ_192000),
+    // Bits Per Sample
+    (A2DP_LHDCV5_BIT_FMT_16 | A2DP_LHDCV5_BIT_FMT_24),
+    // Channel Mode
+    A2DP_LHDCV5_CHANNEL_MODE_STEREO,
+    // Codec SubVersion Number
+    A2DP_LHDCV5_VER_1,
+    // Encoded Frame Length
+    A2DP_LHDCV5_FRAME_LEN_5MS,
+    // Max Target Bit Rate Type
+    A2DP_LHDCV5_MAX_BIT_RATE_MASK,
+    // Min Target Bit Rate Type
+    A2DP_LHDCV5_MIN_BIT_RATE_MASK,
+    // FeatureSupported: AR
+    true,
+    // FeatureSupported: JAS
+    true,
+    // FeatureSupported: META
+    true,
+    // FeatureSupported: Low Latency
+    true,
+    // FeatureSupported: Lossless
+    true,
+    // Feature On/OFF: AR
+    false,
+};
+
+// default source capabilities for best select
+static const tA2DP_LHDCV5_CIE a2dp_lhdcv5_source_default_caps = {
+    A2DP_LHDC_VENDOR_ID,  // vendorId
+    A2DP_LHDCV5_CODEC_ID, // codecId
+    // Sampling Frequency
+    A2DP_LHDCV5_SAMPLING_FREQ_48000,
+    // Bits Per Sample
+    A2DP_LHDCV5_BIT_FMT_24,
+    // Channel Mode
+    A2DP_LHDCV5_CHANNEL_MODE_STEREO,
+    // Codec Version Number
+    A2DP_LHDCV5_VER_1,
+    // Encoded Frame Length
+    A2DP_LHDCV5_FRAME_LEN_5MS,
+    // Max Target Bit Rate Type
+    A2DP_LHDCV5_MAX_BIT_RATE_1000K,
+    // Min Target Bit Rate Type
+    A2DP_LHDCV5_MIN_BIT_RATE_64K,
+    // FeatureSupported: AR
+    true,
+    // FeatureSupported: JAS
+    true,
+    // FeatureSupported: META
+    true,
+    // FeatureSupported: Low Latency
+    true,
+    // FeatureSupported: Lossless
+    true,
+    // Feature On/OFF: AR
+    false,
+};
+
+// sink capabilities
+static const tA2DP_LHDCV5_CIE a2dp_lhdcv5_sink_caps = {
+    A2DP_LHDC_VENDOR_ID,  // vendorId
+    A2DP_LHDCV5_CODEC_ID, // codecId
+    // Sampling Frequency
+    (A2DP_LHDCV5_SAMPLING_FREQ_44100 | A2DP_LHDCV5_SAMPLING_FREQ_48000 | A2DP_LHDCV5_SAMPLING_FREQ_96000 | A2DP_LHDCV5_SAMPLING_FREQ_192000),
+    // Bits Per Sample
+    (A2DP_LHDCV5_BIT_FMT_16 | A2DP_LHDCV5_BIT_FMT_24 | A2DP_LHDCV5_BIT_FMT_32),
+    // Channel Mode
+    A2DP_LHDCV5_CHANNEL_MODE_STEREO,
+    // Codec Version Number
+    A2DP_LHDCV5_VER_1,
+    // Encoded Frame Length
+    A2DP_LHDCV5_FRAME_LEN_5MS,
+    // Max Target Bit Rate Type
+    A2DP_LHDCV5_MAX_BIT_RATE_1000K,
+    // Min Target Bit Rate Type
+    A2DP_LHDCV5_MIN_BIT_RATE_64K,
+    // FeatureSupported: AR
+    true,
+    // FeatureSupported: JAS
+    true,
+    // FeatureSupported: META
+    true,
+    // FeatureSupported: Low Latency
+    true,
+    // FeatureSupported: Lossless
+    true,
+    // Feature On/OFF: AR
+    false,
+};
+
+// default sink capabilities
+UNUSED_ATTR static const tA2DP_LHDCV5_CIE a2dp_lhdcv5_sink_default_caps = {
+    A2DP_LHDC_VENDOR_ID,  // vendorId
+    A2DP_LHDCV5_CODEC_ID, // codecId
+    // Sampling Frequency
+    A2DP_LHDCV5_SAMPLING_FREQ_48000,
+    // Bits Per Sample
+    A2DP_LHDCV5_BIT_FMT_24,
+    // Channel Mode
+    A2DP_LHDCV5_CHANNEL_MODE_STEREO,
+    // Codec Version Number
+    A2DP_LHDCV5_VER_1,
+    // Encoded Frame Length
+    A2DP_LHDCV5_FRAME_LEN_5MS,
+    // Max Target Bit Rate Type
+    A2DP_LHDCV5_MAX_BIT_RATE_1000K,
+    // Min Target Bit Rate Type
+    A2DP_LHDCV5_MIN_BIT_RATE_64K,
+    // FeatureSupported: AR
+    true,
+    // FeatureSupported: JAS
+    true,
+    // FeatureSupported: META
+    true,
+    // FeatureSupported: Low Latency
+    true,
+    // FeatureSupported: Lossless
+    true,
+    // Feature On/OFF: AR
+    false,
+};
+
+//
+// Utilities for LHDC configuration on A2DP specifics - START
+//
+typedef struct {
+  btav_a2dp_codec_config_t *_codec_config_;
+  btav_a2dp_codec_config_t *_codec_capability_;
+  btav_a2dp_codec_config_t *_codec_local_capability_;
+  btav_a2dp_codec_config_t *_codec_selectable_capability_;
+  btav_a2dp_codec_config_t *_codec_user_config_;
+  btav_a2dp_codec_config_t *_codec_audio_config_;
+}tA2DP_CODEC_CONFIGS_PACK;
+
+typedef struct {
+  uint8_t   featureCode;  /* code of LHDC features */
+  uint8_t   inSpecBank;   /* target specific to store the feature flag */
+  uint8_t   bitPos;       /* the bit index(0~63) of the specific(int64_t) that bit store */
+  int64_t   value;        /* real value of the bit position written to the target specific */
+}tA2DP_LHDC_FEATURE_POS;
+
+// default settings of LHDC features configuration on specifics
+// info of feature: JAS
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdcv5_source_spec_JAS = {
+    LHDCV5_FEATURE_CODE_JAS,
+    LHDCV5_FEATURE_ON_A2DP_SPECIFIC_3,
+    LHDCV5_FEATURE_JAS_SPEC_BIT_POS,
+    (0x1ULL << LHDCV5_FEATURE_JAS_SPEC_BIT_POS),
+};
+
+// info of feature: AR
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdcv5_source_spec_AR = {
+    LHDCV5_FEATURE_CODE_AR,
+    LHDCV5_FEATURE_ON_A2DP_SPECIFIC_3,
+    LHDCV5_FEATURE_AR_SPEC_BIT_POS,
+    (0x1ULL << LHDCV5_FEATURE_AR_SPEC_BIT_POS),
+};
+
+// info of feature: META
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdcv5_source_spec_META = {
+    LHDCV5_FEATURE_CODE_META,
+    LHDCV5_FEATURE_ON_A2DP_SPECIFIC_3,
+    LHDCV5_FEATURE_META_SPEC_BIT_POS,
+    (0x1ULL << LHDCV5_FEATURE_META_SPEC_BIT_POS),
+};
+
+// info of feature: Low Latency
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdcv5_source_spec_LL = {
+    LHDCV5_FEATURE_CODE_LL,
+    LHDCV5_FEATURE_ON_A2DP_SPECIFIC_2,
+    LHDCV5_FEATURE_LL_SPEC_BIT_POS,
+    (0x1ULL << LHDCV5_FEATURE_LL_SPEC_BIT_POS),
+};
+
+// info of feature: LossLess
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdcv5_source_spec_LLESS = {
+    LHDCV5_FEATURE_CODE_LLESS,
+    LHDCV5_FEATURE_ON_A2DP_SPECIFIC_3,
+    LHDCV5_FEATURE_LLESS_SPEC_BIT_POS,
+    (0x1ULL << LHDCV5_FEATURE_LLESS_SPEC_BIT_POS),
+};
+
+UNUSED_ATTR static const tA2DP_LHDC_FEATURE_POS a2dp_lhdcv5_source_spec_all[] = {
+    a2dp_lhdcv5_source_spec_JAS,
+    a2dp_lhdcv5_source_spec_AR,
+    a2dp_lhdcv5_source_spec_META,
+    a2dp_lhdcv5_source_spec_LL,
+    a2dp_lhdcv5_source_spec_LLESS,
+};
+
+// to check if target feature bit is set in codec_user_config_
+static bool A2DP_IsFeatureInUserConfigLhdcV5(tA2DP_CODEC_CONFIGS_PACK* cfgsPtr, uint8_t featureCode) {
+  bool ret = false;
+
+  if (cfgsPtr == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return false;
+  }
+
+  switch (featureCode) {
+  case LHDCV5_FEATURE_CODE_JAS:
+  {
+    ret = LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_,
+        a2dp_lhdcv5_source_spec_JAS.inSpecBank, a2dp_lhdcv5_source_spec_JAS.value);
+    return ret;
+  } break;
+  case LHDCV5_FEATURE_CODE_AR:
+  {
+    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_,
+        a2dp_lhdcv5_source_spec_AR.inSpecBank, a2dp_lhdcv5_source_spec_AR.value);
+  } break;
+  case LHDCV5_FEATURE_CODE_META:
+  {
+    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_,
+        a2dp_lhdcv5_source_spec_META.inSpecBank, a2dp_lhdcv5_source_spec_META.value);
+  } break;
+  case LHDCV5_FEATURE_CODE_LL:
+  {
+    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_,
+        a2dp_lhdcv5_source_spec_LL.inSpecBank, a2dp_lhdcv5_source_spec_LL.value);
+  } break;
+  case LHDCV5_FEATURE_CODE_LLESS:
+  {
+    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_,
+        a2dp_lhdcv5_source_spec_LLESS.inSpecBank, a2dp_lhdcv5_source_spec_LLESS.value);
+  } break;
+  default:
+    break;
+  }
+
+  return false;
+}
+
+// to check if target feature bit is set in codec_config_
+static bool A2DP_IsFeatureInCodecConfigLhdcV5(tA2DP_CODEC_CONFIGS_PACK* cfgsPtr, uint8_t featureCode) {
+  if (cfgsPtr == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return false;
+  }
+
+  switch(featureCode) {
+  case LHDCV5_FEATURE_CODE_JAS:
+  {
+    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_,
+        a2dp_lhdcv5_source_spec_JAS.inSpecBank, a2dp_lhdcv5_source_spec_JAS.value);
+  } break;
+  case LHDCV5_FEATURE_CODE_AR:
+  {
+    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_,
+        a2dp_lhdcv5_source_spec_AR.inSpecBank, a2dp_lhdcv5_source_spec_AR.value);
+  } break;
+  case LHDCV5_FEATURE_CODE_META:
+  {
+    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_,
+        a2dp_lhdcv5_source_spec_META.inSpecBank, a2dp_lhdcv5_source_spec_META.value);
+  } break;
+  case LHDCV5_FEATURE_CODE_LL:
+  {
+    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_,
+        a2dp_lhdcv5_source_spec_LL.inSpecBank, a2dp_lhdcv5_source_spec_LL.value);
+  } break;
+  case LHDCV5_FEATURE_CODE_LLESS:
+  {
+    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_,
+        a2dp_lhdcv5_source_spec_LLESS.inSpecBank, a2dp_lhdcv5_source_spec_LLESS.value);
+  } break;
+  default:
+    break;
+  }
+
+  return false;
+}
+
+static void A2DP_UpdateFeatureToSpecLhdcV5(tA2DP_CODEC_CONFIGS_PACK* cfgsPtr,
+    uint16_t toCodecCfg, bool hasFeature, uint8_t toSpec, int64_t value) {
+  if (cfgsPtr == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return;
+  }
+
+  if (toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_CONFIG_) {
+    LHDC_SETUP_A2DP_SPEC(cfgsPtr->_codec_config_, toSpec, hasFeature, value);
+  }
+  if (toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_CAP_) {
+    LHDC_SETUP_A2DP_SPEC(cfgsPtr->_codec_capability_, toSpec, hasFeature, value);
+  }
+  if (toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_LOCAL_CAP_) {
+    LHDC_SETUP_A2DP_SPEC(cfgsPtr->_codec_local_capability_, toSpec, hasFeature, value);
+  }
+  if (toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_) {
+    LHDC_SETUP_A2DP_SPEC(cfgsPtr->_codec_selectable_capability_, toSpec, hasFeature, value);
+  }
+  if (toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_USER_) {
+    LHDC_SETUP_A2DP_SPEC(cfgsPtr->_codec_user_config_, toSpec, hasFeature, value);
+  }
+  if (toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_AUDIO_) {
+    LHDC_SETUP_A2DP_SPEC(cfgsPtr->_codec_audio_config_, toSpec, hasFeature, value);
+  }
+}
+
+// to update feature bit value to target codec config's specific
+static void A2DP_UpdateFeatureToA2dpConfigLhdcV5(tA2DP_CODEC_CONFIGS_PACK *cfgsPtr,
+    uint8_t featureCode,  uint16_t toCodecCfg, bool hasFeature) {
+  if (cfgsPtr == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return;
+  }
+
+  switch(featureCode) {
+  case LHDCV5_FEATURE_CODE_JAS:
+    A2DP_UpdateFeatureToSpecLhdcV5(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdcv5_source_spec_JAS.inSpecBank, a2dp_lhdcv5_source_spec_JAS.value);
+    break;
+  case LHDCV5_FEATURE_CODE_AR:
+    A2DP_UpdateFeatureToSpecLhdcV5(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdcv5_source_spec_AR.inSpecBank, a2dp_lhdcv5_source_spec_AR.value);
+    break;
+  case LHDCV5_FEATURE_CODE_META:
+    A2DP_UpdateFeatureToSpecLhdcV5(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdcv5_source_spec_META.inSpecBank, a2dp_lhdcv5_source_spec_META.value);
+    break;
+  case LHDCV5_FEATURE_CODE_LL:
+    A2DP_UpdateFeatureToSpecLhdcV5(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdcv5_source_spec_LL.inSpecBank, a2dp_lhdcv5_source_spec_LL.value);
+    break;
+  case LHDCV5_FEATURE_CODE_LLESS:
+    A2DP_UpdateFeatureToSpecLhdcV5(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdcv5_source_spec_LLESS.inSpecBank, a2dp_lhdcv5_source_spec_LLESS.value);
+    break;
+  default:
+    break;
+  }
+}
+//
+// Utilities for LHDC configuration on A2DP specifics - END
+
+static const tA2DP_ENCODER_INTERFACE a2dp_encoder_interface_lhdcv5 = {
+    a2dp_vendor_lhdcv5_encoder_init,
+    a2dp_vendor_lhdcv5_encoder_cleanup,
+    a2dp_vendor_lhdcv5_feeding_reset,
+    a2dp_vendor_lhdcv5_feeding_flush,
+    a2dp_vendor_lhdcv5_get_encoder_interval_ms,
+    a2dp_vendor_lhdcv5_send_frames,
+    a2dp_vendor_lhdcv5_set_transmit_queue_length,
+};
+
+static const tA2DP_DECODER_INTERFACE a2dp_decoder_interface_lhdcv5 = {
+    a2dp_vendor_lhdcv5_decoder_init,
+    a2dp_vendor_lhdcv5_decoder_cleanup,
+    a2dp_vendor_lhdcv5_decoder_decode_packet,
+};
+
+UNUSED_ATTR static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV5(
+    const tA2DP_LHDCV5_CIE* p_cap, const uint8_t* p_codec_info,
+    bool is_capability);
+
+
+// check if target version is supported right now
+static bool is_codec_version_supported(uint8_t version, bool is_source) {
+  const tA2DP_LHDCV5_CIE* p_a2dp_lhdcv5_caps =
+      (is_source) ? &a2dp_lhdcv5_source_caps : &a2dp_lhdcv5_sink_caps;
+
+  if ((version & p_a2dp_lhdcv5_caps->version) != A2DP_LHDCV5_VER_NS) {
+    return true;
+  }
+
+  LHDC_LOG_DBG(LOG_TAG, "%s: versoin unsupported! peer:%d local:%d",
+      __func__, version, p_a2dp_lhdcv5_caps->version);
+  return false;
+}
+
+// Builds the LHDC Media Codec Capabilities byte sequence beginning from the
+// LOSC octet. |media_type| is the media type |AVDT_MEDIA_TYPE_*|.
+// |p_ie| is a pointer to the LHDC Codec Information Element information.
+// The result is stored in |p_result|. Returns A2DP_SUCCESS on success,
+// otherwise the corresponding A2DP error status code.
+static tA2DP_STATUS A2DP_BuildInfoLhdcV5(uint8_t media_type,
+    const tA2DP_LHDCV5_CIE* p_ie,
+    uint8_t* p_result) {
+
+  const uint8_t* tmpInfo = p_result;
+  uint8_t para = 0;
+
+  if (p_ie == nullptr || p_result == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return A2DP_INVALID_PARAMS;
+  }
+
+  *p_result++ = A2DP_LHDCV5_CODEC_LEN;  //H0
+  *p_result++ = (media_type << 4);      //H1
+  *p_result++ = A2DP_MEDIA_CT_NON_A2DP; //H2
+
+  // Vendor ID(P0-P3) and Codec ID(P4-P5)
+  *p_result++ = (uint8_t)(p_ie->vendorId & 0x000000FF);
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0x0000FF00) >> 8);
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0x00FF0000) >> 16);
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0xFF000000) >> 24);
+  *p_result++ = (uint8_t)(p_ie->codecId & 0x00FF);
+  *p_result++ = (uint8_t)((p_ie->codecId & 0xFF00) >> 8);
+
+  para = 0;
+  // P6[5:0] Sampling Frequency
+  if ((p_ie->sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_MASK) != A2DP_LHDCV5_SAMPLING_FREQ_NS) {
+    para |= (p_ie->sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_MASK);
+  } else {
+    LOG_ERROR(LOG_TAG, "%s: invalid sample rate (0x%02X)", __func__, p_ie->sampleRate);
+    return A2DP_INVALID_PARAMS;
+  }
+  // update P6
+  *p_result++ = para; para = 0;
+
+  // P7[2:0] Bit Depth
+  if ((p_ie->bitsPerSample & A2DP_LHDCV5_BIT_FMT_MASK) != A2DP_LHDCV5_BIT_FMT_NS) {
+    para |= (p_ie->bitsPerSample & A2DP_LHDCV5_BIT_FMT_MASK);
+  } else {
+    LOG_ERROR(LOG_TAG, "%s: invalid bits per sample (0x%02X)", __func__, p_ie->bitsPerSample);
+    return A2DP_INVALID_PARAMS;
+  }
+  // P7[5:4] Max Target Bit Rate
+  para |= (p_ie->maxTargetBitrate & A2DP_LHDCV5_MAX_BIT_RATE_MASK);
+  // P7[7:6] Min Target Bit Rate
+  para |= (p_ie->minTargetBitrate & A2DP_LHDCV5_MIN_BIT_RATE_MASK);
+  // update P7
+  *p_result++ = para; para = 0;
+
+  // P8[3:0] Codec SubVersion
+  if ((p_ie->version & A2DP_LHDCV5_VERSION_MASK) != A2DP_LHDCV5_VER_NS) {
+    para = para | (p_ie->version & A2DP_LHDCV5_VERSION_MASK);
+  } else {
+    LOG_ERROR(LOG_TAG, "%s: invalid codec subversion (0x%02X)", __func__, p_ie->version);
+    return A2DP_INVALID_PARAMS;
+  }
+  // P8[5:4] Frame Length Type
+  if ((p_ie->frameLenType & A2DP_LHDCV5_FRAME_LEN_MASK) != A2DP_LHDCV5_FRAME_LEN_NS) {
+    para = para | (p_ie->frameLenType & A2DP_LHDCV5_FRAME_LEN_MASK);
+  } else {
+    LOG_ERROR(LOG_TAG, "%s: invalid frame length type (0x%02X)", __func__, p_ie->frameLenType);
+    return A2DP_INVALID_PARAMS;
+  }
+  // update P8
+  *p_result++ = para; para = 0;
+
+  // P9[0] HasAR
+  // P9[1] HasJAS
+  // P9[2] HasMeta
+  // P9[6] HasLL
+  // P9[7] HasLossless
+  if (p_ie->hasFeatureAR) {
+    para |= A2DP_LHDCV5_FEATURE_AR;
+  }
+  if (p_ie->hasFeatureJAS) {
+    para |= A2DP_LHDCV5_FEATURE_JAS;
+  }
+  if (p_ie->hasFeatureMETA) {
+    para |= A2DP_LHDCV5_FEATURE_META;
+  }
+  if (p_ie->hasFeatureLL) {
+    para |= A2DP_LHDCV5_FEATURE_LL;
+  }
+  if (p_ie->hasFeatureLLESS) {
+    para |= A2DP_LHDCV5_FEATURE_LLESS;
+  }
+  // update P9
+  *p_result++ = para; para = 0;
+
+  // P10[0] AR ON/OFF
+  if (p_ie->featureOnAR) {
+    para |= A2DP_LHDCV5_AR_ON;
+  }
+  // update P10
+  *p_result++ = para; para = 0;
+
+  LHDC_LOG_DBG(LOG_TAG, "%s: codec info built = H0-H2{%02X %02X %02X} P0-P3{%02X "
+      "%02X %02X %02X} P4-P5{%02X %02X} P6{%02X} P7{%02X} P8{%02X} P9{%02X} P10{%02X}", __func__,
+      tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3], tmpInfo[4], tmpInfo[5], tmpInfo[6], tmpInfo[7],
+      tmpInfo[8], tmpInfo[9], tmpInfo[10], tmpInfo[11], tmpInfo[12], tmpInfo[A2DP_LHDCV5_CODEC_LEN]);
+
+  return A2DP_SUCCESS;
+}
+
+// Parses the LHDC Media Codec Capabilities byte sequence beginning from the
+// LOSC octet. The result is stored in |p_ie|. The byte sequence to parse is
+// |p_codec_info|. If |is_capability| is true, the byte sequence is
+// codec capabilities, otherwise is codec configuration.
+// Returns A2DP_SUCCESS on success, otherwise the corresponding A2DP error
+// status code.
+static tA2DP_STATUS A2DP_ParseInfoLhdcV5(tA2DP_LHDCV5_CIE* p_ie,
+    const uint8_t* p_codec_info,
+    bool is_capability,
+    bool is_source) {
+  uint8_t losc;
+  uint8_t media_type;
+  tA2DP_CODEC_TYPE codec_type;
+  const uint8_t* tmpInfo = p_codec_info;
+  const uint8_t* p_codec_Info_save = p_codec_info;
+
+  if (p_ie == nullptr || p_codec_info == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return A2DP_INVALID_PARAMS;
+  }
+
+  // Codec capability length
+  losc = *p_codec_info++;
+  if (losc != A2DP_LHDCV5_CODEC_LEN) {
+    LOG_ERROR(LOG_TAG, "%s: wrong length %u", __func__, losc);
+    return A2DP_WRONG_CODEC;
+  }
+
+  media_type = (*p_codec_info++) >> 4;
+  codec_type = *p_codec_info++;
+
+  // Media Type and Media Codec Type
+  if (media_type != AVDT_MEDIA_TYPE_AUDIO ||
+      codec_type != A2DP_MEDIA_CT_NON_A2DP) {
+    LOG_ERROR(LOG_TAG, "%s: invalid media type 0x%X codec_type 0x%X", __func__, media_type, codec_type);
+    return A2DP_WRONG_CODEC;
+  }
+
+  // Vendor ID(P0-P3) and Codec ID(P4-P5)
+  p_ie->vendorId = (*p_codec_info & 0x000000FF) |
+      (*(p_codec_info + 1) << 8 & 0x0000FF00) |
+      (*(p_codec_info + 2) << 16 & 0x00FF0000) |
+      (*(p_codec_info + 3) << 24 & 0xFF000000);
+  p_codec_info += 4;
+  p_ie->codecId = (*p_codec_info & 0x00FF) | (*(p_codec_info + 1) << 8 & 0xFF00);
+  p_codec_info += 2;
+  if (p_ie->vendorId != A2DP_LHDC_VENDOR_ID ||
+      p_ie->codecId != A2DP_LHDCV5_CODEC_ID) {
+    LOG_ERROR(LOG_TAG, "%s: invalid vendorId 0x%X codecId 0x%X", __func__,
+        p_ie->vendorId, p_ie->codecId);
+    return A2DP_WRONG_CODEC;
+  }
+
+  // P6[5:0] Sampling Frequency
+  p_ie->sampleRate = (*p_codec_info & A2DP_LHDCV5_SAMPLING_FREQ_MASK);
+  if (p_ie->sampleRate == A2DP_LHDCV5_SAMPLING_FREQ_NS) {
+    LOG_ERROR(LOG_TAG, "%s: invalid sample rate 0x%X", __func__, p_ie->sampleRate);
+    return A2DP_WRONG_CODEC;
+  }
+  p_codec_info += 1;
+
+  // P7[2:0] Bits Per Sample
+  p_ie->bitsPerSample = (*p_codec_info & A2DP_LHDCV5_BIT_FMT_MASK);
+  if (p_ie->bitsPerSample == A2DP_LHDCV5_BIT_FMT_NS) {
+    LOG_ERROR(LOG_TAG, "%s: invalid bit per sample 0x%X", __func__, p_ie->bitsPerSample);
+    return A2DP_WRONG_CODEC;
+  }
+  // P7[5:4] Max Target Bit Rate
+  p_ie->maxTargetBitrate = (*p_codec_info & A2DP_LHDCV5_MAX_BIT_RATE_MASK);
+  // P7[7:6] Min Target Bit Rate
+  p_ie->minTargetBitrate = (*p_codec_info & A2DP_LHDCV5_MIN_BIT_RATE_MASK);
+  p_codec_info += 1;
+
+  // Channel Mode: stereo only
+  p_ie->channelMode = A2DP_LHDCV5_CHANNEL_MODE_STEREO;
+
+  // P8[3:0] Codec SubVersion
+  p_ie->version = (*p_codec_info & A2DP_LHDCV5_VERSION_MASK);
+  if (p_ie->version == A2DP_LHDCV5_VER_NS) {
+    LOG_ERROR(LOG_TAG, "%s: invalid version 0x%X", __func__, p_ie->version);
+    return A2DP_WRONG_CODEC;
+  } else {
+    if (!is_codec_version_supported(p_ie->version, is_source)) {
+      LOG_ERROR(LOG_TAG, "%s: unsupported version 0x%X", __func__, p_ie->version);
+      return A2DP_WRONG_CODEC;
+    }
+  }
+  // P8[5:4] Frame Length Type
+  p_ie->frameLenType = (*p_codec_info & A2DP_LHDCV5_FRAME_LEN_MASK);
+  if (p_ie->frameLenType == A2DP_LHDCV5_FRAME_LEN_NS) {
+    LOG_ERROR(LOG_TAG, "%s: invalid frame length mode 0x%X", __func__, p_ie->frameLenType);
+    return A2DP_WRONG_CODEC;
+  }
+  p_codec_info += 1;
+
+  // Features:
+  // P9[0] HasAR
+  // P9[1] HasJAS
+  // P9[2] HasMeta
+  // P9[6] HasLL
+  // P9[7] HasLossless
+  p_ie->hasFeatureAR = ((*p_codec_info & A2DP_LHDCV5_FEATURE_AR) != 0) ? true : false;
+  p_ie->hasFeatureJAS = ((*p_codec_info & A2DP_LHDCV5_FEATURE_JAS) != 0) ? true : false;
+  p_ie->hasFeatureMETA = ((*p_codec_info & A2DP_LHDCV5_FEATURE_META) != 0) ? true : false;
+  p_ie->hasFeatureLL = ((*p_codec_info & A2DP_LHDCV5_FEATURE_LL) != 0) ? true : false;
+  p_ie->hasFeatureLLESS = ((*p_codec_info & A2DP_LHDCV5_FEATURE_LLESS) != 0) ? true : false;
+  p_codec_info += 1;
+
+  // P10[0] AR_ON_OFF
+  p_ie->featureOnAR = ((*p_codec_info & A2DP_LHDCV5_AR_ON) != 0) ? true : false;
+
+  LHDC_LOG_DBG(LOG_TAG, "%s: codec info parsed = H0-H2{%02X %02X %02X} P0-P3{%02X "
+      "%02X %02X %02X} P4-P5{%02X %02X} P6{%02X} P7{%02X} P8{%02X} P9{%02X} P10{%02X}", __func__,
+      tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3], tmpInfo[4], tmpInfo[5], tmpInfo[6], tmpInfo[7],
+      tmpInfo[8], tmpInfo[9], tmpInfo[10], tmpInfo[11], tmpInfo[12], tmpInfo[A2DP_LHDCV5_CODEC_LEN]);
+
+  LHDC_LOG_DBG(LOG_TAG, "%s: %s isCap{%d} SR{%02X} BPS{%02X} Ver{%02X} FL{%02X} "
+      "MBR{%02X} mBR{%02X} Feature{AR(%d) JAS(%d) META(%d) LL(%d) LLESS(%d)} AR_ON{%d}",
+      __func__,
+      (is_source?"SRC":"SNK"),
+      is_capability,
+      p_ie->sampleRate,
+      p_ie->bitsPerSample,
+      p_ie->version,
+      p_ie->frameLenType,
+      p_ie->maxTargetBitrate,
+      p_ie->minTargetBitrate,
+      p_ie->hasFeatureAR,
+      p_ie->hasFeatureJAS,
+      p_ie->hasFeatureMETA,
+      p_ie->hasFeatureLL,
+      p_ie->hasFeatureLLESS,
+      p_ie->featureOnAR);
+
+  //save decoder needed parameters
+#if 1
+  if (!is_source) {
+    if (!a2dp_lhdcv5_decoder_save_codec_info(p_codec_Info_save)) {
+      LHDC_LOG_DBG(LOG_TAG, "%s: save decoder parameters error", __func__);
+    }
+  }
+#endif
+
+  return A2DP_SUCCESS;
+}
+
+bool A2DP_IsVendorSourceCodecValidLhdcV5(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE cfg_cie;
+  /* Use a liberal check when parsing the codec info */
+  return (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, false, IS_SRC) == A2DP_SUCCESS) ||
+      (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, true, IS_SRC) == A2DP_SUCCESS);
+}
+bool A2DP_IsVendorSinkCodecValidLhdcV5(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE cfg_cie;
+  /* Use a liberal check when parsing the codec info */
+  return (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, false, IS_SNK) == A2DP_SUCCESS) ||
+      (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, true, IS_SNK) == A2DP_SUCCESS);
+}
+
+bool A2DP_IsVendorPeerSinkCodecValidLhdcV5(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE cfg_cie;
+  /* Use a liberal check when parsing the codec info */
+  return (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, false, IS_SRC) == A2DP_SUCCESS) ||
+      (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, true, IS_SRC) == A2DP_SUCCESS);
+}
+bool A2DP_IsVendorPeerSourceCodecValidLhdcV5(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE cfg_cie;
+  /* Use a liberal check when parsing the codec info */
+  return (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, false, IS_SNK) == A2DP_SUCCESS) ||
+      (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, true, IS_SNK) == A2DP_SUCCESS);
+}
+
+// NOTE: Should be done only for local Sink codec
+bool A2DP_IsVendorSinkCodecSupportedLhdcV5(const uint8_t* p_codec_info) {
+  return (A2DP_CodecInfoMatchesCapabilityLhdcV5(&a2dp_lhdcv5_sink_caps, p_codec_info,
+      false) == A2DP_SUCCESS);
+}
+// NOTE: Should be done only for local Sink codec
+bool A2DP_IsPeerSourceCodecSupportedLhdcV5(const uint8_t* p_codec_info) {
+  return (A2DP_CodecInfoMatchesCapabilityLhdcV5(&a2dp_lhdcv5_sink_caps, p_codec_info,
+      true) == A2DP_SUCCESS);
+}
+
+// Checks whether A2DP LHDC codec configuration matches with a device's codec
+// capabilities.
+//  |p_cap| is the LHDC local codec capabilities.
+//  |p_codec_info| is peer's codec capabilities acting as an A2DP source.
+// If |is_capability| is true, the byte sequence is codec capabilities,
+// otherwise is codec configuration.
+// Returns A2DP_SUCCESS if the codec configuration matches with capabilities,
+// otherwise the corresponding A2DP error status code.
+static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV5(
+    const tA2DP_LHDCV5_CIE* p_cap, const uint8_t* p_codec_info, bool is_capability) {
+  tA2DP_STATUS status;
+  tA2DP_LHDCV5_CIE cfg_cie;
+
+  if (p_cap == nullptr || p_codec_info == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return A2DP_INVALID_PARAMS;
+  }
+
+  // parse configuration
+  status = A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, is_capability, IS_SNK);
+  if (status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: parsing failed %d", __func__, status);
+    return status;
+  }
+
+  // verify that each parameter is in range
+  LHDC_LOG_DBG(LOG_TAG, "%s: FREQ peer: 0x%x, capability 0x%x", __func__,
+      cfg_cie.sampleRate, p_cap->sampleRate);
+
+  LHDC_LOG_DBG(LOG_TAG, "%s: BIT_FMT peer: 0x%x, capability 0x%x", __func__,
+      cfg_cie.bitsPerSample, p_cap->bitsPerSample);
+
+  // sampling frequency
+  if ((cfg_cie.sampleRate & p_cap->sampleRate) == 0) return A2DP_NS_SAMP_FREQ;
+
+  // bits per sample
+  if ((cfg_cie.bitsPerSample & p_cap->bitsPerSample) == 0) return A2DP_NS_BIT_RATE;
+
+  return A2DP_SUCCESS;
+}
+
+bool A2DP_VendorUsesRtpHeaderLhdcV5(UNUSED_ATTR bool content_protection_enabled,
+    UNUSED_ATTR const uint8_t* p_codec_info) {
+  // TODO: Is this correct? The RTP header is always included?
+  return true;
+}
+
+const char* A2DP_VendorCodecNameLhdcV5(UNUSED_ATTR const uint8_t* p_codec_info) {
+  return "LHDC V5";
+}
+
+bool A2DP_VendorCodecTypeEqualsLhdcV5(const uint8_t* p_codec_info_a,
+    const uint8_t* p_codec_info_b) {
+  tA2DP_LHDCV5_CIE lhdc_cie_a;
+  tA2DP_LHDCV5_CIE lhdc_cie_b;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info_a == nullptr || p_codec_info_b == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status =
+      A2DP_ParseInfoLhdcV5(&lhdc_cie_a, p_codec_info_a, true, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+        a2dp_status);
+    return false;
+  }
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie_b, p_codec_info_b, true, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+        a2dp_status);
+    return false;
+  }
+
+  return true;
+}
+
+bool A2DP_VendorCodecEqualsLhdcV5(const uint8_t* p_codec_info_a,
+    const uint8_t* p_codec_info_b) {
+  tA2DP_LHDCV5_CIE lhdc_cie_a;
+  tA2DP_LHDCV5_CIE lhdc_cie_b;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info_a == nullptr || p_codec_info_b == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status =
+      A2DP_ParseInfoLhdcV5(&lhdc_cie_a, p_codec_info_a, true, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information of a: %d", __func__,
+        a2dp_status);
+    return false;
+  }
+  a2dp_status =
+      A2DP_ParseInfoLhdcV5(&lhdc_cie_b, p_codec_info_b, true, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information of b: %d", __func__,
+        a2dp_status);
+    return false;
+  }
+
+  // exam items that require to update codec config with peer if different
+  return (lhdc_cie_a.sampleRate == lhdc_cie_b.sampleRate) &&
+      (lhdc_cie_a.bitsPerSample == lhdc_cie_b.bitsPerSample) &&
+      (lhdc_cie_a.channelMode == lhdc_cie_b.channelMode) &&
+      (lhdc_cie_a.frameLenType == lhdc_cie_b.frameLenType) &&
+      //(lhdc_cie_a.hasFeatureAR == lhdc_cie_b.hasFeatureAR) &&
+      (lhdc_cie_a.hasFeatureLL == lhdc_cie_b.hasFeatureLL);
+}
+
+int A2DP_VendorGetBitRateLhdcV5(const uint8_t* p_codec_info) {
+  A2dpCodecConfig* current_codec = bta_av_get_a2dp_current_codec();
+  btav_a2dp_codec_config_t codec_config_ = current_codec->getCodecConfig();
+
+  if ((codec_config_.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) ==
+      A2DP_LHDC_QUALITY_MAGIC_NUM) {
+    switch ((int)(codec_config_.codec_specific_1 & 0xff)) {
+      case A2DP_LHDCV5_QUALITY_LOW0:
+        return 64000;
+      case A2DP_LHDCV5_QUALITY_LOW1:
+        return 128000;
+      case A2DP_LHDCV5_QUALITY_LOW2:
+        return 192000;
+      case A2DP_LHDCV5_QUALITY_LOW3:
+        return 256000;
+      case A2DP_LHDCV5_QUALITY_LOW4:
+        return 320000;
+      case A2DP_LHDCV5_QUALITY_LOW:
+        return 400000;
+      case A2DP_LHDCV5_QUALITY_MID:
+        return 500000;
+      case A2DP_LHDCV5_QUALITY_HIGH:
+        return 900000;
+      case A2DP_LHDCV5_QUALITY_HIGH1:
+        return 1000000;
+      case A2DP_LHDCV5_QUALITY_ABR:
+        return 9999999;
+      default:
+        return -1;
+    }
+  }
+  return 400000;
+}
+
+int A2DP_VendorGetTrackSampleRateLhdcV5(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return -1;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+        a2dp_status);
+    return -1;
+  }
+
+  switch (lhdc_cie.sampleRate) {
+  case A2DP_LHDCV5_SAMPLING_FREQ_44100:
+    return 44100;
+  case A2DP_LHDCV5_SAMPLING_FREQ_48000:
+    return 48000;
+  case A2DP_LHDCV5_SAMPLING_FREQ_96000:
+    return 96000;
+  case A2DP_LHDCV5_SAMPLING_FREQ_192000:
+    return 192000;
+  }
+
+  return -1;
+}
+
+int A2DP_VendorGetTrackBitsPerSampleLhdcV5(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return -1;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+        a2dp_status);
+    return -1;
+  }
+
+  switch (lhdc_cie.bitsPerSample) {
+  case A2DP_LHDCV5_BIT_FMT_16:
+    return 16;
+  case A2DP_LHDCV5_BIT_FMT_24:
+    return 24;
+  case A2DP_LHDCV5_BIT_FMT_32:
+    return 32;
+  }
+
+  return -1;
+}
+
+int A2DP_VendorGetTrackChannelCountLhdcV5(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return -1;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+        a2dp_status);
+    return -1;
+  }
+
+  switch (lhdc_cie.channelMode) {
+  case A2DP_LHDCV5_CHANNEL_MODE_MONO:
+    return 1;
+  case A2DP_LHDCV5_CHANNEL_MODE_DUAL:
+    return 2;
+  case A2DP_LHDCV5_CHANNEL_MODE_STEREO:
+    return 2;
+  }
+
+  return -1;
+}
+
+int A2DP_VendorGetSinkTrackChannelTypeLhdcV5(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return -1;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SNK);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+        a2dp_status);
+    return -1;
+  }
+
+  switch (lhdc_cie.channelMode) {
+  case A2DP_LHDCV5_CHANNEL_MODE_MONO:
+    return 1;
+  case A2DP_LHDCV5_CHANNEL_MODE_DUAL:
+    return 3;
+  case A2DP_LHDCV5_CHANNEL_MODE_STEREO:
+    return 3;
+  }
+
+  return -1;
+}
+
+int A2DP_VendorGetChannelModeCodeLhdcV5(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return -1;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+        a2dp_status);
+    return -1;
+  }
+
+  switch (lhdc_cie.channelMode) {
+  case A2DP_LHDCV5_CHANNEL_MODE_MONO:
+  case A2DP_LHDCV5_CHANNEL_MODE_DUAL:
+  case A2DP_LHDCV5_CHANNEL_MODE_STEREO:
+    return lhdc_cie.channelMode;
+  default:
+    break;
+  }
+
+  return -1;
+}
+
+bool A2DP_VendorGetPacketTimestampLhdcV5(UNUSED_ATTR const uint8_t* p_codec_info,
+    const uint8_t* p_data,
+    uint32_t* p_timestamp) {
+  if (p_codec_info == nullptr || p_data == nullptr || p_timestamp == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // TODO: Is this function really codec-specific?
+  *p_timestamp = *(const uint32_t*)p_data;
+  return true;
+}
+
+bool A2DP_VendorBuildCodecHeaderLhdcV5(UNUSED_ATTR const uint8_t* p_codec_info,
+    BT_HDR* p_buf,
+    uint16_t frames_per_packet) {
+  uint8_t* p;
+
+  if (p_codec_info == nullptr || p_buf == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return false;
+  }
+
+  p_buf->offset -= A2DP_LHDC_MPL_HDR_LEN;
+  p = (uint8_t*)(p_buf + 1) + p_buf->offset;
+  p_buf->len += A2DP_LHDC_MPL_HDR_LEN;
+
+  // Not support fragmentation
+  p[0] = ( uint8_t)( frames_per_packet & 0xff);
+  p[1] = ( uint8_t)( ( frames_per_packet >> 8) & 0xff);
+
+  return true;
+}
+
+void A2DP_VendorDumpCodecInfoLhdcV5(const uint8_t* p_codec_info) {
+  tA2DP_STATUS a2dp_status;
+  tA2DP_LHDCV5_CIE lhdc_cie;
+
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, true, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: A2DP_ParseInfoLhdcV5 fail:%d", __func__, a2dp_status);
+    return;
+  }
+
+  LOG_DEBUG(LOG_TAG, "\tsamp_freq: 0x%02X ", lhdc_cie.sampleRate);
+  if (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100) {
+    LOG_DEBUG(LOG_TAG, "\tsamp_freq: (44100)");
+  }
+  if (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000) {
+    LOG_DEBUG(LOG_TAG, "\tsamp_freq: (48000)");
+  }
+  if (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000) {
+    LOG_DEBUG(LOG_TAG, "\tsamp_freq: (96000)");
+  }
+  if (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000) {
+    LOG_DEBUG(LOG_TAG, "\tsamp_freq: (19200)");
+  }
+
+  LOG_DEBUG(LOG_TAG, "\tbitsPerSample: 0x%02X ", lhdc_cie.bitsPerSample);
+  if (lhdc_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_16) {
+    LOG_DEBUG(LOG_TAG, "\tbit_depth: (16)");
+  }
+  if (lhdc_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_24) {
+    LOG_DEBUG(LOG_TAG, "\tbit_depth: (24)");
+  }
+  if (lhdc_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_32) {
+    LOG_DEBUG(LOG_TAG, "\tbit_depth: (32)");
+  }
+
+  LOG_DEBUG(LOG_TAG, "\tchannelMode: 0x%02X ", lhdc_cie.channelMode);
+  if (lhdc_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_MONO) {
+    LOG_DEBUG(LOG_TAG, "\tchannle_mode: (mono)");
+  }
+  if (lhdc_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_DUAL) {
+    LOG_DEBUG(LOG_TAG, "\tchannle_mode: (dual)");
+  }
+  if (lhdc_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_STEREO) {
+    LOG_DEBUG(LOG_TAG, "\tchannle_mode: (stereo)");
+  }
+}
+
+std::string A2DP_VendorCodecInfoStringLhdcV5(const uint8_t* p_codec_info) {
+  std::stringstream res;
+  std::string field;
+  tA2DP_STATUS a2dp_status;
+  tA2DP_LHDCV5_CIE lhdc_cie;
+
+  if (p_codec_info == nullptr) {
+    res << "A2DP_VendorCodecInfoStringLhdcV5 nullptr";
+    return res.str();
+  }
+
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, true, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    res << "A2DP_ParseInfoLhdcV5 fail: " << loghex(a2dp_status);
+    return res.str();
+  }
+
+  res << "\tname: LHDC V5\n";
+
+  // Sample frequency
+  field.clear();
+  AppendField(&field, (lhdc_cie.sampleRate == A2DP_LHDCV5_SAMPLING_FREQ_NS), "NONE");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100),
+      "44100");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000),
+      "48000");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000),
+      "96000");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000),
+      "192000");
+  res << "\tsamp_freq: " << field << " (" << loghex(lhdc_cie.sampleRate)
+                                                                      << ")\n";
+
+  // bits per sample
+  field.clear();
+  AppendField(&field, (lhdc_cie.bitsPerSample == A2DP_LHDCV5_BIT_FMT_NS), "NONE");
+  AppendField(&field, (lhdc_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_16),
+      "16");
+  AppendField(&field, (lhdc_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_24),
+      "24");
+  AppendField(&field, (lhdc_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_32),
+      "24");
+  res << "\tbits_depth: " << field << " bits (" << loghex((int)lhdc_cie.bitsPerSample)
+                                                                      << ")\n";
+
+  // Channel mode
+  field.clear();
+  AppendField(&field, (lhdc_cie.channelMode == A2DP_LHDCV5_CHANNEL_MODE_NS), "NONE");
+  AppendField(&field, (lhdc_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_MONO),
+      "Mono");
+  AppendField(&field, (lhdc_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_DUAL),
+      "Dual");
+  AppendField(&field, (lhdc_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_STEREO),
+      "Stereo");
+  res << "\tch_mode: " << field << " (" << loghex(lhdc_cie.channelMode)
+                                                                      << ")\n";
+
+  // Version
+  field.clear();
+  AppendField(&field, (lhdc_cie.version == A2DP_LHDCV5_VER_NS), "NONE");
+  AppendField(&field, (lhdc_cie.version == A2DP_LHDCV5_VER_1),
+      "LHDC V5 Ver1");
+  res << "\tversion: " << field << " (" << loghex(lhdc_cie.version)
+                                                                      << ")\n";
+
+  // Max target bit rate...
+  field.clear();
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDCV5_MAX_BIT_RATE_MASK) == A2DP_LHDCV5_MAX_BIT_RATE_1000K),
+      "1000Kbps");
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDCV5_MAX_BIT_RATE_MASK) == A2DP_LHDCV5_MAX_BIT_RATE_900K),
+      "900Kbps");
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDCV5_MAX_BIT_RATE_MASK) == A2DP_LHDCV5_MAX_BIT_RATE_500K),
+      "500Kbps");
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDCV5_MAX_BIT_RATE_MASK) == A2DP_LHDCV5_MAX_BIT_RATE_400K),
+      "400Kbps");
+  res << "\tMax target-rate: " << field << " (" << loghex((lhdc_cie.maxTargetBitrate & A2DP_LHDCV5_MAX_BIT_RATE_MASK))
+                                                                      << ")\n";
+
+  // Min target bit rate...
+  field.clear();
+  AppendField(&field, ((lhdc_cie.minTargetBitrate & A2DP_LHDCV5_MIN_BIT_RATE_MASK) == A2DP_LHDCV5_MIN_BIT_RATE_400K),
+      "400Kbps");
+  AppendField(&field, ((lhdc_cie.minTargetBitrate & A2DP_LHDCV5_MIN_BIT_RATE_MASK) == A2DP_LHDCV5_MIN_BIT_RATE_256K),
+      "256Kbps");
+  AppendField(&field, ((lhdc_cie.minTargetBitrate & A2DP_LHDCV5_MIN_BIT_RATE_MASK) == A2DP_LHDCV5_MIN_BIT_RATE_128K),
+      "128Kbps");
+  AppendField(&field, ((lhdc_cie.minTargetBitrate & A2DP_LHDCV5_MIN_BIT_RATE_MASK) == A2DP_LHDCV5_MIN_BIT_RATE_64K),
+      "64Kbps");
+  res << "\tMin target-rate: " << field << " (" << loghex((lhdc_cie.minTargetBitrate & A2DP_LHDCV5_MIN_BIT_RATE_MASK))
+                                                                      << ")\n";
+
+  return res.str();
+}
+
+const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterfaceLhdcV5(
+    const uint8_t* p_codec_info) {
+  if (p_codec_info == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return NULL;
+  }
+
+  if (!A2DP_IsVendorSourceCodecValidLhdcV5(p_codec_info)) return NULL;
+
+  return &a2dp_encoder_interface_lhdcv5;
+}
+
+const tA2DP_DECODER_INTERFACE* A2DP_VendorGetDecoderInterfaceLhdcV5(
+    const uint8_t* p_codec_info) {
+  if (p_codec_info == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return NULL;
+  }
+
+  if (!A2DP_IsVendorSinkCodecValidLhdcV5(p_codec_info)) return NULL;
+
+  return &a2dp_decoder_interface_lhdcv5;
+}
+
+bool A2DP_VendorAdjustCodecLhdcV5(uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE cfg_cie;
+  if (p_codec_info == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // Nothing to do: just verify the codec info is valid
+  if (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, true, IS_SRC) != A2DP_SUCCESS)
+    return false;
+
+  return true;
+}
+
+btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndexLhdcV5(
+    UNUSED_ATTR const uint8_t* p_codec_info) {
+  return BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5;
+}
+
+btav_a2dp_codec_index_t A2DP_VendorSinkCodecIndexLhdcV5(
+    UNUSED_ATTR const uint8_t* p_codec_info) {
+  return BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5;
+}
+
+const char* A2DP_VendorCodecIndexStrLhdcV5(void) { return "LHDC V5"; }
+
+const char* A2DP_VendorCodecIndexStrLhdcV5Sink(void) { return "LHDC V5 SINK"; }
+
+bool A2DP_VendorInitCodecConfigLhdcV5(AvdtpSepConfig* p_cfg) {
+  if (p_cfg == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return false;
+  }
+
+  if (A2DP_BuildInfoLhdcV5(AVDT_MEDIA_TYPE_AUDIO, &a2dp_lhdcv5_source_caps,
+      p_cfg->codec_info) != A2DP_SUCCESS) {
+    return false;
+  }
+
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+  /* Content protection info - support SCMS-T */
+  uint8_t* p = p_cfg->protect_info;
+  *p++ = AVDT_CP_LOSC;
+  UINT16_TO_STREAM(p, AVDT_CP_SCMS_T_ID);
+  p_cfg->num_protect = 1;
+#endif
+
+  return true;
+}
+
+bool A2DP_VendorInitCodecConfigLhdcV5Sink(AvdtpSepConfig* p_cfg) {
+  if (p_cfg == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return false;
+  }
+
+  if (A2DP_BuildInfoLhdcV5(AVDT_MEDIA_TYPE_AUDIO, &a2dp_lhdcv5_sink_caps,
+      p_cfg->codec_info) != A2DP_SUCCESS) {
+    return false;
+  }
+
+  return true;
+}
+
+UNUSED_ATTR static void build_codec_config(const tA2DP_LHDCV5_CIE& config_cie,
+    btav_a2dp_codec_config_t* result) {
+  if (result == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return;
+  }
+
+  // sample rate
+  result->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+  if (config_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+  if (config_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+  if (config_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+  if (config_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
+
+  // bits per sample
+  result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+  if (config_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_16)
+    result->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+  if (config_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_24)
+    result->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+  if (config_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_32)
+    result->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32;
+
+  // channel mode
+  result->channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
+  if (config_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_MONO)
+    result->channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_MONO;
+  if (config_cie.channelMode &
+      (A2DP_LHDCV5_CHANNEL_MODE_DUAL | A2DP_LHDCV5_CHANNEL_MODE_STEREO)) {
+    result->channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  }
+}
+
+A2dpCodecConfigLhdcV5Source::A2dpCodecConfigLhdcV5Source(
+    btav_a2dp_codec_priority_t codec_priority)
+: A2dpCodecConfigLhdcV5Base(BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5,
+    A2DP_VendorCodecIndexStrLhdcV5(),
+    codec_priority, true) {
+
+  // Compute the local capability
+  codec_local_capability_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+  if (a2dp_lhdcv5_source_caps.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+  }
+  if (a2dp_lhdcv5_source_caps.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+  }
+  if (a2dp_lhdcv5_source_caps.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+  }
+  if (a2dp_lhdcv5_source_caps.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
+  }
+
+  codec_local_capability_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+  if (a2dp_lhdcv5_source_caps.bitsPerSample & A2DP_LHDCV5_BIT_FMT_16) {
+    codec_local_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+  }
+  if (a2dp_lhdcv5_source_caps.bitsPerSample & A2DP_LHDCV5_BIT_FMT_24) {
+    codec_local_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+  }
+  if (a2dp_lhdcv5_source_caps.bitsPerSample & A2DP_LHDCV5_BIT_FMT_32) {
+    codec_local_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32;
+  }
+
+  codec_local_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
+  if (a2dp_lhdcv5_source_caps.channelMode & A2DP_LHDCV5_CHANNEL_MODE_MONO) {
+    codec_local_capability_.channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_MONO;
+  }
+  if (a2dp_lhdcv5_source_caps.channelMode & A2DP_LHDCV5_CHANNEL_MODE_DUAL) {
+    codec_local_capability_.channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  }
+  if (a2dp_lhdcv5_source_caps.channelMode & A2DP_LHDCV5_CHANNEL_MODE_STEREO) {
+    codec_local_capability_.channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  }
+}
+
+A2dpCodecConfigLhdcV5Source::~A2dpCodecConfigLhdcV5Source() {}
+
+bool A2dpCodecConfigLhdcV5Source::init() {
+  if (!isValid()) return false;
+
+  // Load the encoder
+  if (!A2DP_VendorLoadEncoderLhdcV5()) {
+    LOG_ERROR(LOG_TAG, "%s: cannot load the encoder", __func__);
+    return false;
+  }
+
+  return true;
+}
+
+bool A2dpCodecConfigLhdcV5Source::useRtpHeaderMarkerBit() const { return false; }
+
+//
+// Selects the best sample rate from |sampleRate|.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_best_sample_rate(uint8_t sampleRate,
+    tA2DP_LHDCV5_CIE* p_result,
+    btav_a2dp_codec_config_t* p_codec_config) {
+  if (p_codec_config == nullptr || p_result == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // LHDC V5 priority: 48K > 44.1K > 96K > 192K > others(min to max)
+  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000) {
+    p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_48000;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    return true;
+  }
+  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100) {
+    p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_44100;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    return true;
+  }
+  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000) {
+    p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_96000;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+    return true;
+  }
+  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000) {
+    p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_192000;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
+    return true;
+  }
+  return false;
+}
+
+//
+// Selects the audio sample rate from |p_codec_audio_config|.
+// |sampleRate| contains the capability.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_audio_sample_rate(
+    const btav_a2dp_codec_config_t* p_codec_audio_config, uint8_t sampleRate,
+    tA2DP_LHDCV5_CIE* p_result, btav_a2dp_codec_config_t* p_codec_config) {
+  if (p_codec_audio_config == nullptr || p_result == nullptr || p_codec_config == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // LHDC V5 priority: 48K > 44.1K > 96K > 192K > others(min to max)
+  switch (p_codec_audio_config->sample_rate) {
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000) {
+      p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_48000;
+      p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+      return true;
+    }
+    break;
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100) {
+      p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_44100;
+      p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+      return true;
+    }
+    break;
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000) {
+      p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_96000;
+      p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+      return true;
+    }
+    break;
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000) {
+      p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_192000;
+      p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
+      return true;
+    }
+    break;
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_16000:
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_24000:
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
+    break;
+  }
+  return false;
+}
+
+//
+// Selects the best bits per sample from |bitsPerSample|.
+// |bitsPerSample| contains the capability.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_best_bits_per_sample(
+    uint8_t bitsPerSample, tA2DP_LHDCV5_CIE* p_result,
+    btav_a2dp_codec_config_t* p_codec_config) {
+
+  if (p_result == nullptr || p_codec_config == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // LHDC V5 priority: 24 > 16 > 32
+  if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_24) {
+    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+    p_result->bitsPerSample = A2DP_LHDCV5_BIT_FMT_24;
+    return true;
+  }
+  if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_16) {
+    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    p_result->bitsPerSample = A2DP_LHDCV5_BIT_FMT_16;
+    return true;
+  }
+  if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_32) {
+    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32;
+    p_result->bitsPerSample = A2DP_LHDCV5_BIT_FMT_32;
+    return true;
+  }
+  return false;
+}
+
+//
+// Selects the audio bits per sample from |p_codec_audio_config|.
+// |bitsPerSample| contains the capability.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_audio_bits_per_sample(
+    const btav_a2dp_codec_config_t* p_codec_audio_config,
+    uint8_t bitsPerSample, tA2DP_LHDCV5_CIE* p_result,
+    btav_a2dp_codec_config_t* p_codec_config) {
+
+  if (p_codec_audio_config == nullptr || p_result == nullptr || p_codec_config == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // LHDC V5 priority: 24 > 16 > 32
+  switch (p_codec_audio_config->bits_per_sample) {
+  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_24) {
+      p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+      p_result->bitsPerSample = A2DP_LHDCV5_BIT_FMT_24;
+      return true;
+    }
+    break;
+  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_16) {
+      p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+      p_result->bitsPerSample = A2DP_LHDCV5_BIT_FMT_16;
+      return true;
+    }
+    break;
+  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_32) {
+      p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32;
+      p_result->bitsPerSample = A2DP_LHDCV5_BIT_FMT_32;
+      return true;
+    }
+    break;
+  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+    break;
+  }
+  return false;
+}
+
+static bool A2DP_MaxBitRatetoQualityLevelLhdcV5(uint8_t *mode, uint8_t bitrate) {
+  if (mode == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return false;
+  }
+
+  switch (bitrate & A2DP_LHDCV5_MAX_BIT_RATE_MASK) {
+  case A2DP_LHDCV5_MAX_BIT_RATE_1000K:
+    *mode = A2DP_LHDCV5_QUALITY_HIGH1;
+    return true;
+  case A2DP_LHDCV5_MAX_BIT_RATE_900K:
+    *mode = A2DP_LHDCV5_QUALITY_HIGH;
+    return true;
+  case A2DP_LHDCV5_MAX_BIT_RATE_500K:
+    *mode = A2DP_LHDCV5_QUALITY_MID;
+    return true;
+  case A2DP_LHDCV5_MAX_BIT_RATE_400K:
+    *mode = A2DP_LHDCV5_QUALITY_LOW;
+    return true;
+  }
+  return false;
+}
+
+static bool A2DP_MinBitRatetoQualityLevelLhdcV5(uint8_t *mode, uint8_t bitrate) {
+  if (mode == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return false;
+  }
+
+  switch (bitrate & A2DP_LHDCV5_MIN_BIT_RATE_MASK) {
+  case A2DP_LHDCV5_MIN_BIT_RATE_400K:
+    *mode = A2DP_LHDCV5_QUALITY_LOW;
+    return true;
+  case A2DP_LHDCV5_MIN_BIT_RATE_256K:
+    *mode = A2DP_LHDCV5_QUALITY_LOW3;
+    return true;
+  case A2DP_LHDCV5_MIN_BIT_RATE_128K:
+    *mode = A2DP_LHDCV5_QUALITY_LOW1;
+    return true;
+  case A2DP_LHDCV5_MIN_BIT_RATE_64K:
+    *mode = A2DP_LHDCV5_QUALITY_LOW0;
+    return true;
+  }
+  return false;
+}
+
+static std::string lhdcV5_sampleRate_toString(uint8_t value) {
+  switch((int)value)
+  {
+  case A2DP_LHDCV5_SAMPLING_FREQ_44100:
+    return "44100";
+  case A2DP_LHDCV5_SAMPLING_FREQ_48000:
+    return "48000";
+  case A2DP_LHDCV5_SAMPLING_FREQ_96000:
+    return "96000";
+  case A2DP_LHDCV5_SAMPLING_FREQ_192000:
+    return "192000";
+  default:
+    return "Unknown Sample Rate";
+  }
+}
+
+static std::string lhdcV5_bitPerSample_toString(uint8_t value) {
+  switch((int)value)
+  {
+  case A2DP_LHDCV5_BIT_FMT_16:
+    return "16";
+  case A2DP_LHDCV5_BIT_FMT_24:
+    return "24";
+  case A2DP_LHDCV5_BIT_FMT_32:
+    return "32";
+  default:
+    return "Unknown Bit Per Sample";
+  }
+}
+
+static std::string lhdcV5_frameLenType_toString(uint8_t value) {
+  switch((int)value)
+  {
+  case A2DP_LHDCV5_FRAME_LEN_5MS:
+    return "5ms";
+  default:
+    return "Unknown frame length type";
+  }
+}
+
+static std::string lhdcV5_MaxTargetBitRate_toString(uint8_t value) {
+  switch((int)value)
+  {
+  case A2DP_LHDCV5_MAX_BIT_RATE_900K:
+    return "900Kbps";
+  case A2DP_LHDCV5_MAX_BIT_RATE_500K:
+    return "500Kbps";
+  case A2DP_LHDCV5_MAX_BIT_RATE_400K:
+    return "400Kbps";
+  case A2DP_LHDCV5_MAX_BIT_RATE_1000K:
+    return "1000Kbps";
+  default:
+    return "Unknown Max Bit Rate";
+  }
+}
+
+static std::string lhdcV5_MinTargetBitRate_toString(uint8_t value) {
+  switch((int)value)
+  {
+  case A2DP_LHDCV5_MIN_BIT_RATE_400K:
+    return "400Kbps";
+  case A2DP_LHDCV5_MIN_BIT_RATE_256K:
+    return "256Kbps";
+  case A2DP_LHDCV5_MIN_BIT_RATE_128K:
+    return "128Kbps";
+  case A2DP_LHDCV5_MIN_BIT_RATE_64K:
+    return "64Kbps";
+  default:
+    return "Unknown Min Bit Rate";
+  }
+}
+
+static std::string lhdcV5_QualityModeBitRate_toString(uint8_t value) {
+  switch((int)value)
+  {
+  case A2DP_LHDCV5_QUALITY_ABR:
+    return "ABR";
+  case A2DP_LHDCV5_QUALITY_HIGH1:
+    return "HIGH 1 (1000 Kbps)";
+  case A2DP_LHDCV5_QUALITY_HIGH:
+    return "HIGH (900 Kbps)";
+  case A2DP_LHDCV5_QUALITY_MID:
+    return "MID (500 Kbps)";
+  case A2DP_LHDCV5_QUALITY_LOW:
+    return "LOW (400 Kbps)";
+  case A2DP_LHDCV5_QUALITY_LOW4:
+    return "LOW 4 (320 Kbps)";
+  case A2DP_LHDCV5_QUALITY_LOW3:
+    return "LOW 3 (256 Kbps)";
+  case A2DP_LHDCV5_QUALITY_LOW2:
+    return "LOW 2 (192 Kbps)";
+  case A2DP_LHDCV5_QUALITY_LOW1:
+    return "LOW 1 (128 Kbps)";
+  case A2DP_LHDCV5_QUALITY_LOW0:
+    return "LOW 0 (64 Kbps)";
+  default:
+    return "Unknown Bit Rate Mode";
+  }
+}
+
+
+bool A2dpCodecConfigLhdcV5Base::setCodecConfig(const uint8_t* p_peer_codec_info,
+    bool is_capability,
+    uint8_t* p_result_codec_config) {
+  std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
+  tA2DP_LHDCV5_CIE sink_info_cie;
+  tA2DP_LHDCV5_CIE result_config_cie;
+  uint8_t sampleRate = 0;
+  uint8_t bitsPerSample = 0;
+  bool hasFeature = false;
+  bool hasUserSet = false;
+  uint8_t qualityMode = 0;
+  uint8_t bitRateQmode = 0;
+  tA2DP_STATUS status;
+
+  const tA2DP_LHDCV5_CIE* p_a2dp_lhdcv5_caps =
+      (is_source_) ? &a2dp_lhdcv5_source_caps : &a2dp_lhdcv5_sink_caps;
+
+  // Save the internal state
+  btav_a2dp_codec_config_t saved_codec_config = codec_config_;
+  btav_a2dp_codec_config_t saved_codec_capability = codec_capability_;
+  btav_a2dp_codec_config_t saved_codec_selectable_capability =
+      codec_selectable_capability_;
+  btav_a2dp_codec_config_t saved_codec_user_config = codec_user_config_;
+  btav_a2dp_codec_config_t saved_codec_audio_config = codec_audio_config_;
+  uint8_t saved_ota_codec_config[AVDT_CODEC_SIZE];
+  uint8_t saved_ota_codec_peer_capability[AVDT_CODEC_SIZE];
+  uint8_t saved_ota_codec_peer_config[AVDT_CODEC_SIZE];
+  memcpy(saved_ota_codec_config, ota_codec_config_, sizeof(ota_codec_config_));
+  memcpy(saved_ota_codec_peer_capability, ota_codec_peer_capability_,
+      sizeof(ota_codec_peer_capability_));
+  memcpy(saved_ota_codec_peer_config, ota_codec_peer_config_,
+      sizeof(ota_codec_peer_config_));
+
+  tA2DP_CODEC_CONFIGS_PACK allCfgPack;
+  allCfgPack._codec_config_ = &codec_config_;
+  allCfgPack._codec_capability_ = &codec_capability_;
+  allCfgPack._codec_local_capability_ = &codec_local_capability_;
+  allCfgPack._codec_selectable_capability_ = &codec_selectable_capability_;
+  allCfgPack._codec_user_config_ = &codec_user_config_;
+  allCfgPack._codec_audio_config_ = &codec_audio_config_;
+
+  if (p_peer_codec_info == nullptr || p_result_codec_config == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    goto fail;
+  }
+
+  status = A2DP_ParseInfoLhdcV5(&sink_info_cie, p_peer_codec_info, is_capability, IS_SRC);
+  if (status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: can't parse peer's Sink capabilities: error = %d",
+        __func__, status);
+    goto fail;
+  }
+
+  //
+  // Build the preferred configuration
+  //
+  memset(&result_config_cie, 0, sizeof(result_config_cie));
+  result_config_cie.vendorId = p_a2dp_lhdcv5_caps->vendorId;
+  result_config_cie.codecId = p_a2dp_lhdcv5_caps->codecId;
+  result_config_cie.version = sink_info_cie.version;
+
+  //
+  // Select the sample frequency
+  //
+  sampleRate = p_a2dp_lhdcv5_caps->sampleRate & sink_info_cie.sampleRate;
+  LHDC_LOG_DBG(LOG_TAG, "%s: sampleRate Cap:{peer:0x%02X local:0x%02X result:0x%02X}",
+      __func__, sink_info_cie.sampleRate, p_a2dp_lhdcv5_caps->sampleRate, sampleRate);
+
+  codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+  switch (codec_user_config_.sample_rate) {
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100) {
+      result_config_cie.sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_44100;
+      codec_capability_.sample_rate = codec_user_config_.sample_rate;
+      codec_config_.sample_rate = codec_user_config_.sample_rate;
+    }
+    break;
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000) {
+      result_config_cie.sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_48000;
+      codec_capability_.sample_rate = codec_user_config_.sample_rate;
+      codec_config_.sample_rate = codec_user_config_.sample_rate;
+    }
+    break;
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000) {
+      result_config_cie.sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_96000;
+      codec_capability_.sample_rate = codec_user_config_.sample_rate;
+      codec_config_.sample_rate = codec_user_config_.sample_rate;
+    }
+    break;
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000) {
+      result_config_cie.sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_192000;
+      codec_capability_.sample_rate = codec_user_config_.sample_rate;
+      codec_config_.sample_rate = codec_user_config_.sample_rate;
+    }
+    break;
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_16000:
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_24000:
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
+    codec_capability_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+    codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+    break;
+  }
+
+  // Select the sample frequency if there is no user preference
+  do {
+    // Compute the selectable capability
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100)
+      codec_selectable_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000)
+      codec_selectable_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000)
+      codec_selectable_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000)
+      codec_selectable_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
+
+    if (codec_config_.sample_rate != BTAV_A2DP_CODEC_SAMPLE_RATE_NONE) {
+      LHDC_LOG_DBG(LOG_TAG, "%s: sample rate configured successfully 0x%02X",
+          __func__, result_config_cie.sampleRate);
+      break;
+    }
+    // Ignore follows if codec config is setup, otherwise pick a best one from default rules
+
+    // Compute the common capability
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
+
+    // No user preference - try the codec audio config
+    if (select_audio_sample_rate(&codec_audio_config_, sampleRate,
+        &result_config_cie, &codec_config_)) {
+      LHDC_LOG_DBG(LOG_TAG, "%s: select sample rate from audio: 0x%02X", __func__,
+          result_config_cie.sampleRate);
+      break;
+    }
+
+    // No user preference - try the default config
+    if (select_best_sample_rate(
+        a2dp_lhdcv5_source_default_caps.sampleRate & sink_info_cie.sampleRate,
+        &result_config_cie, &codec_config_)) {
+      LHDC_LOG_DBG(LOG_TAG, "%s: select sample rate from default: 0x%02X", __func__,
+          result_config_cie.sampleRate);
+      break;
+    }
+
+    // No user preference - use the best match
+    if (select_best_sample_rate(sampleRate, &result_config_cie,
+        &codec_config_)) {
+      LHDC_LOG_DBG(LOG_TAG, "%s: select sample rate from best match: 0x%02X", __func__,
+          result_config_cie.sampleRate);
+      break;
+    }
+  } while (false);
+
+  if (codec_config_.sample_rate == BTAV_A2DP_CODEC_SAMPLE_RATE_NONE) {
+    LOG_ERROR(LOG_TAG,
+        "%s: cannot match sample frequency: local caps = 0x%02X "
+        "peer info = 0x%02X",
+        __func__, p_a2dp_lhdcv5_caps->sampleRate, sink_info_cie.sampleRate);
+    goto fail;
+  }
+  LHDC_LOG_DBG(LOG_TAG, "%s: => sample rate(0x%02X) = %s", __func__,
+      result_config_cie.sampleRate,
+      lhdcV5_sampleRate_toString(result_config_cie.sampleRate).c_str());
+
+  //
+  // Select the bits per sample
+  //
+  bitsPerSample = p_a2dp_lhdcv5_caps->bitsPerSample & sink_info_cie.bitsPerSample;
+  LHDC_LOG_DBG(LOG_TAG, "%s: bitsPerSample:{peer:0x%02X local:0x%02X result:0x%02X}",
+      __func__, sink_info_cie.bitsPerSample, p_a2dp_lhdcv5_caps->bitsPerSample, bitsPerSample);
+
+  codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+  switch (codec_user_config_.bits_per_sample) {
+  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_16) {
+      result_config_cie.bitsPerSample = A2DP_LHDCV5_BIT_FMT_16;
+      codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
+      codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
+    }
+    break;
+  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_24) {
+      result_config_cie.bitsPerSample = A2DP_LHDCV5_BIT_FMT_24;
+      codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
+      codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
+    }
+    break;
+  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_32) {
+      result_config_cie.bitsPerSample = A2DP_LHDCV5_BIT_FMT_32;
+      codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
+      codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
+    }
+    break;
+  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+    result_config_cie.bitsPerSample = A2DP_LHDCV5_BIT_FMT_NS;
+    codec_capability_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+    codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+    break;
+  }
+
+  // Select the bits per sample if there is no user preference
+  do {
+    // Compute the selectable capability
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_16)
+      codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_24)
+      codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_32)
+      codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32;
+
+    if (codec_config_.bits_per_sample != BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE) {
+      LHDC_LOG_DBG(LOG_TAG, "%s: bit_per_sample configured successfully 0x%02X",
+          __func__, result_config_cie.bitsPerSample);
+      break;
+    }
+    // Ignore follows if codec config is setup, otherwise pick a best one from default rules
+
+    // Compute the common capability
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_16)
+      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_24)
+      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_32)
+      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32;
+
+    // No user preference - the the codec audio config
+    if (select_audio_bits_per_sample(&codec_audio_config_, bitsPerSample,
+        &result_config_cie, &codec_config_)) {
+      LHDC_LOG_DBG(LOG_TAG, "%s: select bit per sample from audio: 0x%02X", __func__,
+          result_config_cie.bitsPerSample);
+      break;
+    }
+
+    // No user preference - try the default config
+    if (select_best_bits_per_sample(
+        a2dp_lhdcv5_source_default_caps.bitsPerSample & sink_info_cie.bitsPerSample,
+        &result_config_cie, &codec_config_)) {
+      LHDC_LOG_DBG(LOG_TAG, "%s: select bit per sample from default: 0x%02X", __func__,
+          result_config_cie.bitsPerSample);
+      break;
+    }
+
+    // No user preference - use the best match
+    if (select_best_bits_per_sample(bitsPerSample, &result_config_cie,
+        &codec_config_)) {
+      LHDC_LOG_DBG(LOG_TAG, "%s: select sample rate from best match: 0x%02X", __func__,
+          result_config_cie.bitsPerSample);
+      break;
+    }
+  } while (false);
+
+  if (codec_config_.bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE) {
+    LOG_ERROR(LOG_TAG,
+        "%s: cannot match bits per sample: local caps = 0x%02X "
+        "peer info = 0x%02X",
+        __func__, p_a2dp_lhdcv5_caps->bitsPerSample,
+        sink_info_cie.bitsPerSample);
+    goto fail;
+  }
+  LHDC_LOG_DBG(LOG_TAG, "%s: => bit per sample(0x%02X) = %s", __func__,
+      result_config_cie.bitsPerSample,
+      lhdcV5_bitPerSample_toString(result_config_cie.bitsPerSample).c_str());
+
+  // Select the channel mode
+  codec_user_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  codec_selectable_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  codec_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  LHDC_LOG_DBG(LOG_TAG, "%s: channelMode = Only supported stereo", __func__);
+
+  // Update frameLenType
+  result_config_cie.frameLenType = sink_info_cie.frameLenType;
+  LHDC_LOG_DBG(LOG_TAG, "%s: => frame length type(0x%02X) = %s", __func__,
+      result_config_cie.frameLenType,
+      lhdcV5_frameLenType_toString(result_config_cie.frameLenType).c_str());
+
+  // Update maxTargetBitrate
+  result_config_cie.maxTargetBitrate = sink_info_cie.maxTargetBitrate;
+  LHDC_LOG_DBG(LOG_TAG, "%s: => peer Max Bit Rate(0x%02X) = %s", __func__,
+      result_config_cie.maxTargetBitrate,
+      lhdcV5_MaxTargetBitRate_toString(result_config_cie.maxTargetBitrate).c_str());
+
+  // Update minTargetBitrate
+  result_config_cie.minTargetBitrate = sink_info_cie.minTargetBitrate;
+  LHDC_LOG_DBG(LOG_TAG, "%s: => peer Min Bit Rate(0x%02X) = %s", __func__,
+      result_config_cie.minTargetBitrate,
+      lhdcV5_MinTargetBitRate_toString(result_config_cie.minTargetBitrate).c_str());
+
+  //
+  // Update Feature/Capabilities to A2DP specifics
+  //
+  /*******************************************
+   * for features that can be enabled by user-control, exam features tag on the specific.
+   * current user-control enabling features:
+   *    Feature: AR
+   *    Feature: LL
+   *******************************************/
+  //features on specific 3
+  if ((codec_user_config_.codec_specific_3 & A2DP_LHDC_VENDOR_FEATURE_MASK) != A2DP_LHDC_FEATURE_MAGIC_NUM)
+  {
+    // reset the specific and apply tag
+    codec_user_config_.codec_specific_3 = A2DP_LHDC_FEATURE_MAGIC_NUM;
+
+    // get previous status of user-control enabling features from codec_config, then restore to user settings
+    //
+    // Feature: AR
+    hasUserSet = A2DP_IsFeatureInCodecConfigLhdcV5(&allCfgPack, LHDCV5_FEATURE_CODE_AR);
+    A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+        &allCfgPack,
+        LHDCV5_FEATURE_CODE_AR,
+        A2DP_LHDC_TO_A2DP_CODEC_USER_,
+        (hasUserSet?true:false));
+    LHDC_LOG_DBG(LOG_TAG, "%s: LHDC features tag check fail, reset UI status[AR] => %s", __func__, hasUserSet?"true":"false");
+  }
+
+  /*************************************************
+   *  quality mode: caps-control enabling
+   *************************************************/
+  if ((codec_user_config_.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) != A2DP_LHDC_QUALITY_MAGIC_NUM) {
+    codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDCV5_QUALITY_ABR;
+    LHDC_LOG_DBG(LOG_TAG, "%s: tag not match, use default Quality Mode: ABR", __func__);
+  }
+  qualityMode = (uint8_t)codec_user_config_.codec_specific_1 & A2DP_LHDCV5_QUALITY_MASK;
+
+  /*******************************************
+   *  JAS: caps-control enabling
+   *******************************************/
+  {
+    hasFeature = (p_a2dp_lhdcv5_caps->hasFeatureJAS & sink_info_cie.hasFeatureJAS);
+    // reset first
+    result_config_cie.hasFeatureJAS = false;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+        &allCfgPack,
+        LHDCV5_FEATURE_CODE_JAS,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ |
+            A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
+            false);
+    // update
+    hasUserSet = true;  //caps-control enabling case => always true
+    if (hasFeature && hasUserSet) {
+      result_config_cie.hasFeatureJAS = true;
+      A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+          &allCfgPack,
+          LHDCV5_FEATURE_CODE_JAS,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+              true);
+    }
+    LHDC_LOG_DBG(LOG_TAG, "%s: featureJAS: enabled? <%s> {Peer:0x%02X Local:0x%02X User:%s}", __func__,
+        (result_config_cie.hasFeatureJAS?"Y":"N"),
+        sink_info_cie.hasFeatureJAS,
+        p_a2dp_lhdcv5_caps->hasFeatureJAS,
+        (hasUserSet?"Y":"N"));
+  }
+
+  /*******************************************
+   *  AR: user-control/peer-OTA control enabling
+   *******************************************/
+  {
+    hasFeature = (p_a2dp_lhdcv5_caps->hasFeatureAR & sink_info_cie.hasFeatureAR);
+    // reset first
+    result_config_cie.hasFeatureAR = false;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+        &allCfgPack,
+        LHDCV5_FEATURE_CODE_AR,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ | A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
+        false);
+    // update
+    hasUserSet = A2DP_IsFeatureInUserConfigLhdcV5(&allCfgPack, LHDCV5_FEATURE_CODE_AR);
+
+    // default AR turning on condition: (customizable)
+    //  1. both sides have the capabilities
+    //  2. (UI on SRC side turns on) || (SNK set AR_ON in codec info)
+    if (hasFeature && (hasUserSet || sink_info_cie.featureOnAR)) {
+      result_config_cie.hasFeatureAR = true;  //decide to turn on feature in encoder
+      A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+          &allCfgPack,
+          LHDCV5_FEATURE_CODE_AR,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+              true);
+
+      // reconfigure (48KHz sample rate + 24 bits per sample) to run AR
+      if (codec_user_config_.sample_rate != BTAV_A2DP_CODEC_SAMPLE_RATE_48000) {
+        codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+        codec_capability_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+        codec_user_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+        result_config_cie.sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_48000;
+        LHDC_LOG_DBG(LOG_TAG, "%s: set 48KHz sample Rate for running AR", __func__);
+      }
+
+      if (codec_user_config_.bits_per_sample != BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+        codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+        codec_capability_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+        codec_user_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+        result_config_cie.bitsPerSample = A2DP_LHDCV5_BIT_FMT_24;
+        LHDC_LOG_DBG(LOG_TAG, "%s: set 24 bits per sample 24 for running AR", __func__);
+      }
+    }
+    LHDC_LOG_DBG(LOG_TAG, "%s: featureAR: enabled? <%s> {Peer:0x%02X Local:0x%02X User:%s AR_ON:%s}", __func__,
+        (result_config_cie.hasFeatureAR?"Y":"N"),
+        sink_info_cie.hasFeatureAR,
+        p_a2dp_lhdcv5_caps->hasFeatureAR,
+        (hasUserSet?"Y":"N"),
+        (sink_info_cie.featureOnAR)?"Y":"N");
+  }
+
+  /*******************************************
+   *  META: caps-control enabling
+   *******************************************/
+  {
+    hasFeature = (p_a2dp_lhdcv5_caps->hasFeatureMETA & sink_info_cie.hasFeatureMETA);
+    // reset first
+    result_config_cie.hasFeatureMETA = false;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+        &allCfgPack,
+        LHDCV5_FEATURE_CODE_META,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ | A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
+        false);
+    // update
+    hasUserSet = true;  //caps-control enabling, always true
+    if (hasFeature && hasUserSet) {
+      result_config_cie.hasFeatureMETA = true;
+      A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+          &allCfgPack,
+          LHDCV5_FEATURE_CODE_META,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+              true);
+    }
+    LHDC_LOG_DBG(LOG_TAG, "%s: featureMETA: enabled? <%s> {Peer:0x%02X Local:0x%02X User:%s}", __func__,
+        (result_config_cie.hasFeatureMETA?"Y":"N"),
+        sink_info_cie.hasFeatureMETA,
+        p_a2dp_lhdcv5_caps->hasFeatureMETA,
+        (hasUserSet?"Y":"N"));
+  }
+
+  /*******************************************
+   *  Low Latency: user-control enabling
+   *******************************************/
+  {
+    hasFeature = (p_a2dp_lhdcv5_caps->hasFeatureLL & sink_info_cie.hasFeatureLL);
+    // reset first
+    result_config_cie.hasFeatureLL = false;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+        &allCfgPack,
+        LHDCV5_FEATURE_CODE_LL,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ | A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
+        false);
+    // update
+    hasUserSet = A2DP_IsFeatureInUserConfigLhdcV5(&allCfgPack, LHDCV5_FEATURE_CODE_LL);
+    if (hasFeature && hasUserSet) {
+      result_config_cie.hasFeatureLL = true;
+      A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+          &allCfgPack,
+          LHDCV5_FEATURE_CODE_LL,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+              true);
+    }
+    LHDC_LOG_DBG(LOG_TAG, "%s: featureLL: enabled? <%s> {Peer:0x%02X Local:0x%02X User:%s}", __func__,
+        (result_config_cie.hasFeatureLL?"Y":"N"),
+        sink_info_cie.hasFeatureLL,
+        p_a2dp_lhdcv5_caps->hasFeatureLL,
+        (hasUserSet?"Y":"N"));
+  }
+
+  /*******************************************
+   *  LLESS: caps-control enabling
+   *******************************************/
+  {
+    hasFeature = (p_a2dp_lhdcv5_caps->hasFeatureLLESS & sink_info_cie.hasFeatureLLESS);
+    // reset first
+    result_config_cie.hasFeatureLLESS = false;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+        &allCfgPack,
+        LHDCV5_FEATURE_CODE_LLESS,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ | A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
+        false);
+    // update
+    //hasUserSet = true;  //caps-control enabling, always true
+    hasUserSet = A2DP_IsFeatureInUserConfigLhdcV5(&allCfgPack, LHDCV5_FEATURE_CODE_LLESS);  //UI-control
+    if (hasFeature && hasUserSet) {
+      result_config_cie.hasFeatureLLESS = true;
+      A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+          &allCfgPack,
+          LHDCV5_FEATURE_CODE_LLESS,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+              true);
+    }
+    LHDC_LOG_DBG(LOG_TAG, "%s: featureLLESS: enabled? <%s> {Peer:0x%02X Local:0x%02X User:%s}", __func__,
+        (result_config_cie.hasFeatureLLESS?"Y":"N"),
+        sink_info_cie.hasFeatureLLESS,
+        p_a2dp_lhdcv5_caps->hasFeatureLLESS,
+        (hasUserSet?"Y":"N"));
+  }
+
+
+  //
+  // quality mode re-adjustion in non-ABR cases
+  //
+  if (qualityMode != A2DP_LHDCV5_QUALITY_ABR) {
+    // get corresponding quality mode of the max target bit rate
+    if (!A2DP_MaxBitRatetoQualityLevelLhdcV5(&bitRateQmode, result_config_cie.maxTargetBitrate)) {
+      LOG_ERROR(LOG_TAG, "%s: get quality mode from maxTargetBitrate error", __func__);
+      goto fail;
+    }
+    // downgrade audio quality according to the max target bit rate
+    if (qualityMode > bitRateQmode) {
+      codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | bitRateQmode;
+      qualityMode = bitRateQmode;
+      LHDC_LOG_DBG(LOG_TAG, "%s: downgrade quality mode to 0x%02X", __func__, qualityMode);
+    }
+
+    // get corresponding quality mode of the min target bit rate
+    if (!A2DP_MinBitRatetoQualityLevelLhdcV5(&bitRateQmode, result_config_cie.minTargetBitrate)) {
+      LOG_ERROR(LOG_TAG, "%s: get quality mode from minTargetBitrate error", __func__);
+      goto fail;
+    }
+    // upgrade audio quality according to the min target bit rate
+    if (qualityMode < bitRateQmode) {
+      codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | bitRateQmode;
+      qualityMode = bitRateQmode;
+      LHDC_LOG_DBG(LOG_TAG, "%s: upgrade quality mode to 0x%02X", __func__, qualityMode);
+    }
+
+    // specification rule: if sample rate >= 96KHz && qualityMode < 256kbps,
+    //  upgrade qualityMode to 256Kbps(LOW3)
+    if (result_config_cie.sampleRate == A2DP_LHDCV5_SAMPLING_FREQ_96000 ||
+        result_config_cie.sampleRate == A2DP_LHDCV5_SAMPLING_FREQ_192000) {
+      if (qualityMode < A2DP_LHDCV5_QUALITY_LOW3) {
+        codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDCV5_QUALITY_LOW3;
+        qualityMode = A2DP_LHDCV5_QUALITY_LOW3;
+        LHDC_LOG_DBG(LOG_TAG, "%s: upgrade quality mode to 0x%02X due to higher sample rates", __func__, qualityMode);
+      }
+    }
+
+    // specification rule: if (sample rate == 44.1/48KHz && qualityMode == 1000kbps(HIGH 1)),
+    //  downgrade qualityMode to 900kbps(HIGH)
+    if (result_config_cie.sampleRate == A2DP_LHDCV5_SAMPLING_FREQ_44100 ||
+        result_config_cie.sampleRate == A2DP_LHDCV5_SAMPLING_FREQ_48000) {
+      if (qualityMode == A2DP_LHDCV5_QUALITY_HIGH1) {
+        codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDCV5_QUALITY_HIGH;
+        qualityMode = A2DP_LHDCV5_QUALITY_HIGH;
+        LHDC_LOG_DBG(LOG_TAG, "%s: downgrade quality mode to 0x%02X due to lower sample rates", __func__, qualityMode);
+      }
+    }
+  }
+
+  LHDC_LOG_DBG(LOG_TAG, "%s: => final quality mode(0x%02X) = %s", __func__,
+      qualityMode,
+      lhdcV5_QualityModeBitRate_toString(qualityMode).c_str());
+
+  /* Setup final nego result config to peer */
+  if (A2DP_BuildInfoLhdcV5(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
+      p_result_codec_config) != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: A2DP build info fail", __func__);
+    goto fail;
+  }
+
+  //
+  // Copy the codec-specific fields if they are not zero
+  //
+  if (codec_user_config_.codec_specific_1 != 0)
+    codec_config_.codec_specific_1 = codec_user_config_.codec_specific_1;
+  if (codec_user_config_.codec_specific_2 != 0)
+    codec_config_.codec_specific_2 = codec_user_config_.codec_specific_2;
+  if (codec_user_config_.codec_specific_3 != 0)
+    codec_config_.codec_specific_3 = codec_user_config_.codec_specific_3;
+  if (codec_user_config_.codec_specific_4 != 0)
+    codec_config_.codec_specific_4 = codec_user_config_.codec_specific_4;
+
+  // Create a local copy of the peer codec capability, and the
+  // result codec config.
+  if (is_capability) {
+    status = A2DP_BuildInfoLhdcV5(AVDT_MEDIA_TYPE_AUDIO, &sink_info_cie,
+        ota_codec_peer_capability_);
+  } else {
+    status = A2DP_BuildInfoLhdcV5(AVDT_MEDIA_TYPE_AUDIO, &sink_info_cie,
+        ota_codec_peer_config_);
+  }
+  CHECK(status == A2DP_SUCCESS);
+
+  status = A2DP_BuildInfoLhdcV5(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
+      ota_codec_config_);
+  CHECK(status == A2DP_SUCCESS);
+  return true;
+
+  fail:
+  // Restore the internal state
+  codec_config_ = saved_codec_config;
+  codec_capability_ = saved_codec_capability;
+  codec_selectable_capability_ = saved_codec_selectable_capability;
+  codec_user_config_ = saved_codec_user_config;
+  codec_audio_config_ = saved_codec_audio_config;
+  memcpy(ota_codec_config_, saved_ota_codec_config, sizeof(ota_codec_config_));
+  memcpy(ota_codec_peer_capability_, saved_ota_codec_peer_capability,
+      sizeof(ota_codec_peer_capability_));
+  memcpy(ota_codec_peer_config_, saved_ota_codec_peer_config,
+      sizeof(ota_codec_peer_config_));
+  return false;
+}
+
+bool A2dpCodecConfigLhdcV5Base::setPeerCodecCapabilities(
+    const uint8_t* p_peer_codec_capabilities) {
+  std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
+  tA2DP_LHDCV5_CIE peer_info_cie;
+  uint8_t sampleRate;
+  uint8_t bits_per_sample;
+  tA2DP_STATUS status;
+  const tA2DP_LHDCV5_CIE* p_a2dp_lhdcv5_caps =
+      (is_source_) ? &a2dp_lhdcv5_source_caps : &a2dp_lhdcv5_sink_caps;
+
+  // Save the internal state
+  btav_a2dp_codec_config_t saved_codec_selectable_capability =
+      codec_selectable_capability_;
+  uint8_t saved_ota_codec_peer_capability[AVDT_CODEC_SIZE];
+  memcpy(saved_ota_codec_peer_capability, ota_codec_peer_capability_,
+      sizeof(ota_codec_peer_capability_));
+
+  if (p_peer_codec_capabilities == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    goto fail;
+  }
+
+  status = A2DP_ParseInfoLhdcV5(&peer_info_cie, p_peer_codec_capabilities, true, IS_SRC);
+  if (status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: can't parse peer's capabilities: error = %d",
+        __func__, status);
+    goto fail;
+  }
+
+  // Compute the selectable capability - sample rate
+  sampleRate = p_a2dp_lhdcv5_caps->sampleRate & peer_info_cie.sampleRate;
+  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100) {
+    codec_selectable_capability_.sample_rate |=
+        BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+  }
+  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000) {
+    codec_selectable_capability_.sample_rate |=
+        BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+  }
+  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000) {
+    codec_selectable_capability_.sample_rate |=
+        BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+  }
+  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000) {
+    codec_selectable_capability_.sample_rate |=
+        BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
+  }
+
+  // Compute the selectable capability - bits per sample
+  bits_per_sample = p_a2dp_lhdcv5_caps->bitsPerSample & peer_info_cie.bitsPerSample;
+  if (bits_per_sample & A2DP_LHDCV5_BIT_FMT_16) {
+    codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+  }
+  if (bits_per_sample & A2DP_LHDCV5_BIT_FMT_24) {
+    codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+  }
+  if (bits_per_sample & A2DP_LHDCV5_BIT_FMT_32) {
+    codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32;
+  }
+
+  // Compute the selectable capability - channel mode
+  codec_selectable_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+
+  status = A2DP_BuildInfoLhdcV5(AVDT_MEDIA_TYPE_AUDIO, &peer_info_cie,
+      ota_codec_peer_capability_);
+  CHECK(status == A2DP_SUCCESS);
+  return true;
+
+  fail:
+  // Restore the internal state
+  codec_selectable_capability_ = saved_codec_selectable_capability;
+  memcpy(ota_codec_peer_capability_, saved_ota_codec_peer_capability,
+      sizeof(ota_codec_peer_capability_));
+  return false;
+}
+
+////////
+// LHDC Extended API Start
+////////
+static bool swapInt64toByteArray(uint8_t *byteArray, int64_t integer64) {
+  if (byteArray == nullptr) {
+    LHDC_LOG_DBG(LOG_TAG, "%s: null ptr", __func__);
+    return false;
+  }
+
+  byteArray[7] = ((integer64 & 0x00000000000000FF) >> 0);
+  byteArray[6] = ((integer64 & 0x000000000000FF00) >> 8);
+  byteArray[5] = ((integer64 & 0x0000000000FF0000) >> 16);
+  byteArray[4] = ((integer64 & 0x00000000FF000000) >> 24);
+  byteArray[3] = ((integer64 & 0x000000FF00000000) >> 32);
+  byteArray[2] = ((integer64 & 0x0000FF0000000000) >> 40);
+  byteArray[1] = ((integer64 & 0x00FF000000000000) >> 48);
+  byteArray[0] = ((integer64 & 0xFF00000000000000) >> 56);
+
+  return true;
+}
+
+static bool A2DP_LhdcV5GetFeatureInfoV2(uint8_t *featVector) {
+  uint8_t featNum = 0, idx = 0;
+
+  if(featVector == nullptr) {
+    LHDC_LOG_DBG(LOG_TAG, "%s: null buffer!", __func__);
+    return false;
+  }
+
+  featNum = (sizeof(a2dp_lhdcv5_source_spec_all) / sizeof(tA2DP_LHDC_FEATURE_POS) );
+  if (featNum <= 0) {
+    //LHDC_LOG_DBG(LOG_TAG, "%s: no any features recorded in specifics, nothing to do", __func__);
+    return true;
+  }
+
+  /* 2 bytes per info tuple
+   *  byte0:      featureCode
+   *  byte1[7-6]: inSpecBank
+   *  byte1[5-0]: bitPos in decimal(0~31)
+   */
+  for(int i=0; i<featNum; i++) {
+    featVector[idx] = a2dp_lhdcv5_source_spec_all[i].featureCode;
+    featVector[idx + 1] = (a2dp_lhdcv5_source_spec_all[i].inSpecBank | a2dp_lhdcv5_source_spec_all[i].bitPos);
+    idx += 2;
+  }
+
+  return true;
+}
+
+static bool A2DP_LhdcV5GetA2DPSpecificV2(btav_a2dp_codec_config_t *a2dpCfg,
+    uint8_t *buf, uint32_t len) {
+  if (len < LHDCV5_EXTEND_API_A2DP_SPEC_TOTAL_SIZE_V2) {
+    LHDC_LOG_DBG(LOG_TAG, "%s: payload size too small %d ",__func__, len);
+    return false;
+  }
+
+  /* retrieve specifics value */
+  if ( !(
+      swapInt64toByteArray(&buf[LHDCV5_EXTEND_API_A2DP_SPEC1_HEAD_V2], a2dpCfg->codec_specific_1) &&
+      swapInt64toByteArray(&buf[LHDCV5_EXTEND_API_A2DP_SPEC2_HEAD_V2], a2dpCfg->codec_specific_2) &&
+      swapInt64toByteArray(&buf[LHDCV5_EXTEND_API_A2DP_SPEC3_HEAD_V2], a2dpCfg->codec_specific_3) &&
+      swapInt64toByteArray(&buf[LHDCV5_EXTEND_API_A2DP_SPEC4_HEAD_V2], a2dpCfg->codec_specific_4)
+  )) {
+    LHDC_LOG_DBG(LOG_TAG, "%s: copy specifics error",  __func__);
+    return false;
+  }
+
+  /* retrieve bitmap info of LHDCv5 features */
+  if (!A2DP_LhdcV5GetFeatureInfoV2(&buf[LHDCV5_EXTEND_API_A2DP_SPEC_INFO_HEAD_V2])) {
+    LHDC_LOG_DBG(LOG_TAG, "%s: get feature info error!",  __func__);
+    return false;
+  }
+  return true;
+}
+
+static int A2DP_getEncoderExtendFuncA2DPTypeLhdcV5(A2dpCodecConfig* codecCfg,
+    uint8_t *buf, uint32_t buflen) {
+  btav_a2dp_codec_config_t codec_config_tmp;
+  uint32_t exFuncVer = 0;
+  uint32_t exFuncCode = 0;
+
+  //check buf size
+  if (buflen < (LHDCV5_EXTEND_API_A2DP_SPEC_VER_SIZE + LHDCV5_EXTEND_API_A2DP_SPEC_CODE_SIZE)) {
+    LHDC_LOG_DBG(LOG_TAG, "%s: buf len too small %d",  __func__, buflen);
+    return BT_STATUS_FAIL;
+  }
+
+  exFuncVer = (((unsigned int) buf[3]) & ((unsigned int)0xff)) |
+      ((((unsigned int) buf[2]) & ((unsigned int)0xff)) << 8)  |
+      ((((unsigned int) buf[1]) & ((unsigned int)0xff)) << 16) |
+      ((((unsigned int) buf[0]) & ((unsigned int)0xff)) << 24);
+  exFuncCode = (((unsigned int) buf[7]) & ((unsigned int)0xff)) |
+      ((((unsigned int) buf[6]) & ((unsigned int)0xff)) << 8)  |
+      ((((unsigned int) buf[5]) & ((unsigned int)0xff)) << 16) |
+      ((((unsigned int) buf[4]) & ((unsigned int)0xff)) << 24);
+
+  switch (exFuncCode) {
+  case LHDCV5_EXTEND_API_A2DP_SPEC_CODE:
+    switch(buf[LHDCV5_EXTEND_API_A2DP_SPEC_ID_HEAD]) {
+    case LHDCV5_EXTEND_API_A2DP_SPEC_CFG:
+      codec_config_tmp = codecCfg->getCodecConfig();
+      break;
+    case LHDCV5_EXTEND_API_A2DP_SPEC_CAP:
+      codec_config_tmp = codecCfg->getCodecCapability();
+      break;
+    case LHDCV5_EXTEND_API_A2DP_SPEC_LOCAL_CAP:
+      codec_config_tmp = codecCfg->getCodecLocalCapability();
+      break;
+    case LHDCV5_EXTEND_API_A2DP_SPEC_SELECT_CAP:
+      codec_config_tmp = codecCfg->getCodecSelectableCapability();
+      break;
+    case LHDCV5_EXTEND_API_A2DP_SPEC_USER_CFG:
+      codec_config_tmp = codecCfg->getCodecUserConfig();
+      break;
+    case LHDCV5_EXTEND_API_A2DP_SPEC_AUDIO_CFG:
+      codec_config_tmp = codecCfg->getCodecAudioConfig();
+      break;
+    default:
+      LHDC_LOG_DBG(LOG_TAG, "%s: unknown a2dp codec config",  __func__);
+      return BT_STATUS_FAIL;
+    }
+    break;
+    default:
+      LHDC_LOG_DBG(LOG_TAG, "%s: invalid ext API command(0x%X)",  __func__, exFuncCode);
+      return BT_STATUS_FAIL;
+  }
+
+  switch (exFuncVer) {
+  case LHDCV5_EXTEND_API_A2DP_SPEC_VER2:
+    if (!A2DP_LhdcV5GetA2DPSpecificV2(&codec_config_tmp, buf, buflen)) {
+      LHDC_LOG_DBG(LOG_TAG, "%s: get specifics error",  __func__);
+      return BT_STATUS_FAIL;
+    }
+    break;
+  default:
+    LHDC_LOG_DBG(LOG_TAG, "%s: invalid ext API version(0x%X)",  __func__, exFuncVer);
+    return BT_STATUS_FAIL;
+  }
+
+  return BT_STATUS_SUCCESS;
+}
+
+int A2dpCodecConfigLhdcV5Base::getLhdcExtendAPIVersion(A2dpCodecConfig* peerCodec,
+    const char* buf, const int clen) {
+  int result = BT_STATUS_FAIL;
+
+  if (peerCodec == nullptr || buf == nullptr || clen <= 0) {
+    LHDC_LOG_DBG(LOG_TAG, "%s: invalid input clen %d", __func__, clen);
+    return BT_STATUS_FAIL;
+  }
+
+  LOG_VERBOSE(LOG_TAG, "%s: %s:(buf:%p clen:%d)",
+      __func__, ((is_source_)?"SRC" :"SNK"), buf, clen);
+
+  if (is_source_) {
+    result = A2dpCodecConfigLhdcV5Source::getEncoderExtendFuncUserApiVer(buf, clen);
+  } else {
+    LHDC_LOG_DBG(LOG_TAG, "%s: sink not supported", __func__);
+    return BT_STATUS_FAIL;
+  }
+
+  return result;
+}
+
+int A2dpCodecConfigLhdcV5Base::getLhdcExtendAPIConfig(A2dpCodecConfig* peerCodec,
+    const char* buf, const int clen) {
+  int result = BT_STATUS_FAIL;
+  uint8_t *pucBuf = (uint8_t *) buf;
+
+  if (peerCodec == nullptr || buf == nullptr || clen <= 0) {
+    LHDC_LOG_DBG(LOG_TAG, "%s: invalid input clen %d", __func__, clen);
+    return BT_STATUS_FAIL;
+  }
+
+  LOG_VERBOSE(LOG_TAG, "%s: %s:(buf:%p clen:%d)",
+      __func__, ((is_source_)?"SRC" :"SNK"), buf, clen);
+
+  if (is_source_) {
+    if (buf[LHDCV5_EXTEND_API_A2DP_SPEC_CODE_HEAD] == LHDCV5_EXTEND_API_CODE_A2DP_TYPE ) {
+      result = A2DP_getEncoderExtendFuncA2DPTypeLhdcV5(peerCodec, pucBuf, (uint32_t)clen);
+    } else if (buf[LHDCV5_EXTEND_API_A2DP_SPEC_CODE_HEAD] == LHDCV5_EXTEND_API_CODE_LIB_TYPE ){
+      result = A2dpCodecConfigLhdcV5Source::getEncoderExtendFuncUserConfig(buf, clen);
+    }
+  } else {
+    LHDC_LOG_DBG(LOG_TAG, "%s: sink not supported", __func__);
+    return BT_STATUS_FAIL;
+  }
+
+  return result;
+}
+
+int A2dpCodecConfigLhdcV5Base::setLhdcExtendAPIConfig(A2dpCodecConfig* peerCodec,
+    const char* buf, const int clen) {
+  int result = BT_STATUS_FAIL;
+
+  if (peerCodec == nullptr || buf == nullptr || clen <= 0) {
+    LHDC_LOG_DBG(LOG_TAG, "%s: invalid input clen %d", __func__, clen);
+    return BT_STATUS_FAIL;
+  }
+
+  LOG_VERBOSE(LOG_TAG, "%s: %s:(buf:%p clen:%d)",
+      __func__, ((is_source_)?"SRC" :"SNK"), buf, clen);
+
+  if (is_source_) {
+    result = A2dpCodecConfigLhdcV5Source::setEncoderExtendFuncUserConfig(buf, clen);
+  } else {
+    LHDC_LOG_DBG(LOG_TAG, "%s: sink not supported", __func__);
+    return BT_STATUS_FAIL;
+  }
+
+  return result;
+}
+
+bool A2dpCodecConfigLhdcV5Base::setLhdcExtendAPIData(A2dpCodecConfig* peerCodec,
+    const char* buf, const int clen) {
+
+  if (peerCodec == nullptr || buf == nullptr || clen <= 0) {
+    LHDC_LOG_DBG(LOG_TAG, "%s: invalid input clen %d", __func__, clen);
+    return BT_STATUS_FAIL;
+  }
+
+  LOG_VERBOSE(LOG_TAG, "%s: %s:(buf:%p clen:%d)",
+      __func__, ((is_source_)?"SRC" :"SNK"), buf, clen);
+
+  if (is_source_) {
+    A2dpCodecConfigLhdcV5Source::setEncoderExtendFuncUserData(buf, clen);
+    return true;
+  } else {
+    LHDC_LOG_DBG(LOG_TAG, "%s: sink not supported", __func__);
+    return false;
+  }
+}
+////////
+// LHDC Extended API End
+////////
+
+////////
+//    class implementation for LHDC V5 Sink
+////////
+A2dpCodecConfigLhdcV5Sink::A2dpCodecConfigLhdcV5Sink(
+    btav_a2dp_codec_priority_t codec_priority)
+: A2dpCodecConfigLhdcV5Base(BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5,
+    A2DP_VendorCodecIndexStrLhdcV5Sink(),
+    codec_priority, false) {}
+
+A2dpCodecConfigLhdcV5Sink::~A2dpCodecConfigLhdcV5Sink() {}
+
+bool A2dpCodecConfigLhdcV5Sink::init() {
+  if (!isValid()) return false;
+
+  // Load the decoder
+  if (!A2DP_VendorLoadDecoderLhdcV5()) {
+    LOG_ERROR(LOG_TAG, "%s: cannot load the decoder", __func__);
+    return false;
+  }
+
+  return true;
+}
+
+bool A2dpCodecConfigLhdcV5Sink::useRtpHeaderMarkerBit() const {
+  // TODO: This method applies only to Source codecs
+  return false;
+}
+
+bool A2dpCodecConfigLhdcV5Sink::updateEncoderUserConfig(
+    UNUSED_ATTR const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+    UNUSED_ATTR bool* p_restart_input, UNUSED_ATTR bool* p_restart_output,
+    UNUSED_ATTR bool* p_config_updated) {
+  // TODO: This method applies only to Source codecs
+  return false;
+}
+
+uint64_t A2dpCodecConfigLhdcV5Sink::encoderIntervalMs() const {
+  // TODO: This method applies only to Source codecs
+  return 0;
+}
+
+int A2dpCodecConfigLhdcV5Sink::getEffectiveMtu() const {
+  // TODO: This method applies only to Source codecs
+  return 0;
+}
+
+////////
+//    APIs for calling from encoder/decoder module - START
+////////
+bool A2DP_VendorGetMaxBitRateLhdcV5(uint32_t *retval, const uint8_t* p_codec_info){
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr || retval == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, true, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+        a2dp_status);
+    return false;
+  }
+
+  switch (lhdc_cie.maxTargetBitrate) {
+  case A2DP_LHDCV5_MAX_BIT_RATE_1000K:
+    *retval = (uint32_t)A2DP_LHDCV5_QUALITY_HIGH1;
+    return true;
+  case A2DP_LHDCV5_MAX_BIT_RATE_900K:
+    *retval = (uint32_t)A2DP_LHDCV5_QUALITY_HIGH;
+    return true;
+  case A2DP_LHDCV5_MAX_BIT_RATE_500K:
+    *retval = (uint32_t)A2DP_LHDCV5_QUALITY_MID;
+    return true;
+  case A2DP_LHDCV5_MAX_BIT_RATE_400K:
+    *retval = (uint32_t)A2DP_LHDCV5_QUALITY_LOW;
+    return true;
+  }
+
+  return false;
+}
+
+bool A2DP_VendorGetMinBitRateLhdcV5(uint32_t *retval, const uint8_t* p_codec_info){
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr || retval == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, true, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+        a2dp_status);
+    return false;
+  }
+
+  switch (lhdc_cie.minTargetBitrate) {
+  case A2DP_LHDCV5_MIN_BIT_RATE_400K:
+    *retval = (uint32_t)A2DP_LHDCV5_QUALITY_LOW;
+    return true;
+  case A2DP_LHDCV5_MIN_BIT_RATE_256K:
+    *retval = (uint32_t)A2DP_LHDCV5_QUALITY_LOW3;
+    return true;
+  case A2DP_LHDCV5_MIN_BIT_RATE_128K:
+    *retval = (uint32_t)A2DP_LHDCV5_QUALITY_LOW1;
+    return true;
+  case A2DP_LHDCV5_MIN_BIT_RATE_64K:
+    *retval = (uint32_t)A2DP_LHDCV5_QUALITY_LOW0;
+    return true;
+  }
+
+  return false;
+}
+
+bool A2DP_VendorGetVersionLhdcV5(uint32_t *retval, const uint8_t* p_codec_info){
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr || retval == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+        a2dp_status);
+    return false;
+  }
+
+  *retval = (uint32_t)lhdc_cie.version;
+
+  return true;
+}
+
+bool A2DP_VendorGetBitPerSampleLhdcV5(uint8_t *retval, const uint8_t* p_codec_info){
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr || retval == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+        a2dp_status);
+    return false;
+  }
+
+  *retval = (uint32_t)lhdc_cie.bitsPerSample;
+
+  return true;
+}
+
+bool A2DP_VendorHasJASFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr || retval == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+        a2dp_status);
+    return false;
+  }
+  *retval = lhdc_cie.hasFeatureJAS ? 1 : 0;
+
+  return true;
+}
+
+bool A2DP_VendorHasARFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr || retval == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+        a2dp_status);
+    return false;
+  }
+  *retval = lhdc_cie.hasFeatureAR ? 1 : 0;
+
+  return true;
+}
+
+bool A2DP_VendorHasMETAFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr || retval == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+        a2dp_status);
+    return false;
+  }
+  *retval = lhdc_cie.hasFeatureMETA ? 1 : 0;
+
+  return true;
+}
+
+//orig A2DP_VendorGetLowLatencyStateLhdcV5
+bool A2DP_VendorHasLLFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info){
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr || retval == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: cannot decode codec information: %d", __func__,
+        a2dp_status);
+    return false;
+  }
+  *retval = lhdc_cie.hasFeatureLL ? 1 : 0;
+
+  return true;
+}
+////////
+//    APIs for calling from encoder/decoder module - END
+////////
diff --git a/system/bt/stack/a2dp/a2dp_vendor_lhdcv5_decoder.cc b/system/bt/stack/a2dp/a2dp_vendor_lhdcv5_decoder.cc
new file mode 100755
index 00000000..25283005
--- /dev/null
+++ b/system/bt/stack/a2dp/a2dp_vendor_lhdcv5_decoder.cc
@@ -0,0 +1,568 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "a2dp_vendor_lhdcv5_decoder"
+
+#include "a2dp_vendor_lhdcv5_decoder.h"
+
+#include <dlfcn.h>
+#include <inttypes.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <lhdcv5BT_dec.h>
+
+#include "bt_common.h"
+#include "common/time_util.h"
+#include "osi/include/log.h"
+#include "osi/include/osi.h"
+
+
+
+#define A2DP_LHDC_FUNC_DISABLE		0
+#define A2DP_LHDC_FUNC_ENABLE		1
+
+#define LHDCV5_DEC_MAX_SAMPLES_PER_FRAME  256
+#define LHDCV5_DEC_MAX_CHANNELS           2
+#define LHDCV5_DEC_MAX_BIT_DEPTH          32
+#define LHDCV5_DEC_FRAME_NUM              16
+#define LHDCV5_DEC_BUF_BYTES              (LHDCV5_DEC_FRAME_NUM * \
+                                           LHDCV5_DEC_MAX_SAMPLES_PER_FRAME * \
+                                           LHDCV5_DEC_MAX_CHANNELS * \
+                                           (LHDCV5_DEC_MAX_BIT_DEPTH >> 3))
+#define LHDCV5_DEC_PACKET_NUM             8
+#define LHDCV5_DEC_INPUT_BUF_BYTES        1024
+#define LHDCV5_DEC_PKT_HDR_BYTES          2
+
+typedef struct {
+  pthread_mutex_t mutex;
+  HANDLE_LHDCV5_BT lhdc_handle;
+  bool has_lhdc_handle;  // True if lhdc_handle is valid
+
+  uint32_t    sample_rate;
+  uint8_t     bits_per_sample;
+  lhdc_ver_t  version;
+  uint8_t     func_ar;
+  uint8_t     func_jas;
+  uint8_t     func_meta;
+
+  uint8_t     decode_buf[LHDCV5_DEC_PACKET_NUM][LHDCV5_DEC_BUF_BYTES];
+  uint32_t    dec_buf_idx;
+
+  uint8_t     dec_input_buf[LHDCV5_DEC_INPUT_BUF_BYTES];
+  uint32_t    dec_input_buf_bytes;
+
+  decoded_data_callback_t decode_callback;
+} tA2DP_LHDCV5_DECODER_CB;
+
+static tA2DP_LHDCV5_DECODER_CB a2dp_lhdcv5_decoder_cb;
+
+
+#define _V5DEC_REC_FILE_
+#if defined(_V5DEC_REC_FILE_)
+#define V5RAW_FILE_NAME "/sdcard/Download/lhdcv5dec.raw"
+#define V5PCM_FILE_NAME "/sdcard/Download/v5decoded.pcm"
+static FILE *rawFile = NULL;
+static FILE *pcmFile = NULL;
+#endif
+
+//
+// The LHDCV5 decoder shared library, and the functions to use
+//
+static const char* LHDC_DECODER_LIB_NAME = "liblhdcv5BT_dec.so";
+static void* lhdc_decoder_lib_handle = NULL;
+
+static const char* LHDCDEC_INIT_DECODER_NAME = "lhdcv5BT_dec_init_decoder";
+typedef int32_t (*tLHDCDEC_INIT_DECODER)(HANDLE_LHDCV5_BT *handle,
+    tLHDCV5_DEC_CONFIG *config);
+
+static const char* LHDCDEC_CHECK_FRAME_DATA_ENOUGH_NAME =
+    "lhdcv5BT_dec_check_frame_data_enough";
+typedef int32_t (*tLHDCDEC_CHECK_FRAME_DATA_ENOUGH)(const uint8_t *frameData,
+    uint32_t frameBytes, uint32_t *packetBytes);
+
+static const char* LHDCDEC_DECODE_NAME = "lhdcv5BT_dec_decode";
+typedef int32_t (*tLHDCDEC_DECODE)(const uint8_t *frameData, uint32_t frameBytes,
+    uint8_t* pcmData, uint32_t* pcmBytes, uint32_t bits_depth);
+
+static const char* LHDCDEC_DEINIT_DECODER_NAME = "lhdcv5BT_dec_deinit_decoder";
+typedef int32_t (*tLHDCDEC_DEINIT_DECODER)(HANDLE_LHDCV5_BT handle);
+
+static tLHDCDEC_INIT_DECODER lhdcv5dec_init_decoder;
+static tLHDCDEC_CHECK_FRAME_DATA_ENOUGH lhdcv5dec_check_frame_data_enough;
+static tLHDCDEC_DECODE lhdcv5dec_decode;
+static tLHDCDEC_DEINIT_DECODER lhdcv5dec_deinit_decoder;
+
+// LHDC V5 Codec Info:
+//  ----------------------------------------------------------------
+//  H0   |    H1     |    H2     |  P0-P3   | P4-P5   | P6[5:0]  |
+//  losc | mediaType | codecType | vendorId | codecId | SampRate |
+//  ----------------------------------------------------------------
+//  P7[2:0]   | P7[5:4]    | P7[7:6]       | P8[3:0] | P8[4]       |
+//  bit depth | MaxBitRate | MinBitRate    | Version | FrameLen5ms |
+//  ----------------------------------------------------------------
+//  P9[0] | P9[1]  | P9[2]   | P9[6] | P9[7]       | P10[0]      |
+//  HasAR | HasJAS | HasMeta | HasLL | HasLossless | FeatureOnAR |
+//  ----------------------------------------------------------------
+#define A2DP_LHDCV5_CODEC_INFO_ATTR_1 (3+6)
+#define A2DP_LHDCV5_CODEC_INFO_ATTR_2 (3+7)
+#define A2DP_LHDCV5_CODEC_INFO_ATTR_3 (3+8)
+#define A2DP_LHDCV5_CODEC_INFO_ATTR_4 (3+9)
+
+
+bool a2dp_lhdcv5_decoder_save_codec_info (const uint8_t* p_codec_info)
+{
+  if (p_codec_info == NULL) {
+    return false;
+  }
+
+  if (lhdc_decoder_lib_handle == NULL) {
+    return false;
+  }
+
+  // Sampling Frequency
+  if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_1] &
+      A2DP_LHDCV5_SAMPLING_FREQ_44100) {
+    a2dp_lhdcv5_decoder_cb.sample_rate = 44100;
+  } else if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_1] &
+      A2DP_LHDCV5_SAMPLING_FREQ_48000) {
+    a2dp_lhdcv5_decoder_cb.sample_rate = 48000;
+  } else if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_1] &
+      A2DP_LHDCV5_SAMPLING_FREQ_96000) {
+    a2dp_lhdcv5_decoder_cb.sample_rate = 96000;
+  } else if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_1] &
+      A2DP_LHDCV5_SAMPLING_FREQ_192000) {
+    a2dp_lhdcv5_decoder_cb.sample_rate = 192000;
+  } else {
+    return false;
+  }
+
+  // Bit Depth
+  if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_2] &
+      A2DP_LHDCV5_BIT_FMT_16) {
+    a2dp_lhdcv5_decoder_cb.bits_per_sample = 16;
+  } else if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_2] &
+      A2DP_LHDCV5_BIT_FMT_24) {
+    a2dp_lhdcv5_decoder_cb.bits_per_sample = 24;
+  } else if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_2] &
+      A2DP_LHDCV5_BIT_FMT_32) {
+    a2dp_lhdcv5_decoder_cb.bits_per_sample = 32;
+  } else {
+    return false;
+  }
+
+  // version
+  if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_3] &
+      A2DP_LHDCV5_VER_1) {
+    a2dp_lhdcv5_decoder_cb.version = VERSION_5;
+  } else {
+    return false;
+  }
+
+  // AR
+  if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_4] &
+      A2DP_LHDCV5_FEATURE_AR) {
+    a2dp_lhdcv5_decoder_cb.func_ar = A2DP_LHDC_FUNC_ENABLE;
+  } else {
+    a2dp_lhdcv5_decoder_cb.func_ar = A2DP_LHDC_FUNC_DISABLE;
+  }
+
+  // JAS
+  if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_4] &
+      A2DP_LHDCV5_FEATURE_JAS) {
+    a2dp_lhdcv5_decoder_cb.func_jas = A2DP_LHDC_FUNC_ENABLE;
+  } else {
+    a2dp_lhdcv5_decoder_cb.func_jas = A2DP_LHDC_FUNC_DISABLE;
+  }
+
+  // META
+  if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_4] &
+      A2DP_LHDCV5_FEATURE_META) {
+    a2dp_lhdcv5_decoder_cb.func_meta = A2DP_LHDC_FUNC_ENABLE;
+  } else {
+    a2dp_lhdcv5_decoder_cb.func_meta = A2DP_LHDC_FUNC_DISABLE;
+  }
+
+  return true;
+}
+
+
+static void* load_func(const char* func_name) {
+
+  void* func_ptr = NULL;
+
+  if ((func_name == NULL) ||
+      (lhdc_decoder_lib_handle == NULL)) {
+    LOG_ERROR(LOG_TAG, "%s: null ptr", __func__);
+    return NULL;
+  }
+
+  func_ptr = dlsym(lhdc_decoder_lib_handle, func_name);
+
+  if (func_ptr == NULL) {
+    LOG_ERROR(LOG_TAG,
+        "%s: cannot find function '%s' in the encoder library: %s",
+        __func__, func_name, dlerror());
+    A2DP_VendorUnloadDecoderLhdcV5();
+    return NULL;
+  }
+
+  return func_ptr;
+}
+
+
+bool A2DP_VendorLoadDecoderLhdcV5(void) {
+
+  if (lhdc_decoder_lib_handle != NULL) {
+    return true;  // Already loaded
+  }
+
+  // Initialize the control block
+  memset(&a2dp_lhdcv5_decoder_cb, 0, sizeof(a2dp_lhdcv5_decoder_cb));
+
+  pthread_mutex_init(&(a2dp_lhdcv5_decoder_cb.mutex), NULL);
+
+  // Open the encoder library
+  lhdc_decoder_lib_handle = dlopen(LHDC_DECODER_LIB_NAME, RTLD_NOW);
+  if (lhdc_decoder_lib_handle == NULL) {
+    LOG_ERROR(LOG_TAG, "%s: cannot open LHDCV5 decoder library %s", __func__, dlerror());
+    return false;
+  }
+
+  // Load all functions
+  lhdcv5dec_init_decoder = (tLHDCDEC_INIT_DECODER)load_func(LHDCDEC_INIT_DECODER_NAME);
+  if (lhdcv5dec_init_decoder == NULL) return false;
+
+  lhdcv5dec_check_frame_data_enough =
+      (tLHDCDEC_CHECK_FRAME_DATA_ENOUGH)load_func(LHDCDEC_CHECK_FRAME_DATA_ENOUGH_NAME);
+  if (lhdcv5dec_check_frame_data_enough == NULL) return false;
+
+  lhdcv5dec_decode = (tLHDCDEC_DECODE)load_func(LHDCDEC_DECODE_NAME);
+  if (lhdcv5dec_decode == NULL) return false;
+
+  lhdcv5dec_deinit_decoder =
+      (tLHDCDEC_DEINIT_DECODER)load_func(LHDCDEC_DEINIT_DECODER_NAME);
+  if (lhdcv5dec_deinit_decoder == NULL) return false;
+
+  LOG_DEBUG(LOG_TAG, "%s: LHDCV5 decoder library loaded", __func__);
+  return true;
+}
+
+
+void A2DP_VendorUnloadDecoderLhdcV5(void) {
+
+  a2dp_vendor_lhdcv5_decoder_cleanup();
+
+  pthread_mutex_destroy(&(a2dp_lhdcv5_decoder_cb.mutex));
+  memset(&a2dp_lhdcv5_decoder_cb, 0, sizeof(a2dp_lhdcv5_decoder_cb));
+
+  lhdcv5dec_init_decoder = NULL;
+  lhdcv5dec_check_frame_data_enough = NULL;
+  lhdcv5dec_decode = NULL;
+  lhdcv5dec_deinit_decoder = NULL;
+
+  if (lhdc_decoder_lib_handle != NULL) {
+    dlclose(lhdc_decoder_lib_handle);
+    lhdc_decoder_lib_handle = NULL;
+  }
+
+#if defined(_V5DEC_REC_FILE_)
+  if (rawFile != NULL) {
+    fclose(rawFile);
+    rawFile = NULL;
+    remove(V5RAW_FILE_NAME);
+  }
+  if (pcmFile != NULL) {
+    fclose(pcmFile);
+    pcmFile = NULL;
+    remove(V5PCM_FILE_NAME);
+  }
+#endif
+  LOG_DEBUG(LOG_TAG, "%s: unload LHDC V5 decoder", __func__);
+}
+
+
+bool a2dp_vendor_lhdcv5_decoder_init(decoded_data_callback_t decode_callback) {
+  int32_t api_ret;
+  tLHDCV5_DEC_CONFIG lhdcdec_config;
+
+  if ((lhdc_decoder_lib_handle == NULL) ||
+      (lhdcv5dec_init_decoder == NULL) ||
+      (lhdcv5dec_deinit_decoder == NULL)) {
+    return false;
+  }
+
+  pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
+
+  LOG_DEBUG(LOG_TAG, "%s: has_lhdc_handle(%d) handle_base (%p) handle(%p)", __func__,
+      a2dp_lhdcv5_decoder_cb.has_lhdc_handle,
+      &(a2dp_lhdcv5_decoder_cb.lhdc_handle),
+      a2dp_lhdcv5_decoder_cb.lhdc_handle);
+
+  if (a2dp_lhdcv5_decoder_cb.has_lhdc_handle) {
+    api_ret = lhdcv5dec_deinit_decoder(a2dp_lhdcv5_decoder_cb.lhdc_handle);
+    if (api_ret != LHDCV5BT_DEC_API_SUCCEED) {
+      LOG_ERROR(LOG_TAG, "%s: fail to deinit decoder %d", __func__, api_ret);
+      pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+      return false;
+    }
+    a2dp_lhdcv5_decoder_cb.has_lhdc_handle = false;
+    a2dp_lhdcv5_decoder_cb.lhdc_handle = NULL;
+    LOG_DEBUG(LOG_TAG, "%s: handle cleaned", __func__);
+  }
+
+  lhdcdec_config.version = a2dp_lhdcv5_decoder_cb.version;
+  lhdcdec_config.sample_rate = a2dp_lhdcv5_decoder_cb.sample_rate;
+  lhdcdec_config.bits_depth = a2dp_lhdcv5_decoder_cb.bits_per_sample;
+  lhdcdec_config.bit_rate = 400000;  //TODO
+
+  if (a2dp_lhdcv5_decoder_cb.has_lhdc_handle == false &&
+      a2dp_lhdcv5_decoder_cb.lhdc_handle == NULL) {
+    LOG_DEBUG(LOG_TAG, "%s: to init decoder...", __func__);
+    api_ret = lhdcv5dec_init_decoder(&(a2dp_lhdcv5_decoder_cb.lhdc_handle), &lhdcdec_config);
+    if (api_ret != LHDCV5BT_DEC_API_SUCCEED) {
+      LOG_ERROR(LOG_TAG, "%s: falied to init decoder %d", __func__, api_ret);
+      pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+    return false;
+  }
+    a2dp_lhdcv5_decoder_cb.has_lhdc_handle = true;
+  }
+
+  a2dp_lhdcv5_decoder_cb.dec_buf_idx = 0;
+  a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes = 0;
+  a2dp_lhdcv5_decoder_cb.decode_callback = decode_callback;
+
+#if defined(_V5DEC_REC_FILE_)
+  if (rawFile == NULL) {
+    rawFile = fopen(V5RAW_FILE_NAME,"wb");
+    LOG_DEBUG(LOG_TAG, "%s: create recode file = %p", __func__, rawFile);
+  }
+  if (pcmFile == NULL) {
+    pcmFile = fopen(V5PCM_FILE_NAME,"wb");
+    LOG_DEBUG(LOG_TAG, "%s: create recode file = %p", __func__, pcmFile);
+  }
+#endif
+
+  LOG_DEBUG(LOG_TAG, "%s: init LHDCV5 decoder success", __func__);
+
+  pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+  return true;
+}
+
+
+void a2dp_vendor_lhdcv5_decoder_cleanup(void) {
+  int32_t api_ret;
+
+  pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
+
+  if (a2dp_lhdcv5_decoder_cb.has_lhdc_handle) {
+    api_ret = lhdcv5dec_deinit_decoder(a2dp_lhdcv5_decoder_cb.lhdc_handle);
+    if (api_ret != LHDCV5BT_DEC_API_SUCCEED) {
+      LOG_ERROR(LOG_TAG, "%s: fail to deinit LHDCV5 decoder %d", __func__, api_ret);
+      pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+      return;
+    }
+  }
+
+  a2dp_lhdcv5_decoder_cb.has_lhdc_handle = false;
+  a2dp_lhdcv5_decoder_cb.lhdc_handle = NULL;
+
+  LOG_DEBUG(LOG_TAG, "%s: deinit LHDCV5 decoder success", __func__);
+  pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+}
+
+
+bool a2dp_vendor_lhdcv5_decoder_decode_packet(BT_HDR* p_buf) {
+  int32_t api_ret;
+  uint8_t *data;
+  size_t data_size;
+  uint32_t out_used = 0;
+  uint32_t dec_buf_idx;
+  uint8_t *ptr_src;
+  uint8_t *ptr_dst;
+  uint32_t packet_bytes;
+  uint32_t i;
+
+  LOG_DEBUG(LOG_TAG, "%s: enter", __func__);
+
+
+  if ((lhdc_decoder_lib_handle == NULL) ||
+      (lhdcv5dec_decode == NULL)) {
+    LOG_ERROR(LOG_TAG, "%s: lib not loaded!", __func__);
+    return false;
+  }
+
+  // check handle
+  if (!a2dp_lhdcv5_decoder_cb.has_lhdc_handle || !a2dp_lhdcv5_decoder_cb.lhdc_handle) {
+    LOG_ERROR(LOG_TAG, "%s: handle not existed!", __func__);
+    return false;
+  }
+
+  if (p_buf == NULL) {
+    return false;
+  }
+
+  pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
+
+  data = p_buf->data + p_buf->offset;
+  data_size = p_buf->len;
+
+  if (data_size == 0) {
+    LOG_ERROR(LOG_TAG, "%s: Empty packet", __func__);
+    pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+    return false;
+  }
+
+
+  dec_buf_idx = a2dp_lhdcv5_decoder_cb.dec_buf_idx++;
+  if (a2dp_lhdcv5_decoder_cb.dec_buf_idx >= LHDCV5_DEC_PACKET_NUM) {
+    a2dp_lhdcv5_decoder_cb.dec_buf_idx = 0;
+  }
+
+#if defined(_V5DEC_REC_FILE_)
+  if (rawFile != NULL && data_size > 0) {
+    fwrite(data + LHDCV5_DEC_PKT_HDR_BYTES, sizeof(uint8_t),
+        data_size - LHDCV5_DEC_PKT_HDR_BYTES, rawFile);
+  }
+#endif
+
+  if ((a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes + data_size) > LHDCV5_DEC_INPUT_BUF_BYTES) {
+    // the data queued is useless
+    // discard them
+    a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes = 0;
+
+    if (data_size > LHDCV5_DEC_INPUT_BUF_BYTES)
+    {
+      // input data is too big (more than buffer size)!!
+      // just ingore it, and do nothing
+      pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+      return true;
+    }
+  }
+
+  memcpy (&(a2dp_lhdcv5_decoder_cb.dec_input_buf[a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes]),
+      data, data_size);
+  a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes += data_size;
+
+  packet_bytes = 0;
+  api_ret = lhdcv5dec_check_frame_data_enough(a2dp_lhdcv5_decoder_cb.dec_input_buf,
+      a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes,
+      &packet_bytes);
+  if (api_ret != LHDCV5BT_DEC_API_SUCCEED) {
+    LOG_ERROR(LOG_TAG, "%s: fail to check frame data! %d", __func__, api_ret);
+    // clear the data in the input buffer
+    a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes = 0;
+    pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+    return false;
+  }
+
+  if (packet_bytes != (a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes - LHDCV5_DEC_PKT_HDR_BYTES)) {
+    // strange!
+    // queued data is NOT exactly equal to one packet!
+    // maybe wrong data in buffer
+    // discard data queued previously, and save input data
+    LOG_ERROR(LOG_TAG, "%s: queued data is NOT exactly equal to one packet! packet (%d),  input (%d)",
+        __func__, packet_bytes, a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes);
+
+    a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes = 0;
+    memcpy(&(a2dp_lhdcv5_decoder_cb.dec_input_buf[a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes]),
+        data,
+        data_size);
+    a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes += data_size;
+    pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+    return true;
+  }
+
+  out_used = sizeof(a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx]);
+  api_ret = lhdcv5dec_decode(a2dp_lhdcv5_decoder_cb.dec_input_buf,
+      a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes,
+      a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx],
+      &out_used,
+      a2dp_lhdcv5_decoder_cb.bits_per_sample);
+
+  // finish decoding
+  // clear the data in the input buffer
+  a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes = 0;
+
+  if (api_ret != LHDCV5BT_DEC_API_SUCCEED) {
+    LOG_ERROR(LOG_TAG, "%s: fail to decode lhdc stream! %d", __func__, api_ret);
+    pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+    return false;
+  }
+
+  if (a2dp_lhdcv5_decoder_cb.bits_per_sample == 24) { //PCM_24_BIT_PACKCED
+    ptr_src = a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx];
+    ptr_dst = a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx];
+
+    for (i = 0; i < (out_used >> 2) ; i++) {
+      *ptr_dst++ = *ptr_src++;
+      *ptr_dst++ = *ptr_src++;
+      *ptr_dst++ = *ptr_src++;
+      ptr_src++;
+    }
+    out_used = (out_used >> 2) * 3;
+  } else if (a2dp_lhdcv5_decoder_cb.bits_per_sample == 32) {
+    ptr_dst = a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx];
+
+    for (i = 0; i < (out_used >> 2) ; i++) {
+      ptr_dst[3] = ptr_dst[2];
+      ptr_dst[2] = ptr_dst[1];
+      ptr_dst[1] = ptr_dst[0];
+      ptr_dst[0] = 0;
+      ptr_dst+=4;
+    }
+  }
+
+#if defined(_V5DEC_REC_FILE_)
+  if (pcmFile != NULL && out_used > 0 &&
+      out_used <= sizeof(a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx])) {
+    int write_bytes;
+    write_bytes = fwrite(a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx],
+        sizeof(uint8_t), out_used, pcmFile);
+  }
+#endif
+
+  a2dp_lhdcv5_decoder_cb.decode_callback(
+      reinterpret_cast<uint8_t*>(a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx]), out_used);
+
+  pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+  return true;
+}
+
+void a2dp_vendor_lhdcv5_decoder_start(void) {
+  //pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
+  LOG_DEBUG(LOG_TAG, "%s", __func__);
+  // do nothing
+
+  //pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+}
+
+void a2dp_vendor_lhdcv5_decoder_suspend(void) {
+  //pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
+  LOG_DEBUG(LOG_TAG, "%s", __func__);
+  // do nothing
+}
+
+void a2dp_vendor_lhdcv5_decoder_configure(const uint8_t* p_codec_info) {
+  if (p_codec_info == NULL) {
+    LOG_DEBUG(LOG_TAG, "%s: p_codec_info is NULL", __func__);
+    return;
+  }
+  //pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
+  LOG_DEBUG(LOG_TAG, "%s", __func__);
+  //pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+}
diff --git a/system/bt/stack/a2dp/a2dp_vendor_lhdcv5_encoder.cc b/system/bt/stack/a2dp/a2dp_vendor_lhdcv5_encoder.cc
new file mode 100755
index 00000000..196cb06c
--- /dev/null
+++ b/system/bt/stack/a2dp/a2dp_vendor_lhdcv5_encoder.cc
@@ -0,0 +1,1260 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "a2dp_vendor_lhdcv5_encoder"
+#define ATRACE_TAG ATRACE_TAG_AUDIO
+
+#include "a2dp_vendor_lhdcv5_encoder.h"
+
+#ifndef OS_GENERIC
+#include <cutils/trace.h>
+#endif
+#include <dlfcn.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <lhdcv5BT.h>
+
+#include "a2dp_vendor.h"
+#include "a2dp_vendor_lhdcv5.h"
+#include "bt_common.h"
+#include "common/time_util.h"
+#include "osi/include/log.h"
+#include "osi/include/osi.h"
+
+//
+// Encoder for LHDC Source Codec
+//
+
+#define LHDCV5_SRC_EXT_API_ENABLE // LHDC extended API implementation
+
+//
+// The LHDC encoder shared library, and the functions to use
+//
+static const char* LHDC_ENCODER_LIB_NAME = "liblhdcv5BT_enc.so";
+static void* lhdc_encoder_lib_handle = nullptr;
+
+static const char* LHDC_GET_HANDLE_NAME = "lhdcv5BT_get_handle";
+typedef int32_t (*tLHDC_GET_HANDLE)(uint32_t version, HANDLE_LHDCV5_BT *hLhdcParam);
+
+static const char* LHDC_FREE_HANDLE_NAME = "lhdcv5BT_free_handle";
+typedef int32_t (*tLHDC_FREE_HANDLE)(HANDLE_LHDCV5_BT hLhdcParam);
+
+static const char* LHDC_GET_BITRATE_NAME = "lhdcv5BT_get_bitrate";
+typedef int32_t (*tLHDC_GET_BITRATE)(HANDLE_LHDCV5_BT hLhdcParam, uint32_t *bitrate);
+
+static const char* LHDC_SET_BITRATE_NAME = "lhdcv5BT_set_bitrate";
+typedef int32_t (*tLHDC_SET_BITRATE)(HANDLE_LHDCV5_BT hLhdcParam, uint32_t bitrateInx);
+
+static const char* LHDC_SET_MAX_BITRATE_NAME = "lhdcv5BT_set_max_bitrate";
+typedef int32_t (*tLHDC_SET_MAX_BITRATE)(HANDLE_LHDCV5_BT hLhdcParam, uint32_t maxBitrateInx);
+
+static const char* LHDC_SET_MIN_BITRATE_NAME = "lhdcv5BT_set_min_bitrate";
+typedef int32_t (*tLHDC_SET_MIN_BITRATE)(HANDLE_LHDCV5_BT hLhdcParam, uint32_t minBitrateInx);
+
+static const char* LHDC_AUTO_ADJUST_BITRATE_NAME = "lhdcv5BT_adjust_bitrate";
+typedef int32_t (*tLHDC_AUTO_ADJUST_BITRATE)(HANDLE_LHDCV5_BT hLhdcParam, uint32_t queueLength);
+
+static const char* LHDC_SET_EXT_FUNC = "lhdcv5BT_set_ext_func_state";
+typedef int32_t (*tLHDC_SET_EXT_FUNC)(HANDLE_LHDCV5_BT hLhdcParam,
+    LHDCV5_EXT_FUNC_T field, bool enabled, void *priv, uint32_t privDataLen);
+
+static const char* LHDC_INIT_ENCODER_NAME = "lhdcv5BT_init_encoder";
+typedef int32_t (*tLHDC_INIT_ENCODER)(HANDLE_LHDCV5_BT hLhdcParam,
+    uint32_t samplingFreq, uint32_t bitsPerSample, uint32_t bitrateInx,
+    uint32_t mtu, uint32_t interval);
+
+static const char* LHDC_GET_BLOCK_SIZE = "lhdcv5BT_get_block_Size";
+typedef int32_t (*tLHDC_GET_BLOCK_SIZE)(HANDLE_LHDCV5_BT hLhdcParam, uint32_t *samplesPerFrame);
+
+static const char* LHDC_ENCODE_NAME = "lhdcv5BT_encode";
+typedef int32_t (*tLHDC_ENCODE)(HANDLE_LHDCV5_BT hLhdcParam,
+    void *pInPcm, uint32_t pcmBytes, uint8_t *pOutBuf, uint32_t outBufBytes,
+    uint32_t *pOutByte, uint32_t *pOut_frames);
+
+//
+// LHDC extend function API
+//
+#ifdef LHDCV5_SRC_EXT_API_ENABLE
+static const char* LHDCV5_EXT_SET_CONFIG_NAME = "lhdcv5BT_set_user_exconfig";
+typedef int (*tLHDCV5_EXT_SET_CONFIG)(HANDLE_LHDCV5_BT hLhdcParam, const char* userBuf, const int bufLen);
+
+static const char* LHDCV5_EXT_GET_CONFIG_NAME = "lhdcv5BT_get_user_exconfig";
+typedef int (*tLHDCV5_EXT_GET_CONFIG)(HANDLE_LHDCV5_BT hLhdcParam, const char* userBuf, const int bufLen);
+
+static const char* LHDC_EXT_SET_DATA_NAME = "lhdcv5BT_set_user_exdata";
+typedef void (*tLHDCV5_EXT_SET_DATA)(HANDLE_LHDCV5_BT hLhdcParam, const char* userBuf, const int bufLen);
+
+static const char* LHDCV5_EXT_GET_APIVER_NAME = "lhdcv5BT_get_user_exApiver";
+typedef int (*tLHDCV5_EXT_GET_APIVER)(HANDLE_LHDCV5_BT hLhdcParam, const char* userBuf, const int bufLen);
+#endif
+
+static tLHDC_GET_HANDLE lhdc_get_handle;
+static tLHDC_FREE_HANDLE lhdc_free_handle;
+static tLHDC_GET_BITRATE lhdc_get_bitrate;
+static tLHDC_SET_BITRATE lhdc_set_bitrate;
+static tLHDC_SET_MAX_BITRATE lhdc_set_max_bitrate;
+static tLHDC_SET_MIN_BITRATE lhdc_set_min_bitrate;
+static tLHDC_AUTO_ADJUST_BITRATE lhdc_auto_adjust_bitrate;
+static tLHDC_SET_EXT_FUNC lhdc_set_ext_func;
+static tLHDC_INIT_ENCODER lhdc_init_encoder;
+static tLHDC_GET_BLOCK_SIZE lhdc_get_block_size;
+static tLHDC_ENCODE lhdc_encode_func;
+
+//
+// LHDC extend function API
+//
+#ifdef LHDCV5_SRC_EXT_API_ENABLE
+static tLHDCV5_EXT_GET_APIVER lhdcv5_ext_get_ApiVer;
+static tLHDCV5_EXT_GET_CONFIG lhdcv5_ext_get_config;
+static tLHDCV5_EXT_SET_CONFIG lhdcv5_ext_set_config;
+static tLHDCV5_EXT_SET_DATA lhdcv5_ext_set_data;
+#endif
+
+// A2DP LHDC encoder interval in milliseconds
+#define A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS 10
+#define A2DP_LHDC_ENCODER_INTERVAL_MS 20
+
+// offset
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+#define A2DP_LHDC_OFFSET (AVDT_MEDIA_OFFSET + A2DP_LHDC_MPL_HDR_LEN + 1)
+#else
+#define A2DP_LHDC_OFFSET (AVDT_MEDIA_OFFSET + A2DP_LHDC_MPL_HDR_LEN)
+#endif
+
+typedef struct {
+  tA2DP_SAMPLE_RATE sample_rate;
+  uint32_t bits_per_sample;
+  uint32_t quality_mode_index;
+  uint32_t pcm_fmt;
+  uint32_t max_target_bitrate;
+  uint32_t min_target_bitrate;
+  uint8_t isLLEnabled;
+} tA2DP_LHDCV5_ENCODER_PARAMS;
+
+typedef struct {
+  uint32_t counter;
+  uint32_t bytes_per_tick; /* pcm bytes read each media task tick */
+  uint64_t last_frame_us;
+} tA2DP_LHDCV5_FEEDING_STATE;
+
+typedef struct {
+  uint64_t session_start_us;
+
+  uint32_t media_read_total_expected_packets;
+  uint32_t media_read_total_expected_reads_count;
+  uint32_t media_read_total_expected_read_bytes;
+
+  uint32_t media_read_total_dropped_packets;
+  uint32_t media_read_total_actual_reads_count;
+  uint32_t media_read_total_actual_read_bytes;
+} a2dp_lhdcv5_encoder_stats_t;
+
+typedef struct {
+  a2dp_source_read_callback_t read_callback;
+  a2dp_source_enqueue_callback_t enqueue_callback;
+  uint32_t TxAaMtuSize;
+  uint32_t TxQueueLength;
+
+  bool use_SCMS_T;
+  bool is_peer_edr;          // True if the peer device supports EDR
+  bool peer_supports_3mbps;  // True if the peer device supports 3Mbps EDR
+  uint16_t peer_mtu;         // MTU of the A2DP peer
+  uint32_t timestamp;        // Timestamp for the A2DP frames
+
+  HANDLE_LHDCV5_BT lhdc_handle;
+  bool has_lhdc_handle;  // True if lhdc_handle is valid
+
+  tA2DP_FEEDING_PARAMS feeding_params;
+  tA2DP_LHDCV5_ENCODER_PARAMS lhdc_encoder_params;
+  tA2DP_LHDCV5_FEEDING_STATE lhdc_feeding_state;
+
+  a2dp_lhdcv5_encoder_stats_t stats;
+  uint32_t buf_seq;
+  uint32_t bytes_read;
+} tA2DP_LHDCV5_ENCODER_CB;
+
+#define _V5ENC_REC_FILE_
+#if defined(_V5ENC_REC_FILE_)
+#define V5ENC_RAW_NAME "/sdcard/Download/lhdcv5.raw"
+#define V5ENC_PCM_NAME     "/sdcard/Download/sourcev5.pcm"
+static FILE  *recFile = NULL;
+static FILE *pcmFile = NULL;
+#endif
+
+static tA2DP_LHDCV5_ENCODER_CB a2dp_lhdc_encoder_cb;
+
+static void a2dp_vendor_lhdcv5_encoder_update(uint16_t peer_mtu,
+    A2dpCodecConfig* a2dp_codec_config,
+    bool* p_restart_input,
+    bool* p_restart_output,
+    bool* p_config_updated);
+
+static void a2dp_lhdcv5_get_num_frame_iteration(uint8_t* num_of_iterations,
+    uint8_t* num_of_frames,
+    uint64_t timestamp_us);
+
+static void a2dp_lhdcV5_encode_frames(uint8_t nb_frame);
+
+static bool a2dp_lhdcv5_read_feeding(uint8_t* read_buffer, uint32_t *bytes_read);
+
+static std::string quality_mode_index_to_name(uint32_t quality_mode_index);
+
+
+static void* load_func(const char* func_name) {
+  if(!func_name) return NULL;
+
+  void* func_ptr = dlsym(lhdc_encoder_lib_handle, func_name);
+  if (func_ptr == NULL) {
+    LOG_ERROR(LOG_TAG,
+        "%s: cannot find function '%s' in the encoder library: %s",
+        __func__, func_name, dlerror());
+    if (!A2DP_VendorUnloadEncoderLhdcV5()) {
+      LOG_ERROR(LOG_TAG, "%s: unload encoder error", __func__);
+    }
+    return nullptr;
+  }
+  return func_ptr;
+}
+
+bool A2DP_VendorLoadEncoderLhdcV5(void) {
+  if (lhdc_encoder_lib_handle != nullptr) return true;  // Already loaded
+
+  // Initialize the control block
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+
+  // Open the encoder library
+  lhdc_encoder_lib_handle = dlopen(LHDC_ENCODER_LIB_NAME, RTLD_NOW);
+  if (lhdc_encoder_lib_handle == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: cannot open LHDC encoder library %s: %s", __func__,
+        LHDC_ENCODER_LIB_NAME, dlerror());
+    return false;
+  }
+
+  lhdc_get_handle = nullptr;
+  lhdc_free_handle = nullptr;
+  lhdc_get_bitrate = nullptr;
+  lhdc_set_bitrate = nullptr;
+  lhdc_set_max_bitrate = nullptr;
+  lhdc_set_min_bitrate = nullptr;
+  lhdc_auto_adjust_bitrate = nullptr;
+  lhdc_set_ext_func = nullptr;
+  lhdc_init_encoder = nullptr;
+  lhdc_get_block_size =nullptr;
+  lhdc_encode_func = nullptr;
+
+  //
+  // LHDC extend function API
+  //
+#ifdef LHDCV5_SRC_EXT_API_ENABLE
+  lhdcv5_ext_get_ApiVer = nullptr;
+  lhdcv5_ext_get_config = nullptr;
+  lhdcv5_ext_set_config = nullptr;
+  lhdcv5_ext_set_data = nullptr;
+#endif
+
+  // Load all APIs
+  lhdc_get_handle = (tLHDC_GET_HANDLE)load_func(LHDC_GET_HANDLE_NAME);
+  if (lhdc_get_handle == nullptr) return false;
+  lhdc_free_handle = (tLHDC_FREE_HANDLE)load_func(LHDC_FREE_HANDLE_NAME);
+  if (lhdc_free_handle == nullptr) return false;
+  lhdc_get_bitrate = (tLHDC_GET_BITRATE)load_func(LHDC_GET_BITRATE_NAME);
+  if (lhdc_get_bitrate == nullptr) return false;
+  lhdc_set_bitrate = (tLHDC_SET_BITRATE)load_func(LHDC_SET_BITRATE_NAME);
+  if (lhdc_set_bitrate == nullptr) return false;
+  lhdc_set_max_bitrate = (tLHDC_SET_MAX_BITRATE)load_func(LHDC_SET_MAX_BITRATE_NAME);
+  if (lhdc_set_max_bitrate == nullptr) return false;
+  lhdc_set_min_bitrate = (tLHDC_SET_MIN_BITRATE)load_func(LHDC_SET_MIN_BITRATE_NAME);
+  if (lhdc_set_min_bitrate == nullptr) return false;
+  lhdc_auto_adjust_bitrate = (tLHDC_AUTO_ADJUST_BITRATE)load_func(LHDC_AUTO_ADJUST_BITRATE_NAME);
+  if (lhdc_auto_adjust_bitrate == nullptr) return false;
+  lhdc_set_ext_func = (tLHDC_SET_EXT_FUNC)load_func(LHDC_SET_EXT_FUNC);
+  if (lhdc_set_ext_func == nullptr) return false;
+  lhdc_init_encoder = (tLHDC_INIT_ENCODER)load_func(LHDC_INIT_ENCODER_NAME);
+  if (lhdc_init_encoder == nullptr) return false;
+  lhdc_get_block_size = (tLHDC_GET_BLOCK_SIZE)load_func(LHDC_GET_BLOCK_SIZE);
+  if (lhdc_get_block_size == nullptr) return false;
+  lhdc_encode_func = (tLHDC_ENCODE)load_func(LHDC_ENCODE_NAME);
+  if (lhdc_encode_func == nullptr) return false;
+
+  //
+  // LHDC extend function API
+  //
+#ifdef LHDCV5_SRC_EXT_API_ENABLE
+  lhdcv5_ext_get_ApiVer = (tLHDCV5_EXT_GET_APIVER)load_func(LHDCV5_EXT_GET_APIVER_NAME);
+  if (lhdcv5_ext_get_ApiVer == nullptr) return false;
+  lhdcv5_ext_get_config = (tLHDCV5_EXT_GET_CONFIG)load_func(LHDCV5_EXT_GET_CONFIG_NAME);
+  if (lhdcv5_ext_get_config == nullptr) return false;
+  lhdcv5_ext_set_config = (tLHDCV5_EXT_SET_CONFIG)load_func(LHDCV5_EXT_SET_CONFIG_NAME);
+  if (lhdcv5_ext_set_config == nullptr) return false;
+  lhdcv5_ext_set_data = (tLHDCV5_EXT_SET_DATA)load_func(LHDC_EXT_SET_DATA_NAME);
+  if (lhdcv5_ext_set_data == nullptr) return false;
+#endif
+
+  return true;
+}
+
+bool A2DP_VendorUnloadEncoderLhdcV5(void) {
+  if (lhdc_encoder_lib_handle == nullptr) return true;  // Already unload
+
+  // Cleanup any LHDC-related state
+  LOG_DEBUG(LOG_TAG, "%s: has_lhdc_handle %d",
+      __func__, a2dp_lhdc_encoder_cb.has_lhdc_handle);
+
+  if (a2dp_lhdc_encoder_cb.has_lhdc_handle && lhdc_free_handle != nullptr) {
+    int32_t ret = lhdc_free_handle(a2dp_lhdc_encoder_cb.lhdc_handle);
+    if (ret < 0) {
+      LOG_ERROR(LOG_TAG, "%s: free handle error %d", __func__, ret);
+      return false;
+    }
+  } else {
+    LOG_ERROR(LOG_TAG, "%s: unload encoder error", __func__);
+    return false;
+  }
+
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+
+  lhdc_get_handle = nullptr;
+  lhdc_free_handle = nullptr;
+  lhdc_get_bitrate = nullptr;
+  lhdc_set_bitrate = nullptr;
+  lhdc_set_max_bitrate = nullptr;
+  lhdc_set_min_bitrate = nullptr;
+  lhdc_auto_adjust_bitrate = nullptr;
+  lhdc_set_ext_func = nullptr;
+  lhdc_init_encoder = nullptr;
+  lhdc_get_block_size =nullptr;
+  lhdc_encode_func = nullptr;
+
+  //
+  // LHDC extend function API
+  //
+#ifdef LHDCV5_SRC_EXT_API_ENABLE
+  lhdcv5_ext_get_ApiVer = nullptr;
+  lhdcv5_ext_get_config = nullptr;
+  lhdcv5_ext_set_config = nullptr;
+  lhdcv5_ext_set_data = nullptr;
+#endif
+
+  dlclose(lhdc_encoder_lib_handle);
+  lhdc_encoder_lib_handle = nullptr;
+
+  return true;
+}
+
+//tA2DP_ENCODER_INTERFACE::(encoder_init)
+void a2dp_vendor_lhdcv5_encoder_init(
+    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+    A2dpCodecConfig* a2dp_codec_config,
+    a2dp_source_read_callback_t read_callback,
+    a2dp_source_enqueue_callback_t enqueue_callback) {
+
+  if (p_peer_params == nullptr || a2dp_codec_config == nullptr ||
+      read_callback == nullptr || enqueue_callback == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: null input", __func__);
+    return;
+  }
+
+  if (a2dp_lhdc_encoder_cb.has_lhdc_handle) {
+    int32_t ret = lhdc_free_handle(a2dp_lhdc_encoder_cb.lhdc_handle);
+    if (ret < 0) {
+      LOG_ERROR(LOG_TAG, "%s: free handle error %d", __func__, ret);
+      return;
+    }
+  }
+
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+
+  a2dp_lhdc_encoder_cb.stats.session_start_us = bluetooth::common::time_get_os_boottime_us();
+
+  a2dp_lhdc_encoder_cb.read_callback = read_callback;
+  a2dp_lhdc_encoder_cb.enqueue_callback = enqueue_callback;
+  a2dp_lhdc_encoder_cb.is_peer_edr = p_peer_params->is_peer_edr;
+  a2dp_lhdc_encoder_cb.peer_supports_3mbps = p_peer_params->peer_supports_3mbps;
+  a2dp_lhdc_encoder_cb.peer_mtu = p_peer_params->peer_mtu;
+  a2dp_lhdc_encoder_cb.timestamp = 0;
+
+
+  a2dp_lhdc_encoder_cb.use_SCMS_T = false;  // TODO: should be a parameter
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+  a2dp_lhdc_encoder_cb.use_SCMS_T = true;
+#endif
+
+  // NOTE: Ignore the restart_input / restart_output flags - this initization
+  // happens when the connection is (re)started.
+  bool restart_input = false;
+  bool restart_output = false;
+  bool config_updated = false;
+  a2dp_vendor_lhdcv5_encoder_update(a2dp_lhdc_encoder_cb.peer_mtu,
+      a2dp_codec_config, &restart_input,
+      &restart_output, &config_updated);
+}
+
+//
+// LHDC Extended API
+//
+#ifndef LHDCV5_SRC_EXT_API_ENABLE
+int A2dpCodecConfigLhdcV5Source::getEncoderExtendFuncUserApiVer(const char* version, const int clen) {
+  return BT_STATUS_FAIL;
+}
+int A2dpCodecConfigLhdcV5Source::getEncoderExtendFuncUserConfig(const char* userConfig, const int clen) {
+  return BT_STATUS_FAIL;
+}
+int A2dpCodecConfigLhdcV5Source::setEncoderExtendFuncUserConfig(const char* userConfig, const int clen) {
+  return BT_STATUS_FAIL;
+}
+bool A2dpCodecConfigLhdcV5Source::setEncoderExtendFuncUserData(const char* codecData, const int clen) {
+  return false;
+}
+#else
+int A2dpCodecConfigLhdcV5Source::getEncoderExtendFuncUserApiVer(const char* version, const int clen)
+{
+  if (version == nullptr) {
+    return BT_STATUS_FAIL;
+  }
+
+  if(lhdcv5_ext_get_ApiVer != nullptr) {
+    LOG_VERBOSE(LOG_TAG, "%s: lhdc_ext_API(GetApiVer): clen:%d", __func__, clen);
+    return lhdcv5_ext_get_ApiVer(a2dp_lhdc_encoder_cb.lhdc_handle, version, clen);
+  } else {
+    LOG_DEBUG(LOG_TAG, "%s: lib func not found", __func__);
+    return BT_STATUS_FAIL;
+  }
+}
+
+int A2dpCodecConfigLhdcV5Source::getEncoderExtendFuncUserConfig(const char* userConfig, const int clen)
+{
+  if (userConfig == nullptr) {
+    return BT_STATUS_FAIL;
+  }
+
+  if(lhdcv5_ext_get_config != nullptr) {
+    LOG_VERBOSE(LOG_TAG, "%s: lhdc_ext_API(GetConfig): clen:%d", __func__, clen);
+    return lhdcv5_ext_get_config(a2dp_lhdc_encoder_cb.lhdc_handle, userConfig, clen);
+  } else {
+    LOG_DEBUG(LOG_TAG, "%s: lib func not found", __func__);
+    return BT_STATUS_FAIL;
+  }
+}
+
+int A2dpCodecConfigLhdcV5Source::setEncoderExtendFuncUserConfig(const char* userConfig, const int clen)
+{
+  if (userConfig == nullptr) {
+    return BT_STATUS_FAIL;
+  }
+
+  if(lhdcv5_ext_set_config != nullptr) {
+    LOG_VERBOSE(LOG_TAG, "%s: lhdc_ext_API(SetConfig): clen:%d", __func__, clen);
+    return lhdcv5_ext_set_config(a2dp_lhdc_encoder_cb.lhdc_handle, userConfig, clen);
+  } else {
+    LOG_DEBUG(LOG_TAG, "%s: lib func not found", __func__);
+    return BT_STATUS_FAIL;
+  }
+}
+
+bool A2dpCodecConfigLhdcV5Source::setEncoderExtendFuncUserData(const char* codecData, const int clen)
+{
+  if (codecData == nullptr) {
+    return BT_STATUS_FAIL;
+  }
+
+  if(lhdcv5_ext_set_data != nullptr) {
+    LOG_VERBOSE(LOG_TAG, "%s: lhdc_ext_API(SetData): clen:%d", __func__, clen);
+    lhdcv5_ext_set_data(a2dp_lhdc_encoder_cb.lhdc_handle, codecData, clen);
+    return true;
+  } else {
+    LOG_DEBUG(LOG_TAG, "%s: lib func not found", __func__);
+    return false;
+  }
+}
+#endif  //LHDCV5_SRC_EXT_API_ENABLE
+
+bool A2dpCodecConfigLhdcV5Source::updateEncoderUserConfig(
+    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params, bool* p_restart_input,
+    bool* p_restart_output, bool* p_config_updated) {
+
+  if (p_peer_params == nullptr || p_restart_input == nullptr ||
+      p_restart_output == nullptr || p_config_updated == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: null input", __func__);
+    return false;
+  }
+
+  a2dp_lhdc_encoder_cb.is_peer_edr = p_peer_params->is_peer_edr;
+  a2dp_lhdc_encoder_cb.peer_supports_3mbps = p_peer_params->peer_supports_3mbps;
+  a2dp_lhdc_encoder_cb.peer_mtu = p_peer_params->peer_mtu;
+  a2dp_lhdc_encoder_cb.timestamp = 0;
+
+  if (a2dp_lhdc_encoder_cb.peer_mtu == 0) {
+    LOG_ERROR(LOG_TAG,
+        "%s: Cannot update the codec encoder for %s: "
+        "invalid peer MTU",
+        __func__, name().c_str());
+    return false;
+  }
+
+  a2dp_vendor_lhdcv5_encoder_update(a2dp_lhdc_encoder_cb.peer_mtu, this,
+      p_restart_input, p_restart_output,
+      p_config_updated);
+  return true;
+}
+
+// wrap index mapping from bt stack to codec library
+static bool a2dp_vendor_lhdcv5_qualitymode_wrapper(uint32_t *out, uint32_t in) {
+  if (!out) return false;
+
+  switch(in) {
+  case A2DP_LHDCV5_QUALITY_ABR:
+    *out = LHDCV5_QUALITY_AUTO;
+    return true;
+  case A2DP_LHDCV5_QUALITY_HIGH1:
+    *out = LHDCV5_QUALITY_HIGH1;
+    return true;
+  case A2DP_LHDCV5_QUALITY_HIGH:
+    *out = LHDCV5_QUALITY_HIGH;
+    return true;
+  case A2DP_LHDCV5_QUALITY_MID:
+    *out = LHDCV5_QUALITY_MID;
+    return true;
+  case A2DP_LHDCV5_QUALITY_LOW:
+    *out = LHDCV5_QUALITY_LOW;
+    return true;
+  case A2DP_LHDCV5_QUALITY_LOW4:
+    *out = LHDCV5_QUALITY_LOW4;
+    return true;
+  case A2DP_LHDCV5_QUALITY_LOW3:
+    *out = LHDCV5_QUALITY_LOW3;
+    return true;
+  case A2DP_LHDCV5_QUALITY_LOW2:
+    *out = LHDCV5_QUALITY_LOW2;
+    return true;
+  case A2DP_LHDCV5_QUALITY_LOW1:
+    *out = LHDCV5_QUALITY_LOW1;
+    return true;
+  case A2DP_LHDCV5_QUALITY_LOW0:
+    *out = LHDCV5_QUALITY_LOW0;
+    return true;
+  }
+
+  return false;
+}
+
+
+// Update the A2DP LHDC encoder.
+// |peer_mtu| is the peer MTU.
+// |a2dp_codec_config| is the A2DP codec to use for the update.
+static void a2dp_vendor_lhdcv5_encoder_update(uint16_t peer_mtu,
+    A2dpCodecConfig* a2dp_codec_config,
+    bool* p_restart_input,
+    bool* p_restart_output,
+    bool* p_config_updated) {
+
+  tA2DP_LHDCV5_ENCODER_PARAMS* p_encoder_params =
+      &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+  uint8_t codec_info[AVDT_CODEC_SIZE];
+  uint32_t verCode = 0;
+  int32_t lib_ret = 0;
+  uint8_t ret_value8 = 0;
+  uint32_t mtu_size = 0;
+  uint32_t max_mtu_len = 0;
+  uint32_t newValue_bt = 0, newValue_lib = 0;
+  tA2DP_FEEDING_PARAMS* p_feeding_params;
+
+  const uint8_t *p_codec_info;
+
+  *p_restart_input = false;
+  *p_restart_output = false;
+  *p_config_updated = false;
+
+  if (!a2dp_codec_config->copyOutOtaCodecConfig(codec_info)) {
+    LOG_ERROR(LOG_TAG,
+        "%s: Cannot update the codec encoder for %s: "
+        "invalid codec config",
+        __func__, a2dp_codec_config->name().c_str());
+    return;
+  }
+  p_codec_info = codec_info;
+
+  btav_a2dp_codec_config_t codec_config = a2dp_codec_config->getCodecConfig();
+  //btav_a2dp_codec_config_t codec_config_user = a2dp_codec_config->getCodecUserConfig();
+
+  // get version
+  if (!A2DP_VendorGetVersionLhdcV5(&verCode, p_codec_info)) {
+    LOG_ERROR(LOG_TAG, "%s: get version error!", __func__);
+    goto fail;
+  }
+  LOG_DEBUG(LOG_TAG, "%s: get version: %d" , __func__, verCode);
+
+  // get new handle
+  if (!a2dp_lhdc_encoder_cb.has_lhdc_handle) {
+    a2dp_lhdc_encoder_cb.lhdc_handle = nullptr;
+    lib_ret = lhdc_get_handle(verCode, &a2dp_lhdc_encoder_cb.lhdc_handle);
+    if (lib_ret != LHDCV5_FRET_SUCCESS) {
+      LOG_ERROR(LOG_TAG, "%s: [lib_ret] lhdc_get_handle error %d", __func__, lib_ret);
+      goto fail;
+    }
+
+    if (a2dp_lhdc_encoder_cb.lhdc_handle == nullptr) {
+      LOG_ERROR(LOG_TAG, "%s: Cannot get LHDC encoder handle", __func__);
+      goto fail;
+    }
+    a2dp_lhdc_encoder_cb.has_lhdc_handle = true;
+  }
+  LOG_DEBUG(LOG_TAG, "%s: lhdc handle addr = %p", __func__, a2dp_lhdc_encoder_cb.lhdc_handle);
+
+  //
+  // setup feeding parameters for encoder feeding process
+  //
+  p_feeding_params = &a2dp_lhdc_encoder_cb.feeding_params;
+  // sample rate (uint32_t)
+  p_feeding_params->sample_rate = A2DP_VendorGetTrackSampleRateLhdcV5(p_codec_info);
+  if (p_feeding_params->sample_rate < 0) {
+    LOG_ERROR(LOG_TAG, "%s: get track sample rate error", __func__);
+    goto fail;
+  }
+
+  // bit per sample (uint8_t)
+  p_feeding_params->bits_per_sample = A2DP_VendorGetTrackBitsPerSampleLhdcV5(p_codec_info);
+  if (p_feeding_params->bits_per_sample < 0) {
+    LOG_ERROR(LOG_TAG, "%s: get bit per sample error", __func__);
+    goto fail;
+  }
+
+  //channel count (uint8_t)
+  p_feeding_params->channel_count = A2DP_VendorGetTrackChannelCountLhdcV5(p_codec_info);
+  if (p_feeding_params->channel_count < 0) {
+    LOG_ERROR(LOG_TAG, "%s: get channel count error", __func__);
+    goto fail;
+  }
+  LOG_DEBUG(LOG_TAG, "%s: (feeding param) sample_rate=%u bits_per_sample=%u channel_count=%u",
+      __func__, p_feeding_params->sample_rate,
+      p_feeding_params->bits_per_sample,
+      p_feeding_params->channel_count);
+
+  //
+  // setup encoder parameters for configuring encoder
+  //
+  // sample rate tA2DP_SAMPLE_RATE(uint32_t)
+  p_encoder_params->sample_rate = a2dp_lhdc_encoder_cb.feeding_params.sample_rate;
+
+  // default mtu size (uint32_t)
+  mtu_size = (BT_DEFAULT_BUFFER_SIZE - A2DP_LHDC_OFFSET - sizeof(BT_HDR));
+  // allowed mtu size (uint32_t)
+  a2dp_lhdc_encoder_cb.TxAaMtuSize = (mtu_size < peer_mtu) ? mtu_size : (uint32_t)peer_mtu;
+  // real mtu size (uint32_t)
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+  max_mtu_len = (uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN - 1);
+#else
+  max_mtu_len = (uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN);
+#endif
+
+  // max target bit rate
+  if (!A2DP_VendorGetMaxBitRateLhdcV5(&newValue_bt, p_codec_info) ) {
+    LOG_ERROR(LOG_TAG, "%s: get max_target_bitrate error", __func__);
+    goto fail;
+  }
+  if (!a2dp_vendor_lhdcv5_qualitymode_wrapper(&newValue_lib, newValue_bt)) {
+    LOG_ERROR(LOG_TAG, "%s: wrap MBR qualiity mode error", __func__);
+    goto fail;
+  }
+  p_encoder_params->max_target_bitrate = newValue_lib;
+
+  // min target bit rate
+  if (!A2DP_VendorGetMinBitRateLhdcV5(&newValue_bt, p_codec_info) ) {
+    LOG_ERROR(LOG_TAG, "%s: get min_target_bitrate error", __func__);
+    goto fail;
+  }
+  if (!a2dp_vendor_lhdcv5_qualitymode_wrapper(&newValue_lib, newValue_bt)) {
+    LOG_ERROR(LOG_TAG, "%s: wrap mBR qualiity mode error", __func__);
+    goto fail;
+  }
+  p_encoder_params->min_target_bitrate = newValue_lib;
+
+  // Low latency mode
+  if (!A2DP_VendorHasLLFlagLhdcV5(&(p_encoder_params->isLLEnabled), p_codec_info)){
+    LOG_ERROR(LOG_TAG, "%s: get Low latency enable error", __func__);
+    goto fail;
+  }
+
+  // bit per sample
+  switch((int)p_feeding_params->bits_per_sample) {
+  case 16:
+    p_encoder_params->pcm_fmt = LHDCV5BT_SMPL_FMT_S16;
+    break;
+  case 24:
+    p_encoder_params->pcm_fmt = LHDCV5BT_SMPL_FMT_S24;
+    break;
+  case 32:
+    p_encoder_params->pcm_fmt = LHDCV5BT_SMPL_FMT_S32;
+    break;
+  }
+
+  // quality mode
+  if ((codec_config.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) == A2DP_LHDC_QUALITY_MAGIC_NUM) {
+    newValue_bt = (codec_config.codec_specific_1 & A2DP_LHDCV5_QUALITY_MASK);
+    if (!a2dp_vendor_lhdcv5_qualitymode_wrapper(&newValue_lib, newValue_bt)) {
+      LOG_ERROR(LOG_TAG, "%s: wrap quality mode error", __func__);
+      goto fail;
+    }
+    if (newValue_lib != p_encoder_params->quality_mode_index) {
+      p_encoder_params->quality_mode_index = newValue_lib;
+    }
+  } else {
+    //default: LOW (400 Kbps)
+    codec_config.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDCV5_QUALITY_LOW;
+    //codec_config_user.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
+
+    newValue_bt = A2DP_LHDCV5_QUALITY_LOW;
+    if (!a2dp_vendor_lhdcv5_qualitymode_wrapper(&newValue_lib, newValue_bt)) {
+      LOG_ERROR(LOG_TAG, "%s: (default) wrap quality mode error", __func__);
+      goto fail;
+    }
+    p_encoder_params->quality_mode_index = newValue_lib;
+  }
+
+  LOG_DEBUG(LOG_TAG, "%s: (encode param) sample_rate=%u pcm_fmt=%d peer_mtu=%d mtu=%d "
+      "maxBitRateIdx=%u minBitRateIdx=%u isLLEnabled=%u quality_mode=%s(%d)", __func__,
+      p_encoder_params->sample_rate,                //44100, 48000, ...
+      p_encoder_params->pcm_fmt,                    //16, 24, 32...
+      peer_mtu, max_mtu_len,                        //number of bytes
+      p_encoder_params->max_target_bitrate,         //index
+      p_encoder_params->min_target_bitrate,         //index
+      p_encoder_params->isLLEnabled,
+      quality_mode_index_to_name(p_encoder_params->quality_mode_index).c_str(),
+      p_encoder_params->quality_mode_index);
+
+  // setup features to encoder
+  if (A2DP_VendorHasARFlagLhdcV5(&ret_value8, p_codec_info)) {
+    lib_ret = lhdc_set_ext_func(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCV5_EXT_FUNC_AR, (bool)ret_value8, NULL, 0);
+    if (lib_ret != LHDCV5_FRET_SUCCESS) {
+      LOG_ERROR(LOG_TAG, "%s: [lib_ret] lhdc_set_ext_func AR(0x%X) %d", __func__, LHDCV5_EXT_FUNC_AR, lib_ret);
+      goto fail;
+    }
+  }
+
+  if (A2DP_VendorHasJASFlagLhdcV5(&ret_value8, p_codec_info)) {
+    lib_ret = lhdc_set_ext_func(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCV5_EXT_FUNC_JAS, (bool)ret_value8, NULL, 0);
+    if (lib_ret != LHDCV5_FRET_SUCCESS) {
+      LOG_ERROR(LOG_TAG, "%s: [lib_ret] lhdc_set_ext_func JAS(0x%X) %d", __func__, LHDCV5_EXT_FUNC_JAS, lib_ret);
+      goto fail;
+    }
+  }
+
+  // Initialize the encoder.
+  // NOTE: MTU in the initialization must include the AVDT media header size.
+  lib_ret = lhdc_init_encoder(
+      a2dp_lhdc_encoder_cb.lhdc_handle,
+      p_encoder_params->sample_rate,
+      p_encoder_params->pcm_fmt,
+      p_encoder_params->quality_mode_index,
+      max_mtu_len,
+      (uint32_t)a2dp_vendor_lhdcv5_get_encoder_interval_ms());
+  if (lib_ret != LHDCV5_FRET_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: [lib_ret] lhdc_init_encoder %d", __func__, lib_ret);
+    goto fail;
+  }
+
+  // setup after encoder initialized
+  lib_ret = lhdc_set_max_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, p_encoder_params->max_target_bitrate);
+  if (lib_ret != LHDCV5_FRET_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: [lib_ret] set_max_bitrate %d", __func__, lib_ret);
+    goto fail;
+  }
+  lib_ret = lhdc_set_min_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, p_encoder_params->min_target_bitrate);
+  if (lib_ret != LHDCV5_FRET_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: [lib_ret] set_min_bitrate %d", __func__, lib_ret);
+    goto fail;
+  }
+  lib_ret = lhdc_set_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, p_encoder_params->quality_mode_index);
+  if (lib_ret != LHDCV5_FRET_SUCCESS) {
+    LOG_ERROR(LOG_TAG, "%s: [lib_ret] set_bitrate %d", __func__, lib_ret);
+    goto fail;
+  }
+
+#if defined(_V5ENC_REC_FILE_)
+  if (recFile == NULL) {
+    recFile = fopen(V5ENC_RAW_NAME,"wb");
+    LOG_DEBUG(LOG_TAG, "%s: create recode file = %p", __func__, recFile);
+  }
+  if (pcmFile == NULL) {
+    pcmFile = fopen(V5ENC_PCM_NAME,"wb");
+    LOG_DEBUG(LOG_TAG, "%s: create recode file = %p", __func__, pcmFile);
+  }
+#endif
+  return;
+
+  fail:
+  if (a2dp_lhdc_encoder_cb.lhdc_handle) {
+    a2dp_vendor_lhdcv5_encoder_cleanup();
+  }
+}
+
+//tA2DP_ENCODER_INTERFACE::(encoder_cleanup)
+void a2dp_vendor_lhdcv5_encoder_cleanup(void) {
+  if (a2dp_lhdc_encoder_cb.has_lhdc_handle && a2dp_lhdc_encoder_cb.lhdc_handle) {
+    int32_t lib_ret = lhdc_free_handle(a2dp_lhdc_encoder_cb.lhdc_handle);
+    if (lib_ret != LHDCV5_FRET_SUCCESS) {
+      LOG_ERROR(LOG_TAG, "%s: free handle error %d", __func__, lib_ret);
+      return;
+    }
+  } else {
+    LOG_DEBUG(LOG_TAG, "%s: nothing to clean", __func__);
+    return;
+  }
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+
+#if defined(_V5ENC_REC_FILE_)
+  if (recFile != NULL) {
+    fclose(recFile);
+    recFile = NULL;
+    remove(V5ENC_RAW_NAME);
+  }
+  if (pcmFile != NULL) {
+    fclose(pcmFile);
+    pcmFile = NULL;
+    remove(V5ENC_PCM_NAME);
+  }
+#endif
+
+  LOG_DEBUG(LOG_TAG, "%s: encoder cleaned up", __func__);
+}
+
+//tA2DP_ENCODER_INTERFACE::(feeding_reset)
+void a2dp_vendor_lhdcv5_feeding_reset(void) {
+  /* By default, just clear the entire state */
+  memset(&a2dp_lhdc_encoder_cb.lhdc_feeding_state, 0,
+      sizeof(a2dp_lhdc_encoder_cb.lhdc_feeding_state));
+
+  uint32_t encoder_interval = (uint32_t)a2dp_vendor_lhdcv5_get_encoder_interval_ms();
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick =
+      (a2dp_lhdc_encoder_cb.feeding_params.sample_rate *
+          a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8 *
+          a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+          encoder_interval) / 1000;
+  a2dp_lhdc_encoder_cb.buf_seq = 0;
+  a2dp_lhdc_encoder_cb.bytes_read = 0;
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us = 0;
+
+  tA2DP_LHDCV5_ENCODER_PARAMS* p_encoder_params = &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+  if (p_encoder_params->quality_mode_index == LHDCV5_QUALITY_AUTO) {
+    if(lhdc_set_bitrate != NULL && a2dp_lhdc_encoder_cb.has_lhdc_handle) {
+      LOG_DEBUG(LOG_TAG, "%s: reset ABR!", __func__);
+      lhdc_set_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCV5_QUALITY_RESET_AUTO);
+    }
+  }
+
+  LOG_DEBUG(LOG_TAG, "%s: PCM bytes per tick %u, reset timestamp", __func__,
+      a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick);
+}
+
+//tA2DP_ENCODER_INTERFACE::(feeding_flush)
+void a2dp_vendor_lhdcv5_feeding_flush(void) {
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter = 0;
+  LOG_DEBUG(LOG_TAG, "%s", __func__);
+}
+
+//tA2DP_ENCODER_INTERFACE::(get_encoder_interval_ms)
+uint64_t a2dp_vendor_lhdcv5_get_encoder_interval_ms(void) {
+  LOG_DEBUG(LOG_TAG, "%s: A2DP_LHDC_ENCODER_INTERVAL_MS %u",  __func__,
+      a2dp_lhdc_encoder_cb.lhdc_encoder_params.isLLEnabled ? A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS : A2DP_LHDC_ENCODER_INTERVAL_MS);
+
+  if (a2dp_lhdc_encoder_cb.lhdc_encoder_params.isLLEnabled){
+    return A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS;
+  }else{
+    return A2DP_LHDC_ENCODER_INTERVAL_MS;
+  }
+}
+
+//tA2DP_ENCODER_INTERFACE::(send_frames)
+void a2dp_vendor_lhdcv5_send_frames(uint64_t timestamp_us) {
+  uint8_t nb_frame = 0;
+  uint8_t nb_iterations = 0;
+
+  a2dp_lhdcv5_get_num_frame_iteration(&nb_iterations, &nb_frame, timestamp_us);
+  LOG_VERBOSE(LOG_TAG, "%s: Sending %d frames per iteration, %d iterations",
+      __func__, nb_frame, nb_iterations);
+
+  if (nb_frame == 0) return;
+
+  for (uint8_t counter = 0; counter < nb_iterations; counter++) {
+    // Transcode frame and enqueue
+    a2dp_lhdcV5_encode_frames(nb_frame);
+  }
+}
+
+// Obtains the number of frames to send and number of iterations
+// to be used. |num_of_iterations| and |num_of_frames| parameters
+// are used as output param for returning the respective values.
+static void a2dp_lhdcv5_get_num_frame_iteration(uint8_t* num_of_iterations,
+    uint8_t* num_of_frames,
+    uint64_t timestamp_us) {
+
+  uint32_t result = 0;
+  uint8_t nof = 0;
+  uint8_t noi = 1;
+  uint32_t pcm_bytes_per_frame = 0;
+  uint32_t samples_per_frame = 0;
+  int32_t lib_ret = 0;
+
+  lib_ret = lhdc_get_block_size(a2dp_lhdc_encoder_cb.lhdc_handle, &samples_per_frame);
+  if (lib_ret != LHDCV5_FRET_SUCCESS) {
+    LOG_DEBUG(LOG_TAG, "%s: get block size error %d", __func__, lib_ret);
+    return;
+  }
+
+  pcm_bytes_per_frame = samples_per_frame *
+      a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+      a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
+
+  uint32_t encoder_interval = (uint32_t)a2dp_vendor_lhdcv5_get_encoder_interval_ms();
+  uint32_t us_this_tick = encoder_interval * 1000;
+  uint64_t now_us = timestamp_us;
+
+  // not the first time, calculate time offset
+  if (a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us != 0) {
+    us_this_tick = (now_us - a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us);
+  }
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us = now_us;
+
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter +=
+      a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick * us_this_tick /
+      (encoder_interval * 1000);
+
+  result =
+      a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter / pcm_bytes_per_frame;
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter -=
+      result * pcm_bytes_per_frame;
+  nof = result;
+
+  LOG_DEBUG(LOG_TAG, "%s: samples_per_frame=%u pcm_bytes_per_frame=%u nb_frame=%u",
+      __func__, samples_per_frame, pcm_bytes_per_frame, nof);
+
+  *num_of_frames = nof;
+  *num_of_iterations = noi;
+}
+
+static BT_HDR *bt_buf_new( void) {
+  BT_HDR *p_buf = ( BT_HDR*)osi_malloc(BT_DEFAULT_BUFFER_SIZE);
+  if ( p_buf == NULL) {
+    // LeoKu(C): should not happen
+    LOG_ERROR( LOG_TAG, "%s: bt_buf_new failed!", __func__);
+    return NULL;
+  }
+
+  p_buf->offset = A2DP_LHDC_OFFSET;
+  p_buf->len = 0;
+  p_buf->layer_specific = 0;
+  return p_buf;
+}
+
+static void a2dp_lhdcV5_encode_frames(uint8_t nb_frame){
+  static float mtu_usage = 0;
+  static int mtu_usage_cnt = 0;
+  static uint32_t time_prev = bluetooth::common::time_get_os_boottime_ms();
+  static uint32_t all_send_bytes = 0;
+  uint8_t read_buffer[LHDCV5_MAX_SAMPLE_FRAME * 2 * 4];
+  uint32_t samples_per_frame = 0;
+  uint32_t out_frames = 0;
+  uint8_t remain_nb_frame = nb_frame;
+  uint32_t written = 0;
+  uint32_t bytes_read = 0;
+  uint8_t *packet = nullptr;
+  BT_HDR *p_buf = nullptr;
+  int32_t lib_ret = 0;
+  uint32_t pcm_bytes_per_frame = 0;
+  uint32_t max_mtu_len = 0;
+
+  uint32_t written_frame = 0;
+  uint32_t temp_bytes_read = 0;
+
+  lib_ret = lhdc_get_block_size(a2dp_lhdc_encoder_cb.lhdc_handle, &samples_per_frame);
+  if (lib_ret != LHDCV5_FRET_SUCCESS) {
+    LOG_DEBUG(LOG_TAG, "%s: [lib_ret] lhdc_get_block_size error %d", __func__, lib_ret);
+    return;
+  }
+  pcm_bytes_per_frame = samples_per_frame *
+      a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+      a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
+
+  if (pcm_bytes_per_frame > sizeof(read_buffer)) {
+    LOG_ERROR(LOG_TAG, "%s: expected read size error", __func__);
+    return;
+  }
+
+  // check codec handle existed
+  if (!a2dp_lhdc_encoder_cb.has_lhdc_handle || !a2dp_lhdc_encoder_cb.lhdc_handle) {
+    LOG_ERROR(LOG_TAG, "%s: encoder handle invalid error", __func__);
+    return;
+  }
+
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+  max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN - 1);
+#else
+  max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN);
+#endif
+
+  while (nb_frame) {
+    // create a temp output buffer
+    if ((p_buf = bt_buf_new()) == NULL) {
+      LOG_ERROR(LOG_TAG, "%s: create buf error", __func__);
+      return;
+    }
+
+    written_frame = 0;
+    do {
+      temp_bytes_read = 0;
+      // read from feeding buffer
+      if (a2dp_lhdcv5_read_feeding(read_buffer, &temp_bytes_read)) {
+        a2dp_lhdc_encoder_cb.bytes_read += temp_bytes_read;
+        packet = (uint8_t*)(p_buf + 1) + p_buf->offset + p_buf->len;
+
+#if defined(_V5ENC_REC_FILE_)
+        if (pcmFile != NULL) {
+          fwrite(read_buffer, sizeof(uint8_t), pcm_bytes_per_frame, pcmFile);
+        }
+#endif
+
+        LOG_DEBUG(LOG_TAG, "%s: nb_frame(%d) to encode...", __func__, nb_frame);
+        // to encode
+        lib_ret = lhdc_encode_func(a2dp_lhdc_encoder_cb.lhdc_handle,
+            read_buffer, temp_bytes_read,
+            packet, (BT_DEFAULT_BUFFER_SIZE-(p_buf->offset + p_buf->len + sizeof(BT_HDR))),
+            &written, &out_frames);
+
+        if (lib_ret != LHDCV5_FRET_SUCCESS) {
+          LOG_ERROR(LOG_TAG, "%s: [lib_ret] lhdc_encode_func error %d", __func__, lib_ret);
+          a2dp_lhdc_encoder_cb.stats.media_read_total_dropped_packets++;
+          osi_free(p_buf);
+          return;
+        }
+
+#if defined(_V5ENC_REC_FILE_)
+        if (recFile != NULL && written > 0) {
+          fwrite(packet, sizeof(uint8_t), written, recFile);
+        }
+#endif
+        LOG_DEBUG(LOG_TAG, "%s: nb_frame(%d) - written:%d, out_frames:%d", __func__,
+            nb_frame, written, out_frames);
+        p_buf->len += written;
+        all_send_bytes += written;
+        nb_frame--;
+        written_frame += out_frames;  // added a frame to the buffer
+      } else {
+        LOG_DEBUG(LOG_TAG, "%s: nb_frame(%d) - underflow", __func__, nb_frame);
+        a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter +=
+            nb_frame * samples_per_frame *
+            a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+            a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
+        // no more pcm to read
+        nb_frame = 0;
+      }
+    } while ((written == 0) && nb_frame);
+
+    if (p_buf->len) {
+      /*
+       * Timestamp of the media packet header represent the TS of the
+       * first frame, i.e the timestamp before including this frame.
+       */
+      p_buf->layer_specific = a2dp_lhdc_encoder_cb.buf_seq++;
+      p_buf->layer_specific <<= 8;
+      p_buf->layer_specific |= ((written_frame << A2DP_LHDC_HDR_NUM_SHIFT));
+
+      *( ( uint32_t*)( p_buf + 1)) = a2dp_lhdc_encoder_cb.timestamp;
+      LOG_VERBOSE(LOG_TAG, "%s: Timestamp (%d)", __func__, a2dp_lhdc_encoder_cb.timestamp);
+
+      a2dp_lhdc_encoder_cb.timestamp += (written_frame * samples_per_frame);
+
+      remain_nb_frame = nb_frame;
+      LOG_DEBUG(LOG_TAG, "%s: nb_frame(%d) - remain_nb_frame:%d", __func__, (nb_frame+1), remain_nb_frame);
+
+      mtu_usage += ((float)p_buf->len) / max_mtu_len;
+      mtu_usage_cnt++;
+
+      LOG_DEBUG(LOG_TAG, "%s: Bytes read for pkt(%d)", __func__, a2dp_lhdc_encoder_cb.bytes_read);
+      LOG_DEBUG(LOG_TAG, "%s: Output frames(%d) encoded pkt len(%d)", __func__, written_frame, p_buf->len);
+      bytes_read = a2dp_lhdc_encoder_cb.bytes_read;
+      a2dp_lhdc_encoder_cb.bytes_read = 0;
+
+      if (!a2dp_lhdc_encoder_cb.enqueue_callback(p_buf, 1, bytes_read))
+        return;
+    } else {
+      LOG_DEBUG(LOG_TAG, "%s: free buffer len(%d)", __func__, p_buf->len);
+      a2dp_lhdc_encoder_cb.stats.media_read_total_dropped_packets++;
+      osi_free(p_buf);
+    }
+  }
+
+  // for statistics
+  uint32_t now_ms = bluetooth::common::time_get_os_boottime_ms();
+  if (now_ms - time_prev >= 1000 ) {
+    LOG_DEBUG(LOG_TAG, "%s: current data rate about %d kbps, packet usage %.2f%%", __func__,
+        (all_send_bytes * 8) / 1000, (mtu_usage * 100)/mtu_usage_cnt);
+    all_send_bytes = 0;
+    mtu_usage_cnt = 0;
+    mtu_usage = 0;
+    time_prev = now_ms;
+  }
+}
+
+static bool a2dp_lhdcv5_read_feeding(uint8_t* read_buffer, uint32_t *bytes_read) {
+  uint32_t read_size = 0;
+  uint32_t samples_per_frame = 0;
+  uint32_t bytes_per_sample =
+      a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+      a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
+  uint32_t nb_byte_read;
+
+  if (read_buffer == nullptr || bytes_read == nullptr) {
+    LOG_ERROR(LOG_TAG, "%s: null input", __func__);
+    return false;
+  }
+
+  int32_t lib_ret = lhdc_get_block_size(a2dp_lhdc_encoder_cb.lhdc_handle, &samples_per_frame);
+  if (lib_ret != LHDCV5_FRET_SUCCESS) {
+    LOG_DEBUG(LOG_TAG, "%s: [lib_ret] lhdc_get_block_size error %d", __func__, lib_ret);
+    return false;
+  }
+  read_size = samples_per_frame * bytes_per_sample;
+
+  a2dp_lhdc_encoder_cb.stats.media_read_total_expected_reads_count++;
+  a2dp_lhdc_encoder_cb.stats.media_read_total_expected_read_bytes += read_size;
+
+  /* Read Data from UIPC channel */
+  nb_byte_read =
+      a2dp_lhdc_encoder_cb.read_callback(read_buffer, read_size);
+  LOG_DEBUG(LOG_TAG, "%s: expected read bytes %u, actual read bytes %u",
+      __func__, read_size, nb_byte_read);
+
+  //TODO: what to do if not alignment?
+  if ((nb_byte_read % bytes_per_sample) != 0) {
+    LOG_DEBUG(LOG_TAG, "%s: PCM data not alignment. The audio sample is shfit %d bytes!",
+        __func__, (nb_byte_read % bytes_per_sample));
+  }
+  a2dp_lhdc_encoder_cb.stats.media_read_total_actual_read_bytes += nb_byte_read;
+
+  // if actual read < want to read
+  if (nb_byte_read < read_size) {
+    if (nb_byte_read == 0) return false;
+
+    /* Fill the unfilled part of the read buffer with silence (0) */
+    memset(((uint8_t*)read_buffer) + nb_byte_read, 0, read_size - nb_byte_read);
+    nb_byte_read = read_size;
+  }
+  a2dp_lhdc_encoder_cb.stats.media_read_total_actual_reads_count++;
+  *bytes_read = nb_byte_read;
+
+  return true;
+}
+
+// library index mapping: quality mode index
+static std::string quality_mode_index_to_name(uint32_t quality_mode_index) {
+  switch (quality_mode_index) {
+  case LHDCV5_QUALITY_HIGH1:
+    return "HIGH1_1000";
+  case LHDCV5_QUALITY_HIGH:
+    return "HIGH_900";
+  case LHDCV5_QUALITY_MID:
+    return "MID_500";
+  case LHDCV5_QUALITY_LOW:
+    return "LOW_400";
+  case LHDCV5_QUALITY_LOW4:
+    return "LOW_320";
+  case LHDCV5_QUALITY_LOW3:
+    return "LOW_256";
+  case LHDCV5_QUALITY_LOW2:
+    return "LOW_192";
+  case LHDCV5_QUALITY_LOW1:
+    return "LOW_128";
+  case LHDCV5_QUALITY_LOW0:
+    return "LOW_64";
+  case LHDCV5_QUALITY_AUTO:
+    return "ABR";
+  default:
+    return "Unknown";
+  }
+}
+
+//tA2DP_ENCODER_INTERFACE::(set_transmit_queue_length)
+void a2dp_vendor_lhdcv5_set_transmit_queue_length(size_t transmit_queue_length) {
+  int32_t lib_ret = 0;
+
+  a2dp_lhdc_encoder_cb.TxQueueLength = transmit_queue_length;
+  tA2DP_LHDCV5_ENCODER_PARAMS* p_encoder_params = &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+  LOG_VERBOSE(LOG_TAG, "%s: transmit_queue_length %zu", __func__, transmit_queue_length);
+
+  if (p_encoder_params->quality_mode_index == LHDCV5_QUALITY_AUTO) {
+    LOG_VERBOSE(LOG_TAG, "%s: Auto Bitrate Enabled!", __func__);
+    if (lhdc_auto_adjust_bitrate != NULL) {
+      lib_ret = lhdc_auto_adjust_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, (uint32_t)transmit_queue_length);
+      if (lib_ret != LHDCV5_FRET_SUCCESS){
+        LOG_ERROR(LOG_TAG, "%s: [lib_ret] lhdc_auto_adjust_bitrate error %d", __func__, lib_ret);
+      }
+    }
+  }
+}
+
+uint64_t A2dpCodecConfigLhdcV5Source::encoderIntervalMs() const {
+  return a2dp_vendor_lhdcv5_get_encoder_interval_ms();
+}
+
+int A2dpCodecConfigLhdcV5Source::getEffectiveMtu() const {
+  return a2dp_lhdc_encoder_cb.TxAaMtuSize;
+}
+
+void A2dpCodecConfigLhdcV5Source::debug_codec_dump(int fd) {
+  a2dp_lhdcv5_encoder_stats_t* stats = &a2dp_lhdc_encoder_cb.stats;
+  tA2DP_LHDCV5_ENCODER_PARAMS* p_encoder_params =
+      &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+
+  uint32_t lib_value = 0;
+  int32_t lib_ret = 0;
+
+  A2dpCodecConfig::debug_codec_dump(fd);
+
+  dprintf(fd,
+      "  Packet counts (expected/dropped)                        : %zu / "
+      "%zu\n",
+      (size_t)stats->media_read_total_expected_packets,
+      (size_t)stats->media_read_total_dropped_packets);
+
+  dprintf(fd,
+      "  PCM read counts (expected/actual)                       : %zu / "
+      "%zu\n",
+      (size_t)stats->media_read_total_expected_reads_count,
+      (size_t)stats->media_read_total_actual_reads_count);
+
+  dprintf(fd,
+      "  PCM read bytes (expected/actual)                        : %zu / "
+      "%zu\n",
+      (size_t)stats->media_read_total_expected_read_bytes,
+      (size_t)stats->media_read_total_actual_read_bytes);
+
+  dprintf(fd,
+      "  LHDC quality mode                                       : %s\n",
+      quality_mode_index_to_name(p_encoder_params->quality_mode_index).c_str());
+
+  lib_ret = lhdc_get_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, &lib_value);
+  if (lib_ret == LHDCV5_FRET_SUCCESS) {
+    dprintf(fd,
+        "  LHDC transmission bitrate (Kbps)                        : %d\n",
+        lib_value);
+  }
+
+  dprintf(fd,
+      "  LHDC saved transmit queue length                        : %zu\n",
+      (size_t)a2dp_lhdc_encoder_cb.TxQueueLength);
+}
+
diff --git a/system/bt/stack/include/a2dp_codec_api.h b/system/bt/stack/include/a2dp_codec_api.h
index 45cbf9ca..e565b3c8 100755
--- a/system/bt/stack/include/a2dp_codec_api.h
+++ b/system/bt/stack/include/a2dp_codec_api.h
@@ -200,6 +200,20 @@ class A2dpCodecConfig {
   virtual bool setPeerCodecCapabilities(
       const uint8_t* p_peer_codec_capabilities) = 0;
 
+  // Savitech Patch - LHDC Extended API Start
+  virtual int getLhdcExtendAPIVersion(
+      A2dpCodecConfig* peerCodec, const char* buf, const int clen) { return 0; }
+
+  virtual int getLhdcExtendAPIConfig(
+      A2dpCodecConfig* peerCodec, const char* buf, const int clen) { return 0; }
+
+  virtual int setLhdcExtendAPIConfig(
+      A2dpCodecConfig* peerCodec, const char* buf, const int clen) { return 0; }
+
+  virtual bool setLhdcExtendAPIData(
+      A2dpCodecConfig* peerCodec, const char* buf, const int clen) { return true; }
+  // Savitech Patch - LHDC Extended API End
+
   // Constructor where |codec_index| is the unique index that identifies the
   // codec. The user-friendly name is |name|.
   // The default codec priority is |codec_priority|. If the value is
@@ -387,6 +401,24 @@ class A2dpCodecs {
                           uint8_t* p_result_codec_config, bool* p_restart_input,
                           bool* p_restart_output, bool* p_config_updated);
 
+  // Savitech Patch - LHDC Extended API Start
+  int getLHDCCodecUserApiVer(
+      A2dpCodecConfig* peerCodec,
+      const char* codecConfig, const int clen);
+
+  int getLHDCCodecUserConfig(
+      A2dpCodecConfig* peerCodec,
+      const char* codecConfig, const int clen);
+
+  int setLHDCCodecUserConfig(
+      A2dpCodecConfig* peerCodec,
+      const char* codecConfig, const int clen);
+
+  bool setLHDCCodecUserData(
+      A2dpCodecConfig* peerCodec,
+      const char* codecData, const int clen);
+  // Savitech Patch - LHDC Extended API End
+
   // Sets the Audio HAL selected audio feeding parameters.
   // Those parameters are applied only to the currently selected codec.
   // |codec_audio_config| contains the selected audio feeding configuration.
diff --git a/system/bt/stack/include/a2dp_vendor_lhdc_constants.h b/system/bt/stack/include/a2dp_vendor_lhdc_constants.h
new file mode 100755
index 00000000..69e3c3ba
--- /dev/null
+++ b/system/bt/stack/include/a2dp_vendor_lhdc_constants.h
@@ -0,0 +1,293 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// A2DP constants for LHDC codec
+//
+
+#ifndef A2DP_VENDOR_LHDC_CONSTANTS_H
+#define A2DP_VENDOR_LHDC_CONSTANTS_H
+#define A2DP_LHDC_SILENCE_LEVEL  1.0f
+#define A2DP_LHDC_VERSION_NUMBER    0x01
+#define A2DP_LHDC_VENDOR_CMD_MASK    0xC000
+#define A2DP_LHDC_VENDOR_FEATURE_MASK    (0xFF000000)
+
+// LHDC Quality Mode Index
+//LHDC not supported auto bit rate now.
+#define A2DP_LHDC_QUALITY_MAGIC_NUM 0x8000
+
+/* LHDC quality supportting new bit rate */
+/* 256kbps, 192kbps, 128kbps, 96kbps, 64kbps */
+#define A2DP_LHDC_QUALITY_MASK   0xFF
+#define A2DP_LHDC_QUALITY_ABR    9   // ABR mode
+#define A2DP_LHDC_QUALITY_HIGH1  8   // 1000kbps (supported in LHDCV5 or higher version)
+#define A2DP_LHDC_QUALITY_HIGH   7   // Equal to LHDCBT_EQMID_HQ 900kbps
+#define A2DP_LHDC_QUALITY_MID    6   // Equal to LHDCBT_EQMID_SQ 500kbps
+#define A2DP_LHDC_QUALITY_LOW    5   // Equal to LHDCBT_EQMID_MQ 400kbps
+#define A2DP_LHDC_QUALITY_LOW4   4   // 320
+#define A2DP_LHDC_QUALITY_LOW3   3   // 256
+#define A2DP_LHDC_QUALITY_LOW2   2   // 192
+#define A2DP_LHDC_QUALITY_LOW1   1   // 128
+#define A2DP_LHDC_QUALITY_LOW0   0   // 64
+
+#define A2DP_LHDC_LATENCY_MAGIC_NUM 0xC000
+#define A2DP_LHDC_LL_ENABLE	  1	// LL enabled
+#define A2DP_LHDC_LL_DISABLE	0	// LL disabled
+
+#define A2DP_LHDC_LATENCY_LOW	0	// 50-100 ms
+#define A2DP_LHDC_LATENCY_MID	1	// default value, 150-200 ms
+#define A2DP_LHDC_LATENCY_HIGH	2	// 300-500 ms
+
+
+// Length of the LHDC Media Payload header
+#define A2DP_LHDC_MPL_HDR_LEN 2
+
+// LHDC Media Payload Header
+#define A2DP_LHDC_HDR_F_MSK 0x80
+#define A2DP_LHDC_HDR_S_MSK 0x40
+#define A2DP_LHDC_HDR_L_MSK 0x20
+
+#define A2DP_LHDCV3_HDR_NUM_MSK 0x0F
+#define A2DP_LHDCV2_HDR_NUM_MSK 0x7
+#define A2DP_LHDCV1_HDR_NUM_MSK 0x7
+#define A2DP_LHDC_HDR_NUM_SHIFT 2
+#define A2DP_LHDCV3_HDR_NUM_MAX 8
+#define A2DP_LHDCV2_HDR_NUM_MAX 7
+#define A2DP_LHDCV1_HDR_NUM_MAX 7
+
+#define A2DP_LHDC_HDR_LATENCY_LOW   0x00
+#define A2DP_LHDC_HDR_LATENCY_MID   0x01
+#define A2DP_LHDC_HDR_LATENCY_HIGH  0x02
+#define A2DP_LHDC_HDR_LATENCY_MSK   0x03
+
+// LHDC codec specific settings
+//#define A2DP_LHDCV3_CODEC_LEN 12
+#define A2DP_LHDCV3_CODEC_LEN 11
+#define A2DP_LHDCV2_CODEC_LEN 11
+#define A2DP_LHDCV1_CODEC_LEN 9
+#define A2DP_LHDC_LL_CODEC_LEN 9
+#define A2DP_LHDCV5_CODEC_LEN 13
+
+// [Octet 0-3] Vendor ID
+#define A2DP_LHDC_VENDOR_ID 0x0000053a
+// [Octet 4-5] Vendor Specific Codec ID
+#define A2DP_LHDCV2_CODEC_ID 0x4C32
+#define A2DP_LHDCV3_CODEC_ID 0x4C33
+#define A2DP_LHDCV1_CODEC_ID 0x484C
+#define A2DP_LHDCV1_LL_CODEC_ID 0x4C4C
+#define A2DP_LHDCV5_CODEC_ID 0x4C35
+
+// [Octet 6], [Bits 0-3] Sampling Frequency
+#define A2DP_LHDC_SAMPLING_FREQ_MASK 0x0F
+#define A2DP_LHDC_SAMPLING_FREQ_44100 0x08
+#define A2DP_LHDC_SAMPLING_FREQ_48000 0x04
+#define A2DP_LHDC_SAMPLING_FREQ_88200 0x02
+#define A2DP_LHDC_SAMPLING_FREQ_96000 0x01
+// [Octet 6], [Bits 3-4] Bit dipth
+#define A2DP_BAD_BITS_PER_SAMPLE    0xff
+#define A2DP_LHDC_BIT_FMT_MASK 	 0x30
+#define A2DP_LHDC_BIT_FMT_24	 0x10
+#define A2DP_LHDC_BIT_FMT_16	 0x20
+
+// [Octet 6], [Bits 6-7] Bit dipth
+#define A2DP_LHDC_FEATURE_AR		0x80
+#define A2DP_LHDC_FEATURE_JAS		0x40
+
+//[Octet 7:bit0..bit3]
+#define A2DP_LHDC_VERSION_MASK 0x0F
+//#define A2DP_LHDC_VERSION_2    0x01
+//#define A2DP_LHDC_VERSION_3    0x02
+//Supported version
+typedef enum {
+    A2DP_LHDC_VER2_BES  = 0,
+    A2DP_LHDC_VER2 = 1,
+    A2DP_LHDC_VER3 = 0x01,
+    A2DP_LHDC_VER4 = 0x02,
+    A2DP_LHDC_VER5 = 0x04,
+    A2DP_LHDC_VER6 = 0x08,
+    A2DP_LHDC_ERROR_VER,
+
+    A2DP_LHDC_LAST_SUPPORTED_VERSION = A2DP_LHDC_VER4,
+} A2DP_LHDC_VERSION;
+
+//[Octet 7:bit4..bit5]
+#define A2DP_LHDC_MAX_BIT_RATE_MASK       0x30
+#define A2DP_LHDC_MAX_BIT_RATE_900K       0x00
+#define A2DP_LHDC_MAX_BIT_RATE_500K       0x10		//500~600K
+#define A2DP_LHDC_MAX_BIT_RATE_400K       0x20
+//[Octet 7:bit6]
+#define A2DP_LHDC_LL_MASK             0x40
+#define A2DP_LHDC_LL_NONE             0x00
+#define A2DP_LHDC_LL_SUPPORTED        0x40
+
+//[Octet 7:bit7]
+#define A2DP_LHDC_FEATURE_LLAC		0x80
+
+//[Octet 8:bit0..bit3]
+#define A2DP_LHDC_CH_SPLIT_MSK        0x0f
+#define A2DP_LHDC_CH_SPLIT_NONE       0x01
+#define A2DP_LHDC_CH_SPLIT_TWS        0x02
+#define A2DP_LHDC_CH_SPLIT_TWS_PLUS   0x04
+
+//[Octet 8:bit4..bit7]
+#define A2DP_LHDC_FEATURE_META		0x10
+#define A2DP_LHDC_FEATURE_MIN_BR	0x20
+#define A2DP_LHDC_FEATURE_LARC		0x40
+#define A2DP_LHDC_FEATURE_LHDCV4	0x80
+
+//For LL used
+#define A2DP_LHDC_CHANNEL_SEPARATION  0x40
+
+
+//Only supported stereo
+#define A2DP_LHDC_CHANNEL_MODE_STEREO 0x03
+
+#define A2DP_LHDC_BITRATE_900K		0x01
+#define A2DP_LHDC_BITRATE_600K		0x02
+#define A2DP_LHDC_BITRATE_400K		0x04
+#define A2DP_LHDC_BITRATE_320K		0x08
+#define A2DP_LHDC_BITRATE_256K		0x10
+#define A2DP_LHDC_BITRATE_192K		0x20
+#define A2DP_LHDC_BITRATE_128K		0x40
+#define A2DP_LHDC_BITRATE_64K		0x80
+#define A2DP_LHDC_BITRATE_ALL		0xff
+
+
+#define A2DP_LHDC_FEATURE_MAGIC_NUM (0x4C000000)
+//LHDC Features: codec config specific field bitmap definition
+//specific2
+#define A2DP_LHDC_LL_ENABLED		0x1ULL
+//specific3
+#define A2DP_LHDC_JAS_ENABLED		0x1ULL
+#define A2DP_LHDC_AR_ENABLED		0x2ULL
+#define A2DP_LHDC_META_ENABLED		0x4ULL
+#define A2DP_LHDC_LLAC_ENABLED		0x8ULL
+#define A2DP_LHDC_MBR_ENABLED		0x10ULL
+#define A2DP_LHDC_LARC_ENABLED		0x20ULL
+#define A2DP_LHDC_V4_ENABLED		0x40ULL
+/* Define the ?th bit(from least significant bit) in the specific, sync with the bitmap definition
+ *  ex: A2DP_LHDC_AR_ENABLED = (2^A2DP_LHDC_AR_SPEC_BIT_POS)
+ * */
+//default in specific2
+#define A2DP_LHDC_LL_SPEC_BIT_POS        (0x0)
+//default in specific3
+#define A2DP_LHDC_JAS_SPEC_BIT_POS       (0x0)
+#define A2DP_LHDC_AR_SPEC_BIT_POS        (0x01)
+#define A2DP_LHDC_META_SPEC_BIT_POS      (0x02)
+#define A2DP_LHDC_LLAC_SPEC_BIT_POS      (0x03)
+#define A2DP_LHDC_MBR_SPEC_BIT_POS       (0x04)
+#define A2DP_LHDC_LARC_SPEC_BIT_POS      (0x05)
+#define A2DP_LHDC_V4_SPEC_BIT_POS        (0x06)
+
+/* bitmap for A2DP codec config selecting */
+#define A2DP_LHDC_TO_A2DP_CODEC_CONFIG_         0x1ULL      //codec_config_
+#define A2DP_LHDC_TO_A2DP_CODEC_CAP_            0x2ULL      //codec_capability_
+#define A2DP_LHDC_TO_A2DP_CODEC_LOCAL_CAP_      0x4ULL      //codec_local_capability_
+#define A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_     0x8ULL      //codec_selectable_capability_
+#define A2DP_LHDC_TO_A2DP_CODEC_USER_           0x10ULL     //codec_user_config_
+#define A2DP_LHDC_TO_A2DP_CODEC_AUDIO_          0x20ULL     //codec_audio_config_
+
+#define SETUP_A2DP_SPEC(cfg, spec, has, value)  do{   \
+  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC1_INDEX ) \
+    (has) ? (cfg->codec_specific_1 |= value) : (cfg->codec_specific_1 &= ~value);   \
+  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC2_INDEX ) \
+    (has) ? (cfg->codec_specific_2 |= value) : (cfg->codec_specific_2 &= ~value);   \
+  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX ) \
+    (has) ? (cfg->codec_specific_3 |= value) : (cfg->codec_specific_3 &= ~value);   \
+  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC4_INDEX ) \
+    (has) ? (cfg->codec_specific_4 |= value) : (cfg->codec_specific_4 &= ~value);   \
+} while(0)
+
+#define CHECK_IN_A2DP_SPEC(cfg, spec, value)  do{   \
+  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC1_INDEX ) \
+    return (cfg->codec_specific_1 & value);   \
+  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC2_INDEX ) \
+    return (cfg->codec_specific_2 & value);   \
+  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX ) \
+    return (cfg->codec_specific_3 & value);   \
+  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC4_INDEX ) \
+    return (cfg->codec_specific_4 & value);   \
+  return false;   \
+} while(0)
+
+// TODO: return version macro to replace LHDC_CHECK_IN_A2DP_SPEC
+#define LHDCV3_CHECK_IN_A2DP_SPEC(cfg, spec, value)  ({ \
+  bool marco_ret = false; \
+  do{   \
+    if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC1_INDEX ) \
+      marco_ret = (cfg->codec_specific_1 & value);   \
+    if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC2_INDEX ) \
+      marco_ret = (cfg->codec_specific_2 & value);   \
+    if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX ) \
+      marco_ret = (cfg->codec_specific_3 & value);   \
+    if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC4_INDEX ) \
+      marco_ret = (cfg->codec_specific_4 & value);   \
+    } while(0);  \
+  marco_ret;   \
+})
+
+//
+// Savitech - LHDC aDSP configuration
+//
+// Lhdcv5Version: 1 << (below value-1)
+#define A2DP_OFFLOAD_LHDCV2_VER_1                   0x01
+#define A2DP_OFFLOAD_LHDCV3_V3_ONLY                 0x02
+#define A2DP_OFFLOAD_LHDCV3_V4_ONLY                 0x03
+#define A2DP_OFFLOAD_LHDCV3_LLAC                    0x04
+#define A2DP_OFFLOAD_LHDCV5_VER_1                   0x01
+
+// Lhdcv5QualityIndex
+#define A2DP_OFFLOAD_LHDC_QUALITY_LOW0            0x01
+#define A2DP_OFFLOAD_LHDC_QUALITY_LOW1            0x02
+#define A2DP_OFFLOAD_LHDC_QUALITY_LOW2            0x04
+#define A2DP_OFFLOAD_LHDC_QUALITY_LOW3            0x08
+#define A2DP_OFFLOAD_LHDC_QUALITY_LOW4            0x10
+#define A2DP_OFFLOAD_LHDC_QUALITY_LOW             0x20
+#define A2DP_OFFLOAD_LHDC_QUALITY_MID             0x40
+#define A2DP_OFFLOAD_LHDC_QUALITY_HIGH            0x80
+#define A2DP_OFFLOAD_LHDC_QUALITY_HIGH1           0x100
+#define A2DP_OFFLOAD_LHDC_QUALITY_ABR             0x8000
+
+// Lhdcv5FrameDuration
+#define A2DP_OFFLOAD_LHDC_FRAME_DURATION_5000US   0x01
+
+// Lhdcv5DataInterval
+#define A2DP_OFFLOAD_LHDC_DATA_INTERVAL_20MS      0x01
+#define A2DP_OFFLOAD_LHDC_DATA_INTERVAL_10MS      0x02
+
+// Lhdcv5Specific
+#define A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_AR     0x01
+#define A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_JAS    0x02
+#define A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_META   0x04
+
+#define A2DP_OFFLOAD_LHDC_SPECIFIC_ACTION_AR_ON   0x01
+#define A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_SPLIT  0x80
+
+// Lhdcv5Parameters
+#define A2DP_OFFLOAD_LHDC_CFG_VER                   6
+#define A2DP_OFFLOAD_LHDC_CFG_BITRATE_L             7
+#define A2DP_OFFLOAD_LHDC_CFG_BITRATE_H             8
+#define A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L          9
+#define A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H          10
+#define A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L          11
+#define A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H          12
+#define A2DP_OFFLOAD_LHDC_CFG_FRAMEDUR              13
+#define A2DP_OFFLOAD_LHDC_CFG_INTERVAL              14
+#define A2DP_OFFLOAD_LHDC_CFG_SPEC1                 15
+#define A2DP_OFFLOAD_LHDC_CFG_SPEC2                 16
+#define A2DP_OFFLOAD_LHDC_CFG_META                  17
+
+#endif  // A2DP_VENDOR_LHDC_CONSTANTS_H
diff --git a/system/bt/stack/include/a2dp_vendor_lhdcv1.h b/system/bt/stack/include/a2dp_vendor_lhdcv1.h
new file mode 100755
index 00000000..68dc6eb2
--- /dev/null
+++ b/system/bt/stack/include/a2dp_vendor_lhdcv1.h
@@ -0,0 +1,171 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// A2DP Codec API for LHDC
+//
+
+#ifndef A2DP_VENDOR_LHDCV1_H
+#define A2DP_VENDOR_LHDCV1_H
+
+#include "a2dp_codec_api.h"
+#include "a2dp_vendor_lhdc_constants.h"
+#include "a2dp_vendor_lhdcv1_constants.h"
+#include "avdt_api.h"
+
+class A2dpCodecConfigLhdcV1 : public A2dpCodecConfig {
+ public:
+  A2dpCodecConfigLhdcV1(btav_a2dp_codec_priority_t codec_priority);
+  virtual ~A2dpCodecConfigLhdcV1();
+
+  bool init() override;
+  uint64_t encoderIntervalMs() const override;
+  int getEffectiveMtu() const override;
+  bool setCodecConfig(const uint8_t* p_peer_codec_info, bool is_capability,
+                      uint8_t* p_result_codec_config) override;
+  bool setPeerCodecCapabilities(
+      const uint8_t* p_peer_codec_capabilities) override;
+
+ private:
+  bool useRtpHeaderMarkerBit() const override;
+  bool updateEncoderUserConfig(
+      const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+      bool* p_restart_input, bool* p_restart_output,
+      bool* p_config_updated) override;
+  void debug_codec_dump(int fd) override;
+};
+
+// Checks whether the codec capabilities contain a valid A2DP LHDC Source
+// codec.
+// NOTE: only codecs that are implemented are considered valid.
+// Returns true if |p_codec_info| contains information about a valid LHDC
+// codec, otherwise false.
+bool A2DP_IsVendorSourceCodecValidLhdcV1(const uint8_t* p_codec_info);
+
+// Checks whether the codec capabilities contain a valid peer A2DP LHDC Sink
+// codec.
+// NOTE: only codecs that are implemented are considered valid.
+// Returns true if |p_codec_info| contains information about a valid LHDC
+// codec, otherwise false.
+bool A2DP_IsVendorPeerSinkCodecValidLhdcV1(const uint8_t* p_codec_info);
+
+// Checks whether the A2DP data packets should contain RTP header.
+// |content_protection_enabled| is true if Content Protection is
+// enabled. |p_codec_info| contains information about the codec capabilities.
+// Returns true if the A2DP data packets should contain RTP header, otherwise
+// false.
+bool A2DP_VendorUsesRtpHeaderLhdcV1(bool content_protection_enabled,
+                                  const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC codec name for a given |p_codec_info|.
+const char* A2DP_VendorCodecNameLhdcV1(const uint8_t* p_codec_info);
+
+// Checks whether two A2DP LHDC codecs |p_codec_info_a| and |p_codec_info_b|
+// have the same type.
+// Returns true if the two codecs have the same type, otherwise false.
+bool A2DP_VendorCodecTypeEqualsLhdcV1(const uint8_t* p_codec_info_a,
+                                    const uint8_t* p_codec_info_b);
+
+// Checks whether two A2DP LHDC codecs |p_codec_info_a| and |p_codec_info_b|
+// are exactly the same.
+// Returns true if the two codecs are exactly the same, otherwise false.
+// If the codec type is not LHDC, the return value is false.
+bool A2DP_VendorCodecEqualsLhdcV1(const uint8_t* p_codec_info_a,
+                                const uint8_t* p_codec_info_b);
+
+// Gets the track sample rate value for the A2DP LHDC codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the track sample rate on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetTrackSampleRateLhdcV1(const uint8_t* p_codec_info);
+
+// Gets the bits per audio sample for the A2DP LHDC codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the bits per audio sample on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetTrackBitsPerSampleLhdcV1(const uint8_t* p_codec_info);
+
+// Gets the channel count for the A2DP LHDC codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the channel count on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetTrackChannelCountLhdcV1(const uint8_t* p_codec_info);
+
+// Gets the channel mode code for the A2DP LHDC codec.
+// The actual value is codec-specific - see |A2DP_LHDC_CHANNEL_MODE_*|.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the channel mode code on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetChannelModeCodeLhdcV1(const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC audio data timestamp from an audio packet.
+// |p_codec_info| contains the codec information.
+// |p_data| contains the audio data.
+// The timestamp is stored in |p_timestamp|.
+// Returns true on success, otherwise false.
+bool A2DP_VendorGetPacketTimestampLhdcV1(const uint8_t* p_codec_info,
+                                       const uint8_t* p_data,
+                                       uint32_t* p_timestamp);
+
+// Builds A2DP LHDC codec header for audio data.
+// |p_codec_info| contains the codec information.
+// |p_buf| contains the audio data.
+// |frames_per_packet| is the number of frames in this packet.
+// Returns true on success, otherwise false.
+bool A2DP_VendorBuildCodecHeaderLhdcV1(const uint8_t* p_codec_info, BT_HDR* p_buf,
+                                     uint16_t frames_per_packet);
+
+
+// Decodes A2DP LHDC codec info into a human readable string.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns a string describing the codec information.
+std::string A2DP_VendorCodecInfoStringLhdcV1(const uint8_t* p_codec_info);
+
+// New feature to check codec info is supported Channel Separation.
+bool A2DP_VendorGetChannelSeparation(const uint8_t* p_codec_info);
+
+// Decodes and displays LHDC codec info (for debugging).
+// |p_codec_info| is a pointer to the LHDC codec_info to decode and display.
+void A2DP_VendorDumpCodecInfoLhdcV1(const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC encoder interface that can be used to encode and prepare
+// A2DP packets for transmission - see |tA2DP_ENCODER_INTERFACE|.
+// |p_codec_info| contains the codec information.
+// Returns the A2DP LHDC encoder interface if the |p_codec_info| is valid and
+// supported, otherwise NULL.
+const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterfaceLhdcV1(
+    const uint8_t* p_codec_info);
+
+// Adjusts the A2DP LHDC codec, based on local support and Bluetooth
+// specification.
+// |p_codec_info| contains the codec information to adjust.
+// Returns true if |p_codec_info| is valid and supported, otherwise false.
+bool A2DP_VendorAdjustCodecLhdcV1(uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC Source codec index for a given |p_codec_info|.
+// Returns the corresponding |btav_a2dp_codec_index_t| on success,
+// otherwise |BTAV_A2DP_CODEC_INDEX_MAX|.
+btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndexLhdcV1(
+    const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC Source codec name.
+const char* A2DP_VendorCodecIndexStrLhdcV1(void);
+
+// Initializes A2DP LHDC Source codec information into |tAVDT_CFG|
+// configuration entry pointed by |p_cfg|.
+bool A2DP_VendorInitCodecConfigLhdcV1(AvdtpSepConfig* p_cfg);
+
+#endif  // A2DP_VENDOR_LHDCV1_H
diff --git a/system/bt/stack/include/a2dp_vendor_lhdcv1_constants.h b/system/bt/stack/include/a2dp_vendor_lhdcv1_constants.h
new file mode 100755
index 00000000..d9c98493
--- /dev/null
+++ b/system/bt/stack/include/a2dp_vendor_lhdcv1_constants.h
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// A2DP constants for LHDC codec
+//
+
+#ifndef A2DP_VENDOR_LHDCV1_CONSTANTS_H
+#define A2DP_VENDOR_LHDCV1_CONSTANTS_H
+
+#define A2DP_LHDCV1_VENDOR_CMD_MASK    0xC000
+
+// LHDC Quality Mode Index
+//LHDC not supported auto bit rate now.
+//#define A2DP_LHDCV1_QUALITY_MAGIC_NUM 0x8000
+//#define A2DP_LHDCV1_QUALITY_ABR    8   // ABR mode, range: 990,660,492,396,330(kbps)
+//#define A2DP_LHDCV1_QUALITY_HIGH   7   // Equal to LHDCBT_EQMID_HQ 900kbps
+//#define A2DP_LHDCV1_QUALITY_MID    6   // Equal to LHDCBT_EQMID_SQ 500/560kbps
+//#define A2DP_LHDCV1_QUALITY_LOW    5   // Equal to LHDCBT_EQMID_MQ 400kbps
+//#define A2DP_LHDCV1_QUALITY_LOW4   4   //
+//#define A2DP_LHDCV1_QUALITY_LOW3   3
+//#define A2DP_LHDCV1_QUALITY_LOW2   2
+//#define A2DP_LHDCV1_QUALITY_LOW1   1
+//#define A2DP_LHDCV1_QUALITY_LOW0   0
+
+#define A2DP_LHDCV1_LATENCY_MAGIC_NUM 0xC000
+//#define A2DP_LHDCV1_LATENCY_LOW	0	// 50-100 ms
+//#define A2DP_LHDCV1_LATENCY_MID	1	// default value, 150-200 ms
+//#define A2DP_LHDCV1_LATENCY_HIGH	2	// 300-500 ms
+
+// Length of the LHDC Media Payload header
+//#define A2DP_LHDCV1_MPL_HDR_LEN 2
+
+// LHDC Media Payload Header
+//#define A2DP_LHDCV1_HDR_F_MSK 0x80
+//#define A2DP_LHDCV1_HDR_S_MSK 0x40
+//#define A2DP_LHDCV1_HDR_L_MSK 0x20
+//#define A2DP_LHDCV1_HDR_NUM_MSK 0x7
+//#define A2DP_LHDCV1_HDR_NUM_SHIFT 2
+//#define A2DP_LHDCV1_HDR_NUM_MAX 7
+
+//#define A2DP_LHDCV1_HDR_LATENCY_LOW   0x00
+//#define A2DP_LHDCV1_HDR_LATENCY_MID   0x01
+//#define A2DP_LHDCV1_HDR_LATENCY_HIGH  0x02
+//#define A2DP_LHDCV1_HDR_LATENCY_MSK   0x03
+
+// LHDC codec specific settings
+//#define A2DP_LHDCV1_CODEC_LEN 9
+// [Octet 0-3] Vendor ID
+//#define A2DP_LHDCV1_VENDOR_ID 0x0000053a
+// [Octet 4-5] Vendor Specific Codec ID
+// [Octet 6], [Bits 0-3] Sampling Frequency
+//#define A2DP_LHDCV1_SAMPLING_FREQ_MASK 0x0F
+//#define A2DP_LHDCV1_SAMPLING_FREQ_44100 0x08
+//#define A2DP_LHDCV1_SAMPLING_FREQ_48000 0x04
+//#define A2DP_LHDCV1_SAMPLING_FREQ_88200 0x02
+//#define A2DP_LHDCV1_SAMPLING_FREQ_96000 0x01
+
+// [Octet 6], [Bits 3-4] Bit dipth
+#define A2DP_LHDCV1_BIT_FMT_MASK 	 0x30
+//#define A2DP_LHDCV1_BIT_FMT_24	 0x10
+//#define A2DP_LHDCV1_BIT_FMT_16	 0x20
+
+#define A2DP_LHDCV1_CHANNEL_SEPARATION  0x40
+
+
+
+//#define A2DP_LHDCV1_CHANNEL_MODE_MASK 0x07
+//#define A2DP_LHDCV1_CHANNEL_MODE_MONO 0x04
+//#define A2DP_LHDCV1_CHANNEL_MODE_DUAL 0x02
+//#define A2DP_LHDCV1_CHANNEL_MODE_STEREO 0x01
+
+
+#endif  // A2DP_VENDOR_LHDCV1_CONSTANTS_H
diff --git a/system/bt/stack/include/a2dp_vendor_lhdcv1_encoder.h b/system/bt/stack/include/a2dp_vendor_lhdcv1_encoder.h
new file mode 100755
index 00000000..86da05b6
--- /dev/null
+++ b/system/bt/stack/include/a2dp_vendor_lhdcv1_encoder.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// Interface to the A2DP LHDC Encoder
+//
+
+#ifndef A2DP_VENDOR_LHDCV1_ENCODER_H
+#define A2DP_VENDOR_LHDCV1_ENCODER_H
+
+#include "a2dp_codec_api.h"
+
+// Loads the A2DP LHDC encoder.
+// Return true on success, otherwise false.
+bool A2DP_VendorLoadEncoderLhdcV1(void);
+
+// Unloads the A2DP LHDC encoder.
+void A2DP_VendorUnloadEncoderLhdcV1(void);
+
+// Initialize the A2DP LHDC encoder.
+// |p_peer_params| contains the A2DP peer information
+// The current A2DP codec config is in |a2dp_codec_config|.
+// |read_callback| is the callback for reading the input audio data.
+// |enqueue_callback| is the callback for enqueueing the encoded audio data.
+void a2dp_vendor_lhdcV1_encoder_init(
+    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+    A2dpCodecConfig* a2dp_codec_config,
+    a2dp_source_read_callback_t read_callback,
+    a2dp_source_enqueue_callback_t enqueue_callback);
+
+// Cleanup the A2DP LHDC encoder.
+void a2dp_vendor_lhdcV1_encoder_cleanup(void);
+
+// Reset the feeding for the A2DP LHDC encoder.
+void a2dp_vendor_lhdcV1_feeding_reset(void);
+
+// Flush the feeding for the A2DP LHDC encoder.
+void a2dp_vendor_lhdcV1_feeding_flush(void);
+
+// Get the A2DP LHDC encoder interval (in milliseconds).
+uint64_t a2dp_vendor_lhdcV1_get_encoder_interval_ms(void);
+
+// Prepare and send A2DP LHDC encoded frames.
+// |timestamp_us| is the current timestamp (in microseconds).
+void a2dp_vendor_lhdcV1_send_frames(uint64_t timestamp_us);
+
+// Set transmit queue length for the A2DP LHDC ABR(Adaptive Bit Rate) mechanism.
+void a2dp_vendor_lhdcV1_set_transmit_queue_length(size_t transmit_queue_length);
+
+#endif  // A2DP_VENDOR_LHDCV1_ENCODER_H
diff --git a/system/bt/stack/include/a2dp_vendor_lhdcv2.h b/system/bt/stack/include/a2dp_vendor_lhdcv2.h
new file mode 100755
index 00000000..5576d12f
--- /dev/null
+++ b/system/bt/stack/include/a2dp_vendor_lhdcv2.h
@@ -0,0 +1,183 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// A2DP Codec API for LHDC
+//
+
+#ifndef A2DP_VENDOR_LHDCV2_H
+#define A2DP_VENDOR_LHDCV2_H
+
+#include "a2dp_codec_api.h"
+#include "a2dp_vendor_lhdc_constants.h"
+#include "avdt_api.h"
+
+
+class A2dpCodecConfigLhdcV2 : public A2dpCodecConfig {
+ public:
+  bool copySinkCapability(uint8_t * codec_info);
+  A2dpCodecConfigLhdcV2(btav_a2dp_codec_priority_t codec_priority);
+  virtual ~A2dpCodecConfigLhdcV2();
+
+  bool init() override;
+  uint64_t encoderIntervalMs() const override;
+  int getEffectiveMtu() const override;
+  bool setCodecConfig(const uint8_t* p_peer_codec_info, bool is_capability,
+                      uint8_t* p_result_codec_config) override;
+  bool setPeerCodecCapabilities(
+      const uint8_t* p_peer_codec_capabilities) override;
+
+
+ private:
+  bool useRtpHeaderMarkerBit() const override;
+  bool updateEncoderUserConfig(
+      const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+      bool* p_restart_input, bool* p_restart_output,
+      bool* p_config_updated) override;
+  void debug_codec_dump(int fd) override;
+};
+
+bool A2DP_VendorGetLowLatencyEnabledLhdcV2();
+// Checks whether the codec capabilities contain a valid A2DP LHDC Source
+// codec.
+// NOTE: only codecs that are implemented are considered valid.
+// Returns true if |p_codec_info| contains information about a valid LHDC
+// codec, otherwise false.
+bool A2DP_IsVendorSourceCodecValidLhdcV2(const uint8_t* p_codec_info);
+
+// Checks whether the codec capabilities contain a valid peer A2DP LHDC Sink
+// codec.
+// NOTE: only codecs that are implemented are considered valid.
+// Returns true if |p_codec_info| contains information about a valid LHDC
+// codec, otherwise false.
+bool A2DP_IsVendorPeerSinkCodecValidLhdcV2(const uint8_t* p_codec_info);
+
+// Checks whether the A2DP data packets should contain RTP header.
+// |content_protection_enabled| is true if Content Protection is
+// enabled. |p_codec_info| contains information about the codec capabilities.
+// Returns true if the A2DP data packets should contain RTP header, otherwise
+// false.
+bool A2DP_VendorUsesRtpHeaderLhdcV2(bool content_protection_enabled,
+                                  const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC codec name for a given |p_codec_info|.
+const char* A2DP_VendorCodecNameLhdcV2(const uint8_t* p_codec_info);
+
+// Checks whether two A2DP LHDC codecs |p_codec_info_a| and |p_codec_info_b|
+// have the same type.
+// Returns true if the two codecs have the same type, otherwise false.
+bool A2DP_VendorCodecTypeEqualsLhdcV2(const uint8_t* p_codec_info_a,
+                                    const uint8_t* p_codec_info_b);
+
+// Checks whether two A2DP LHDC codecs |p_codec_info_a| and |p_codec_info_b|
+// are exactly the same.
+// Returns true if the two codecs are exactly the same, otherwise false.
+// If the codec type is not LHDC, the return value is false.
+bool A2DP_VendorCodecEqualsLhdcV2(const uint8_t* p_codec_info_a,
+                                const uint8_t* p_codec_info_b);
+
+// Gets the track sample rate value for the A2DP LHDC codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the track sample rate on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetTrackSampleRateLhdcV2(const uint8_t* p_codec_info);
+
+// Gets the bits per audio sample for the A2DP LHDC codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the bits per audio sample on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetTrackBitsPerSampleLhdcV2(const uint8_t* p_codec_info);
+
+// Gets the channel count for the A2DP LHDC codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the channel count on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetTrackChannelCountLhdcV2(const uint8_t* p_codec_info);
+
+// Gets the channel mode code for the A2DP LHDC codec.
+// The actual value is codec-specific - see |A2DP_LHDC_CHANNEL_MODE_*|.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the channel mode code on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetChannelModeCodeLhdcV2(const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC audio data timestamp from an audio packet.
+// |p_codec_info| contains the codec information.
+// |p_data| contains the audio data.
+// The timestamp is stored in |p_timestamp|.
+// Returns true on success, otherwise false.
+bool A2DP_VendorGetPacketTimestampLhdcV2(const uint8_t* p_codec_info,
+                                       const uint8_t* p_data,
+                                       uint32_t* p_timestamp);
+
+// Builds A2DP LHDC codec header for audio data.
+// |p_codec_info| contains the codec information.
+// |p_buf| contains the audio data.
+// |frames_per_packet| is the number of frames in this packet.
+// Returns true on success, otherwise false.
+bool A2DP_VendorBuildCodecHeaderLhdcV2(const uint8_t* p_codec_info, BT_HDR* p_buf,
+                                     uint16_t frames_per_packet);
+
+// Decodes A2DP LHDC codec info into a human readable string.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns a string describing the codec information.
+std::string A2DP_VendorCodecInfoStringLhdcV2(const uint8_t* p_codec_info);
+
+// New feature to check codec info is supported Channel Separation.
+int8_t A2DP_VendorGetChannelSplitModeLhdcV2(const uint8_t* p_codec_info);
+
+bool A2DP_VendorGetLowLatencyStateLhdcV2(const uint8_t* p_codec_info);
+int16_t A2DP_VendorGetMaxDatarateLhdcV2(const uint8_t* p_codec_info);
+uint8_t A2DP_VendorGetVersionLhdcV2(const uint8_t* p_codec_info);
+
+// Decodes and displays LHDC codec info (for debugging).
+// |p_codec_info| is a pointer to the LHDC codec_info to decode and display.
+void A2DP_VendorDumpCodecInfoLhdcV2(const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC encoder interface that can be used to encode and prepare
+// A2DP packets for transmission - see |tA2DP_ENCODER_INTERFACE|.
+// |p_codec_info| contains the codec information.
+// Returns the A2DP LHDC encoder interface if the |p_codec_info| is valid and
+// supported, otherwise NULL.
+const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterfaceLhdcV2(
+    const uint8_t* p_codec_info);
+
+// Adjusts the A2DP LHDC codec, based on local support and Bluetooth
+// specification.
+// |p_codec_info| contains the codec information to adjust.
+// Returns true if |p_codec_info| is valid and supported, otherwise false.
+bool A2DP_VendorAdjustCodecLhdcV2(uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC Source codec index for a given |p_codec_info|.
+// Returns the corresponding |btav_a2dp_codec_index_t| on success,
+// otherwise |BTAV_A2DP_CODEC_INDEX_MAX|.
+btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndexLhdcV2(
+    const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC Source codec name.
+const char* A2DP_VendorCodecIndexStrLhdcV2(void);
+
+// Initializes A2DP LHDC Source codec information into |tAVDT_CFG|
+// configuration entry pointed by |p_cfg|.
+
+bool A2DP_VendorInitCodecConfigLhdcV2(AvdtpSepConfig* p_cfg);
+// Gets the track bitrate value for the A2DP LHDCV2 codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the track bit rate on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetBitRateLhdcV2(const uint8_t* p_codec_info);
+
+#endif  // A2DP_VENDOR_LHDCV2_H
diff --git a/system/bt/stack/include/a2dp_vendor_lhdcv2_encoder.h b/system/bt/stack/include/a2dp_vendor_lhdcv2_encoder.h
new file mode 100755
index 00000000..0d762cd8
--- /dev/null
+++ b/system/bt/stack/include/a2dp_vendor_lhdcv2_encoder.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// Interface to the A2DP LHDC Encoder
+//
+
+#ifndef A2DP_VENDOR_LHDCV2_ENCODER_H
+#define A2DP_VENDOR_LHDCV2_ENCODER_H
+
+#include "a2dp_codec_api.h"
+
+// Loads the A2DP LHDC encoder.
+// Return true on success, otherwise false.
+bool A2DP_VendorLoadEncoderLhdcV2(void);
+
+// Unloads the A2DP LHDC encoder.
+void A2DP_VendorUnloadEncoderLhdcV2(void);
+
+// Initialize the A2DP LHDC encoder.
+// |p_peer_params| contains the A2DP peer information
+// The current A2DP codec config is in |a2dp_codec_config|.
+// |read_callback| is the callback for reading the input audio data.
+// |enqueue_callback| is the callback for enqueueing the encoded audio data.
+void a2dp_vendor_lhdcv2_encoder_init(
+    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+    A2dpCodecConfig* a2dp_codec_config,
+    a2dp_source_read_callback_t read_callback,
+    a2dp_source_enqueue_callback_t enqueue_callback);
+
+// Cleanup the A2DP LHDC encoder.
+void a2dp_vendor_lhdcv2_encoder_cleanup(void);
+
+// Reset the feeding for the A2DP LHDC encoder.
+void a2dp_vendor_lhdcv2_feeding_reset(void);
+
+// Flush the feeding for the A2DP LHDC encoder.
+void a2dp_vendor_lhdcv2_feeding_flush(void);
+
+// Get the A2DP LHDC encoder interval (in milliseconds).
+uint64_t a2dp_vendor_lhdcv2_get_encoder_interval_ms(void);
+
+// Prepare and send A2DP LHDC encoded frames.
+// |timestamp_us| is the current timestamp (in microseconds).
+void a2dp_vendor_lhdcv2_send_frames(uint64_t timestamp_us);
+
+// Set transmit queue length for the A2DP LHDC ABR(Adaptive Bit Rate) mechanism.
+void a2dp_vendor_lhdcv2_set_transmit_queue_length(size_t transmit_queue_length);
+
+#endif  // A2DP_VENDOR_LHDCV2_ENCODER_H
diff --git a/system/bt/stack/include/a2dp_vendor_lhdcv3.h b/system/bt/stack/include/a2dp_vendor_lhdcv3.h
new file mode 100755
index 00000000..dd8afaf1
--- /dev/null
+++ b/system/bt/stack/include/a2dp_vendor_lhdcv3.h
@@ -0,0 +1,328 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// A2DP Codec API for LHDC
+//
+
+#ifndef A2DP_VENDOR_LHDCV3_H
+#define A2DP_VENDOR_LHDCV3_H
+
+#include "a2dp_codec_api.h"
+#include "a2dp_vendor_lhdc_constants.h"
+#include "avdt_api.h"
+
+#ifdef LOG_NDEBUG
+#undef LOG_NDEBUG
+#define LOG_NDEBUG 1	//set 0 to turn on VERBOSE LOG
+#endif
+
+/** Start of LHDC A2DP-Related API definition ***************************************/
+#define EXTEND_FUNC_CODE_GET_SPECIFIC                   ((unsigned int) 0x0A010001)
+#define EXTEND_FUNC_VER_GET_SPECIFIC_V1                 ((unsigned int) 0x01000000)
+#define EXTEND_FUNC_VER_GET_SPECIFIC_V2                 ((unsigned int) 0x02000000)
+#define LHDC_EXTEND_FUNC_CODE_A2DP_TYPE_MASK            (0x0A)
+#define LHDC_EXTEND_FUNC_CODE_LIB_TYPE_MASK             (0x0C)
+
+/* ************************************************************************
+ * Version info: EXTEND_FUNC_CODE_GET_SPECIFIC
+ * EXTEND_FUNC_VER_GET_SPECIFIC_V1:  Total Size: 41 bytes
+   * API Version:                   (4 bytes)
+   * API Code:                      (4 bytes)
+   * A2DP Codec Config Code:        (1 bytes)
+   * A2dp Specific1:                (8 bytes)
+   * A2dp Specific2:                (8 bytes)
+   * A2dp Specific3:                (8 bytes)
+   * A2dp Specific4:                (8 bytes)
+ * EXTEND_FUNC_VER_GET_SPECIFIC_V2:  Total Size: 64 bytes
+   * API Version:                   (4 bytes)
+   * API Code:                      (4 bytes)
+   * A2DP Codec Config Code:        (1 bytes)
+   * Reserved:                      (7 bytes)
+   * A2dp Specific1:                (8 bytes)
+   * A2dp Specific2:                (8 bytes)
+   * A2dp Specific3:                (8 bytes)
+   * A2dp Specific4:                (8 bytes)
+   * Capabilities Metadata sub fields:  (7*2 bytes)
+     * sub[0~1]:    JAS
+     * sub[2~3]:    AR
+     * sub[4~5]:    META
+     * sub[6~7]:    LLAC
+     * sub[8~9]:    MBR
+     * sub[10~11]:  LARC
+     * sub[12~13]:  LHDCV4
+   * Padded:                        (2 bytes)
+ * ************************************************************************/
+#define LHDC_EXTEND_FUNC_CONFIG_API_VERSION_SIZE        4       /* API version */
+#define LHDC_EXTEND_FUNC_CONFIG_API_CODE_SIZE           4       /* API index code */
+#define LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_SIZE       1       /* A2DP codec config code */
+#define LHDC_EXTEND_FUNC_CONFIG_RESERVED_V2             7       /* V2 Reserved bytes */
+#define LHDC_EXTEND_FUNC_CONFIG_SPECIFIC1_SIZE          8       /* Specific 1 */
+#define LHDC_EXTEND_FUNC_CONFIG_SPECIFIC2_SIZE          8       /* Specific 2 */
+#define LHDC_EXTEND_FUNC_CONFIG_SPECIFIC3_SIZE          8       /* Specific 3 */
+#define LHDC_EXTEND_FUNC_CONFIG_SPECIFIC4_SIZE          8       /* Specific 4 */
+/* Capabilities metadata fields(2 bytes for each tuple) */
+#define LHDC_EXTEND_FUNC_CONFIG_CAPMETA_SIZE_V2         (7<<1)  /* V2 Capabilities */
+#define LHDC_EXTEND_FUNC_CONFIG_PADDED_SIZE_V2          2       /* V2 Padded Fields */
+
+/* Total size of buffer */
+#define LHDC_EXTEND_FUNC_CONFIG_TOTAL_FIXED_SIZE_V1    (LHDC_EXTEND_FUNC_CONFIG_API_VERSION_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_API_CODE_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC1_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC2_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC3_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC4_SIZE)
+#define LHDC_EXTEND_FUNC_CONFIG_TOTAL_FIXED_SIZE_V2    (LHDC_EXTEND_FUNC_CONFIG_API_VERSION_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_API_CODE_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_RESERVED_V2 + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC1_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC2_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC3_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC4_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_CAPMETA_SIZE_V2 + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_PADDED_SIZE_V2)
+/* Head of each field */
+#define LHDC_EXTEND_FUNC_CONFIG_API_VERSION_HEAD        (0)
+#define LHDC_EXTEND_FUNC_CONFIG_API_CODE_HEAD           (LHDC_EXTEND_FUNC_CONFIG_API_VERSION_HEAD + 4)  //4
+#define LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD       (LHDC_EXTEND_FUNC_CONFIG_API_CODE_HEAD + 4)     //8
+/* Following part in V1 */
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V1        (LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD + 1) //9~16
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V1        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V1 + 8)  //17~24
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V1        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V1 + 8)  //25~32
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V1        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V1 + 8)  //33~40
+/* Following part in V2 */
+#define LHDC_EXTEND_FUNC_A2DP_RESERVED_HEAD_V2          (LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD + 1) //9~15
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V2        (LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD + 8) //16~23
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V2        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V2 + 8)  //24~31
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V2        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V2 + 8)  //32~39
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V2        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V2 + 8)  //40~47
+#define LHDC_EXTEND_FUNC_A2DP_CAPMETA_HEAD_V2           (LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V2 + 8)  //48~61
+#define LHDC_EXTEND_FUNC_A2DP_PADDED_HEAD_V2            (LHDC_EXTEND_FUNC_A2DP_CAPMETA_HEAD_V2 + LHDC_EXTEND_FUNC_CONFIG_CAPMETA_SIZE_V2)   //62~63
+
+
+/* code definition mapping to A2DP codec specific in a2dp_codec_api.h
+ * 0x01: codec_config_
+ * 0x02: codec_capability_
+ * 0x03: codec_local_capability_
+ * 0x04: codec_selectable_capability_
+ * 0x05: codec_user_config_
+ * 0x06: codec_audio_config_
+ */
+#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_FINAL_CFG          (0x01)
+#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_FINAL_CAP          (0x02)
+#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_LOCAL_CAP          (0x03)
+#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_SELECTABLE_CAP     (0x04)
+#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_USER_CFG           (0x05)
+#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_AUDIO_CFG          (0x06)
+
+
+/************************
+ * Capability Meta Format: (denotes where source capabilities bits are stored in specifics)
+   * Capability Code:                   (1 byte)
+   * Saving Position Info:              (1 byte)
+ ************************/
+/* Capabilities's code: */
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE      (0x01)
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE       (0x02)
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE     (0x03)
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE     (0x04)
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE      (0x05)
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE     (0x06)
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE       (0x07)
+
+/* Capabilities's saving position Info:
+ *  1. in which specific                        (represented in leftmost 2-bits)
+ *  2. at which bit position of the specific    (represented in rightmost 6-bits)
+ * */
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFIC1_INDEX    (0x00)     //2-bit:00
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFIC2_INDEX    (0x40)     //2-bit:01
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX    (0x80)     //2-bit:10
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFIC4_INDEX    (0xC0)     //2-bit:11
+/** End of LHDC A2DP-Related API definition ***************************************/
+
+
+class A2dpCodecConfigLhdcV3 : public A2dpCodecConfig {
+ public:
+  bool copySinkCapability(uint8_t * codec_info);
+  A2dpCodecConfigLhdcV3(btav_a2dp_codec_priority_t codec_priority);
+  virtual ~A2dpCodecConfigLhdcV3();
+
+  bool init() override;
+  uint64_t encoderIntervalMs() const override;
+  int getEffectiveMtu() const override;
+  bool setCodecConfig(const uint8_t* p_peer_codec_info, bool is_capability,
+                      uint8_t* p_result_codec_config) override;
+  bool setPeerCodecCapabilities(
+      const uint8_t* p_peer_codec_capabilities) override;
+
+  static int getEncoderExtendFuncUserApiVer(const char* version, const int clen);
+  static int getEncoderExtendFuncUserConfig(const char* userConfig, const int clen);
+  static int setEncoderExtendFuncUserConfig(const char* userConfig, const int clen);
+  static bool setEncoderExtendFuncUserData(const char* userData, const int clen);
+
+ private:
+  bool useRtpHeaderMarkerBit() const override;
+  bool updateEncoderUserConfig(
+      const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+      bool* p_restart_input, bool* p_restart_output,
+      bool* p_config_updated) override;
+  void debug_codec_dump(int fd) override;
+};
+
+bool A2DP_VendorGetLowLatencyEnabledLhdcV3();
+// Checks whether the codec capabilities contain a valid A2DP LHDC Source
+// codec.
+// NOTE: only codecs that are implemented are considered valid.
+// Returns true if |p_codec_info| contains information about a valid LHDC
+// codec, otherwise false.
+bool A2DP_IsVendorSourceCodecValidLhdcV3(const uint8_t* p_codec_info);
+
+// Checks whether the codec capabilities contain a valid peer A2DP LHDC Sink
+// codec.
+// NOTE: only codecs that are implemented are considered valid.
+// Returns true if |p_codec_info| contains information about a valid LHDC
+// codec, otherwise false.
+bool A2DP_IsVendorPeerSinkCodecValidLhdcV3(const uint8_t* p_codec_info);
+
+// Checks whether the A2DP data packets should contain RTP header.
+// |content_protection_enabled| is true if Content Protection is
+// enabled. |p_codec_info| contains information about the codec capabilities.
+// Returns true if the A2DP data packets should contain RTP header, otherwise
+// false.
+bool A2DP_VendorUsesRtpHeaderLhdcV3(bool content_protection_enabled,
+                                  const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC codec name for a given |p_codec_info|.
+const char* A2DP_VendorCodecNameLhdcV3(const uint8_t* p_codec_info);
+
+// Checks whether two A2DP LHDC codecs |p_codec_info_a| and |p_codec_info_b|
+// have the same type.
+// Returns true if the two codecs have the same type, otherwise false.
+bool A2DP_VendorCodecTypeEqualsLhdcV3(const uint8_t* p_codec_info_a,
+                                    const uint8_t* p_codec_info_b);
+
+// Checks whether two A2DP LHDC codecs |p_codec_info_a| and |p_codec_info_b|
+// are exactly the same.
+// Returns true if the two codecs are exactly the same, otherwise false.
+// If the codec type is not LHDC, the return value is false.
+bool A2DP_VendorCodecEqualsLhdcV3(const uint8_t* p_codec_info_a,
+                                const uint8_t* p_codec_info_b);
+
+// Gets the track sample rate value for the A2DP LHDC codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the track sample rate on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetTrackSampleRateLhdcV3(const uint8_t* p_codec_info);
+
+// Gets the bits per audio sample for the A2DP LHDC codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the bits per audio sample on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetTrackBitsPerSampleLhdcV3(const uint8_t* p_codec_info);
+
+// Gets the channel count for the A2DP LHDC codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the channel count on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetTrackChannelCountLhdcV3(const uint8_t* p_codec_info);
+
+// Gets the channel mode code for the A2DP LHDC codec.
+// The actual value is codec-specific - see |A2DP_LHDC_CHANNEL_MODE_*|.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the channel mode code on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetChannelModeCodeLhdcV3(const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC audio data timestamp from an audio packet.
+// |p_codec_info| contains the codec information.
+// |p_data| contains the audio data.
+// The timestamp is stored in |p_timestamp|.
+// Returns true on success, otherwise false.
+bool A2DP_VendorGetPacketTimestampLhdcV3(const uint8_t* p_codec_info,
+                                       const uint8_t* p_data,
+                                       uint32_t* p_timestamp);
+
+// Builds A2DP LHDC codec header for audio data.
+// |p_codec_info| contains the codec information.
+// |p_buf| contains the audio data.
+// |frames_per_packet| is the number of frames in this packet.
+// Returns true on success, otherwise false.
+bool A2DP_VendorBuildCodecHeaderLhdcV3(const uint8_t* p_codec_info, BT_HDR* p_buf,
+                                     uint16_t frames_per_packet);
+
+// Decodes A2DP LHDC codec info into a human readable string.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns a string describing the codec information.
+std::string A2DP_VendorCodecInfoStringLhdcV3(const uint8_t* p_codec_info);
+
+// New feature to check codec info is supported Channel Separation.
+int8_t A2DP_VendorGetChannelSplitModeLhdcV3(const uint8_t* p_codec_info);
+
+bool A2DP_VendorGetLowLatencyStateLhdcV3(const uint8_t* p_codec_info);
+int16_t A2DP_VendorGetMaxDatarateLhdcV3(const uint8_t* p_codec_info);
+uint8_t A2DP_VendorGetVersionLhdcV3(const uint8_t* p_codec_info);
+
+bool A2DP_VendorHasV4FlagLhdcV3(const uint8_t* p_codec_info);
+bool A2DP_VendorHasLLACFlagLhdcV3(const uint8_t* p_codec_info);
+
+bool A2DP_VendorHasJASFlagLhdcV3(const uint8_t* p_codec_info);
+bool A2DP_VendorHasARFlagLhdcV3(const uint8_t* p_codec_info);
+bool A2DP_VendorHasMETAFlagLhdcV3(const uint8_t* p_codec_info);
+bool A2DP_VendorHasMinBRFlagLhdcV3(const uint8_t* p_codec_info);
+bool A2DP_VendorHasLARCFlagLhdcV3(const uint8_t* p_codec_info);
+
+// Decodes and displays LHDC codec info (for debugging).
+// |p_codec_info| is a pointer to the LHDC codec_info to decode and display.
+void A2DP_VendorDumpCodecInfoLhdcV3(const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC encoder interface that can be used to encode and prepare
+// A2DP packets for transmission - see |tA2DP_ENCODER_INTERFACE|.
+// |p_codec_info| contains the codec information.
+// Returns the A2DP LHDC encoder interface if the |p_codec_info| is valid and
+// supported, otherwise NULL.
+const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterfaceLhdcV3(
+    const uint8_t* p_codec_info);
+
+// Adjusts the A2DP LHDC codec, based on local support and Bluetooth
+// specification.
+// |p_codec_info| contains the codec information to adjust.
+// Returns true if |p_codec_info| is valid and supported, otherwise false.
+bool A2DP_VendorAdjustCodecLhdcV3(uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC Source codec index for a given |p_codec_info|.
+// Returns the corresponding |btav_a2dp_codec_index_t| on success,
+// otherwise |BTAV_A2DP_CODEC_INDEX_MAX|.
+btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndexLhdcV3(
+    const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC Source codec name.
+const char* A2DP_VendorCodecIndexStrLhdcV3(void);
+
+// Initializes A2DP LHDC Source codec information into |tAVDT_CFG|
+// configuration entry pointed by |p_cfg|.
+bool A2DP_VendorInitCodecConfigLhdcV3(AvdtpSepConfig* p_cfg);
+
+bool A2DP_VendorGetSrcCapVectorLhdcv3(uint8_t* capVector);
+
+// Gets the track bitrate value for the A2DP LHDCV3 codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the track bit rate on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetBitRateLhdcV3(const uint8_t* p_codec_info);
+
+#endif  // A2DP_VENDOR_LHDCV3_H
diff --git a/system/bt/stack/include/a2dp_vendor_lhdcv3_dec.h b/system/bt/stack/include/a2dp_vendor_lhdcv3_dec.h
new file mode 100755
index 00000000..697ca3b6
--- /dev/null
+++ b/system/bt/stack/include/a2dp_vendor_lhdcv3_dec.h
@@ -0,0 +1,187 @@
+/*
+ * Copyright 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// A2DP Codec API for low complexity subband codec (SBC)
+//
+
+#ifndef A2DP_VENDOR_LHDCV3_DEC_H
+#define A2DP_VENDOR_LHDCV3_DEC_H
+
+#include "a2dp_codec_api.h"
+#include "a2dp_vendor_lhdc_constants.h"
+#include "avdt_api.h"
+
+class A2dpCodecConfigLhdcV3Base : public A2dpCodecConfig {
+ protected:
+  A2dpCodecConfigLhdcV3Base(btav_a2dp_codec_index_t codec_index,
+                         const std::string& name,
+                         btav_a2dp_codec_priority_t codec_priority,
+                         bool is_source)
+      : A2dpCodecConfig(codec_index, name, codec_priority),
+        is_source_(is_source) {}
+  bool setCodecConfig(const uint8_t* p_peer_codec_info, bool is_capability,
+                      uint8_t* p_result_codec_config) override;
+  bool setPeerCodecCapabilities(
+      const uint8_t* p_peer_codec_capabilities) override;
+
+ private:
+  bool is_source_;  // True if local is Source
+};
+
+
+class A2dpCodecConfigLhdcV3Sink : public A2dpCodecConfigLhdcV3Base {
+ public:
+  A2dpCodecConfigLhdcV3Sink(btav_a2dp_codec_priority_t codec_priority);
+  virtual ~A2dpCodecConfigLhdcV3Sink();
+
+  bool init() override;
+  uint64_t encoderIntervalMs() const override;
+  int getEffectiveMtu() const override;
+//  bool setCodecConfig(const uint8_t* p_peer_codec_info, bool is_capability,
+//                      uint8_t* p_result_codec_config) override;
+//  bool setPeerCodecCapabilities(
+//      const uint8_t* p_peer_codec_capabilities) override;
+
+ private:
+  bool useRtpHeaderMarkerBit() const override;
+  bool updateEncoderUserConfig(
+      const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+      bool* p_restart_input, bool* p_restart_output,
+      bool* p_config_updated) override;
+};
+
+
+// Checks whether the codec capabilities contain a valid A2DP LHDC V3 Sink codec.
+// NOTE: only codecs that are implemented are considered valid.
+// Returns true if |p_codec_info| contains information about a valid SBC codec,
+// otherwise false.
+bool A2DP_IsVendorSinkCodecValidLhdcV3(const uint8_t* p_codec_info);
+
+// Checks whether the codec capabilities contain a valid peer A2DP SBC Source
+// codec.
+// NOTE: only codecs that are implemented are considered valid.
+// Returns true if |p_codec_info| contains information about a valid SBC codec,
+// otherwise false.
+bool A2DP_IsVendorPeerSourceCodecValidLhdcV3(const uint8_t* p_codec_info);
+
+// Checks whether A2DP SBC Sink codec is supported.
+// |p_codec_info| contains information about the codec capabilities.
+// Returns true if the A2DP SBC Sink codec is supported, otherwise false.
+bool A2DP_IsVendorSinkCodecSupportedLhdcV3(const uint8_t* p_codec_info);
+
+// Checks whether an A2DP SBC Source codec for a peer Source device is
+// supported.
+// |p_codec_info| contains information about the codec capabilities of the
+// peer device.
+// Returns true if the A2DP SBC Source codec for a peer Source device is
+// supported, otherwise false.
+bool A2DP_IsPeerSourceCodecSupportedLhdcV3(const uint8_t* p_codec_info);
+
+// Initialize state with the default A2DP SBC codec.
+// The initialized state with the codec capabilities is stored in
+// |p_codec_info|.
+void A2DP_InitDefaultCodecLhdcV3Sink(uint8_t* p_codec_info);
+
+// Gets the A2DP SBC codec name for a given |p_codec_info|.
+const char* A2DP_VendorCodecNameLhdcV3Sink(const uint8_t* p_codec_info);
+
+// Checks whether two A2DP SBC codecs |p_codec_info_a| and |p_codec_info_b|
+// have the same type.
+// Returns true if the two codecs have the same type, otherwise false.
+bool A2DP_VendorCodecTypeEqualsLhdcV3Sink(const uint8_t* p_codec_info_a,
+                             const uint8_t* p_codec_info_b);
+
+// Checks whether two A2DP SBC codecs |p_codec_info_a| and |p_codec_info_b|
+// are exactly the same.
+// Returns true if the two codecs are exactly the same, otherwise false.
+// If the codec type is not SBC, the return value is false.
+bool A2DP_VendorCodecEqualsLhdcV3Sink(const uint8_t* p_codec_info_a,
+                         const uint8_t* p_codec_info_b);
+
+// Gets the track sample rate value for the A2DP SBC codec.
+// |p_codec_info| is a pointer to the SBC codec_info to decode.
+// Returns the track sample rate on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetTrackSampleRateLhdcV3Sink(const uint8_t* p_codec_info);
+
+// Gets the channel mode code for the A2DP SBC codec.
+// The actual value is codec-specific - see |A2DP_SBC_IE_CH_MD_*|.
+// |p_codec_info| is a pointer to the SBC codec_info to decode.
+// Returns the channel mode code on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetChannelModeCodeLhdcV3Sink(const uint8_t* p_codec_info);
+
+// Gets the channel type for the A2DP SBC Sink codec:
+// 1 for mono, or 3 for dual/stereo/joint.
+// |p_codec_info| is a pointer to the SBC codec_info to decode.
+// Returns the channel type on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetSinkTrackChannelTypeLhdcV3(const uint8_t* p_codec_info);
+
+// Gets the A2DP SBC audio data timestamp from an audio packet.
+// |p_codec_info| contains the codec information.
+// |p_data| contains the audio data.
+// The timestamp is stored in |p_timestamp|.
+// Returns true on success, otherwise false.
+bool A2DP_VendorGetPacketTimestampLhdcV3Sink(const uint8_t* p_codec_info,
+                                const uint8_t* p_data, uint32_t* p_timestamp);
+
+// Builds A2DP SBC codec header for audio data.
+// |p_codec_info| contains the codec information.
+// |p_buf| contains the audio data.
+// |frames_per_packet| is the number of frames in this packet.
+// Returns true on success, otherwise false.
+/*bool A2DP_VendorBuildCodecHeaderLhdcV3Sink(const uint8_t* p_codec_info, BT_HDR* p_buf,
+                              uint16_t frames_per_packet);
+*/
+// Decodes A2DP SBC codec info into a human readable string.
+// |p_codec_info| is a pointer to the SBC codec_info to decode.
+// Returns a string describing the codec information.
+std::string A2DP_VendorCodecInfoStringLhdcV3Sink(const uint8_t* p_codec_info);
+
+// Gets the A2DP SBC decoder interface that can be used to decode received A2DP
+// packets - see |tA2DP_DECODER_INTERFACE|.
+// |p_codec_info| contains the codec information.
+// Returns the A2DP SBC decoder interface if the |p_codec_info| is valid and
+// supported, otherwise NULL.
+const tA2DP_DECODER_INTERFACE* A2DP_VendorGetDecoderInterfaceLhdcV3(
+    const uint8_t* p_codec_info);
+
+// Adjusts the A2DP SBC codec, based on local support and Bluetooth
+// specification.
+// |p_codec_info| contains the codec information to adjust.
+// Returns true if |p_codec_info| is valid and supported, otherwise false.
+bool A2DP_VendorAdjustCodecLhdcV3Sink(uint8_t* p_codec_info);
+
+// Gets the A2DP SBC Source codec index for a given |p_codec_info|.
+// Returns the corresponding |btav_a2dp_codec_index_t| on success,
+// otherwise |BTAV_A2DP_CODEC_INDEX_MAX|.
+btav_a2dp_codec_index_t A2DP_SourceCodecIndexSbc(const uint8_t* p_codec_info);
+
+// Gets the A2DP SBC Sink codec index for a given |p_codec_info|.
+// Returns the corresponding |btav_a2dp_codec_index_t| on success,
+// otherwise |BTAV_A2DP_CODEC_INDEX_MAX|.
+btav_a2dp_codec_index_t A2DP_VendorSinkCodecIndexLhdcV3(const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC V3 Sink codec name.
+const char* A2DP_VendorCodecIndexStrLhdcV3Sink(void);
+
+// Initializes A2DP SBC Sink codec information into |AvdtpSepConfig|
+// configuration entry pointed by |p_cfg|.
+bool A2DP_VendorInitCodecConfigLhdcV3Sink(AvdtpSepConfig* p_cfg);
+
+#endif  // A2DP_VENDOR_LHDCV3_DEC_H
diff --git a/system/bt/stack/include/a2dp_vendor_lhdcv3_decoder.h b/system/bt/stack/include/a2dp_vendor_lhdcv3_decoder.h
new file mode 100755
index 00000000..58b8f143
--- /dev/null
+++ b/system/bt/stack/include/a2dp_vendor_lhdcv3_decoder.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// Interface to the A2DP LHDC V3 Decoder
+//
+
+#ifndef A2DP_VENDOR_LHDCV3_DECODER_H
+#define A2DP_VENDOR_LHDCV3_DECODER_H
+
+#include "a2dp_codec_api.h"
+#include "a2dp_vendor_lhdc_constants.h"
+
+
+
+// Save CODEC information
+// Return true on success, otherwise false.
+bool save_codec_info (const uint8_t* p_codec_info);
+
+// Loads the A2DP LHDC V3 decoder.
+// Return true on success, otherwise false.
+bool A2DP_VendorLoadDecoderLhdcV3(void);
+
+// Unloads the A2DP LHDC V3 decoder.
+void A2DP_VendorUnloadDecoderLhdcV3(void);
+
+// Initialize the A2DP LHDC V3 decoder.
+bool a2dp_vendor_lhdcv3_decoder_init(decoded_data_callback_t decode_callback);
+
+// Cleanup the A2DP LHDC V3 decoder.
+void a2dp_vendor_lhdcv3_decoder_cleanup(void);
+
+// Decodes |p_buf|. Calls |decode_callback| passed into |a2dp_lhdcv3_decoder_init|
+// if decoded frames are available.
+bool a2dp_vendor_lhdcv3_decoder_decode_packet(BT_HDR* p_buf);
+
+// Start the A2DP LHDCV3 decoder.
+void a2dp_vendor_lhdcv3_decoder_start(void);
+
+// Suspend the A2DP LHDCV3 decoder.
+void a2dp_vendor_lhdcv3_decoder_suspend(void);
+
+// A2DP LHDCV3 decoder configuration.
+void a2dp_vendor_lhdcv3_decoder_configure(const uint8_t* p_codec_info);
+
+#endif  // A2DP_VENDOR_LHDCV3_DECODER_H
diff --git a/system/bt/stack/include/a2dp_vendor_lhdcv3_encoder.h b/system/bt/stack/include/a2dp_vendor_lhdcv3_encoder.h
new file mode 100755
index 00000000..e9ea55f9
--- /dev/null
+++ b/system/bt/stack/include/a2dp_vendor_lhdcv3_encoder.h
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// Interface to the A2DP LHDC Encoder
+//
+
+#ifndef A2DP_VENDOR_LHDCV3_ENCODER_H
+#define A2DP_VENDOR_LHDCV3_ENCODER_H
+
+#include "a2dp_codec_api.h"
+
+typedef enum {
+  BTAV_A2DP_CODEC_LHDC_CONFIG_NOTUSED = 0,
+  BTAV_A2DP_CODEC_LHDC_CONFIG_AR,
+  BTAV_A2DP_CODEC_LHDC_CONFIG_META,
+} btav_a2dp_codec_lhdc_ConfigCfg_t;
+
+typedef enum {
+  BTAV_A2DP_CODEC_LHDC_DATA_NOTUSED = 0,
+  BTAV_A2DP_CODEC_LHDC_DATA_GYRO_XY,
+} btav_a2dp_codec_lhdc_DataCfg_t;
+
+// Loads the A2DP LHDC encoder.
+// Return true on success, otherwise false.
+bool A2DP_VendorLoadEncoderLhdcV3(void);
+
+// Unloads the A2DP LHDC encoder.
+void A2DP_VendorUnloadEncoderLhdcV3(void);
+
+// Initialize the A2DP LHDC encoder.
+// |p_peer_params| contains the A2DP peer information
+// The current A2DP codec config is in |a2dp_codec_config|.
+// |read_callback| is the callback for reading the input audio data.
+// |enqueue_callback| is the callback for enqueueing the encoded audio data.
+void a2dp_vendor_lhdcv3_encoder_init(
+    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+    A2dpCodecConfig* a2dp_codec_config,
+    a2dp_source_read_callback_t read_callback,
+    a2dp_source_enqueue_callback_t enqueue_callback);
+
+// Cleanup the A2DP LHDC encoder.
+void a2dp_vendor_lhdcv3_encoder_cleanup(void);
+
+// Reset the feeding for the A2DP LHDC encoder.
+void a2dp_vendor_lhdcv3_feeding_reset(void);
+
+// Flush the feeding for the A2DP LHDC encoder.
+void a2dp_vendor_lhdcv3_feeding_flush(void);
+
+// Get the A2DP LHDC encoder interval (in milliseconds).
+uint64_t a2dp_vendor_lhdcv3_get_encoder_interval_ms(void);
+
+// Prepare and send A2DP LHDC encoded frames.
+// |timestamp_us| is the current timestamp (in microseconds).
+void a2dp_vendor_lhdcv3_send_frames(uint64_t timestamp_us);
+
+// Set transmit queue length for the A2DP LHDC ABR(Adaptive Bit Rate) mechanism.
+void a2dp_vendor_lhdcv3_set_transmit_queue_length(size_t transmit_queue_length);
+
+#endif  // A2DP_VENDOR_LHDCV3_ENCODER_H
diff --git a/system/bt/stack/include/a2dp_vendor_lhdcv5.h b/system/bt/stack/include/a2dp_vendor_lhdcv5.h
new file mode 100755
index 00000000..98b60750
--- /dev/null
+++ b/system/bt/stack/include/a2dp_vendor_lhdcv5.h
@@ -0,0 +1,302 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// A2DP Codec API for LHDCV5
+//
+
+#ifndef A2DP_VENDOR_LHDCV5_H
+#define A2DP_VENDOR_LHDCV5_H
+
+#include "a2dp_codec_api.h"
+#include "a2dp_vendor_lhdc_constants.h"
+#include "a2dp_vendor_lhdcv5_constants.h"
+#include "avdt_api.h"
+
+#define LHDC_LOG_ENABLE
+#ifdef LHDC_LOG_ENABLE
+#define LHDC_LOG_DBG(tag, fmt, args...)     \
+  do {                                      \
+    ALOG(LOG_DEBUG, tag, fmt, ##args);      \
+  } while (0)
+#else
+  #define LHDC_LOG_DBG(tag, fmt, args...)
+#endif
+
+#define IS_SRC  (true)
+#define IS_SNK  (false)
+
+class A2dpCodecConfigLhdcV5Base : public A2dpCodecConfig {
+ protected:
+  	 A2dpCodecConfigLhdcV5Base(btav_a2dp_codec_index_t codec_index,
+                         const std::string& name,
+                         btav_a2dp_codec_priority_t codec_priority,
+                         bool is_source)
+      : A2dpCodecConfig(codec_index, name, codec_priority),
+        is_source_(is_source) {}
+  bool setCodecConfig(const uint8_t* p_peer_codec_info, bool is_capability,
+                      uint8_t* p_result_codec_config) override;
+  bool setPeerCodecCapabilities(
+      const uint8_t* p_peer_codec_capabilities) override;
+
+  int getLhdcExtendAPIVersion(A2dpCodecConfig* peerCodec, const char* buf, const int clen);
+  int getLhdcExtendAPIConfig(A2dpCodecConfig* peerCodec, const char* buf, const int clen);
+  int setLhdcExtendAPIConfig(A2dpCodecConfig* peerCodec, const char* buf, const int clen);
+  bool setLhdcExtendAPIData(A2dpCodecConfig* peerCodec, const char* buf, const int clen);
+
+ private:
+  bool is_source_;  // True if local is Source
+};
+
+class A2dpCodecConfigLhdcV5Source : public A2dpCodecConfigLhdcV5Base {
+ public:
+	A2dpCodecConfigLhdcV5Source(btav_a2dp_codec_priority_t codec_priority);
+	virtual ~A2dpCodecConfigLhdcV5Source();
+
+	bool init() override;
+	uint64_t encoderIntervalMs() const override;
+	int getEffectiveMtu() const override;
+
+  static int getEncoderExtendFuncUserApiVer(const char* version, const int clen);
+  static int getEncoderExtendFuncUserConfig(const char* userConfig, const int clen);
+  static int setEncoderExtendFuncUserConfig(const char* userConfig, const int clen);
+  static bool setEncoderExtendFuncUserData(const char* userData, const int clen);
+
+ private:
+	bool useRtpHeaderMarkerBit() const override;
+	bool updateEncoderUserConfig(
+		 const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+		 bool* p_restart_input, bool* p_restart_output,
+		 bool* p_config_updated) override;
+	void debug_codec_dump(int fd) override;
+};
+
+class A2dpCodecConfigLhdcV5Sink : public A2dpCodecConfigLhdcV5Base {
+public:
+ A2dpCodecConfigLhdcV5Sink(btav_a2dp_codec_priority_t codec_priority);
+ virtual ~A2dpCodecConfigLhdcV5Sink();
+
+ bool init() override;
+ uint64_t encoderIntervalMs() const override;
+ int getEffectiveMtu() const override;
+
+private:
+ bool useRtpHeaderMarkerBit() const override;
+ bool updateEncoderUserConfig(
+		 const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+		 bool* p_restart_input, bool* p_restart_output,
+		 bool* p_config_updated) override;
+};
+
+bool A2DP_VendorGetLowLatencyEnabledLhdcV5();
+// Checks whether the codec capabilities contain a valid A2DP LHDC Source
+// codec.
+// NOTE: only codecs that are implemented are considered valid.
+// Returns true if |p_codec_info| contains information about a valid LHDC
+// codec, otherwise false.
+bool A2DP_IsVendorSourceCodecValidLhdcV5(const uint8_t* p_codec_info);
+
+// Checks whether the codec capabilities contain a valid peer A2DP LHDC Sink
+// codec.
+// NOTE: only codecs that are implemented are considered valid.
+// Returns true if |p_codec_info| contains information about a valid LHDC
+// codec, otherwise false.
+bool A2DP_IsVendorPeerSinkCodecValidLhdcV5(const uint8_t* p_codec_info);
+
+// Checks whether the A2DP data packets should contain RTP header.
+// |content_protection_enabled| is true if Content Protection is
+// enabled. |p_codec_info| contains information about the codec capabilities.
+// Returns true if the A2DP data packets should contain RTP header, otherwise
+// false.
+bool A2DP_VendorUsesRtpHeaderLhdcV5(bool content_protection_enabled,
+                                  const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC codec name for a given |p_codec_info|.
+const char* A2DP_VendorCodecNameLhdcV5(const uint8_t* p_codec_info);
+
+// Checks whether two A2DP LHDC codecs |p_codec_info_a| and |p_codec_info_b|
+// have the same type.
+// Returns true if the two codecs have the same type, otherwise false.
+bool A2DP_VendorCodecTypeEqualsLhdcV5(const uint8_t* p_codec_info_a,
+                                    const uint8_t* p_codec_info_b);
+
+// Checks whether two A2DP LHDC codecs |p_codec_info_a| and |p_codec_info_b|
+// are exactly the same.
+// Returns true if the two codecs are exactly the same, otherwise false.
+// If the codec type is not LHDC, the return value is false.
+bool A2DP_VendorCodecEqualsLhdcV5(const uint8_t* p_codec_info_a,
+                                const uint8_t* p_codec_info_b);
+
+// Gets the track sample rate value for the A2DP LHDC codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the track sample rate on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetTrackSampleRateLhdcV5(const uint8_t* p_codec_info);
+
+// Gets the bits per audio sample for the A2DP LHDC codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the bits per audio sample on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetTrackBitsPerSampleLhdcV5(const uint8_t* p_codec_info);
+
+// Gets the channel count for the A2DP LHDC codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the channel count on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetTrackChannelCountLhdcV5(const uint8_t* p_codec_info);
+
+// Gets the channel mode code for the A2DP LHDC codec.
+// The actual value is codec-specific - see |A2DP_LHDC_CHANNEL_MODE_*|.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the channel mode code on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetChannelModeCodeLhdcV5(const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC audio data timestamp from an audio packet.
+// |p_codec_info| contains the codec information.
+// |p_data| contains the audio data.
+// The timestamp is stored in |p_timestamp|.
+// Returns true on success, otherwise false.
+bool A2DP_VendorGetPacketTimestampLhdcV5(const uint8_t* p_codec_info,
+                                       const uint8_t* p_data,
+                                       uint32_t* p_timestamp);
+
+// Builds A2DP LHDC codec header for audio data.
+// |p_codec_info| contains the codec information.
+// |p_buf| contains the audio data.
+// |frames_per_packet| is the number of frames in this packet.
+// Returns true on success, otherwise false.
+bool A2DP_VendorBuildCodecHeaderLhdcV5(const uint8_t* p_codec_info, BT_HDR* p_buf,
+                                     uint16_t frames_per_packet);
+
+// Decodes A2DP LHDC codec info into a human readable string.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns a string describing the codec information.
+std::string A2DP_VendorCodecInfoStringLhdcV5(const uint8_t* p_codec_info);
+
+// Parse codec info and get the quality mode of the max target bit rate
+// |p_codec_info_| contains the codec information.
+// the translated quality mode from max target bit rate.
+// Returns true if successfully
+bool A2DP_VendorGetMaxBitRateLhdcV5(uint32_t *retval, const uint8_t* p_codec_info);
+bool A2DP_VendorGetMinBitRateLhdcV5(uint32_t *retval, const uint8_t* p_codec_info);
+
+bool A2DP_VendorGetVersionLhdcV5(uint32_t *retval, const uint8_t* p_codec_info);
+bool A2DP_VendorGetBitPerSampleLhdcV5(uint8_t *retval, const uint8_t* p_codec_info);
+
+bool A2DP_VendorHasJASFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info);
+bool A2DP_VendorHasARFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info);
+bool A2DP_VendorHasMETAFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info);
+bool A2DP_VendorHasLLFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info);
+
+// Decodes and displays LHDC codec info (for debugging).
+// |p_codec_info| is a pointer to the LHDC codec_info to decode and display.
+void A2DP_VendorDumpCodecInfoLhdcV5(const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC encoder interface that can be used to encode and prepare
+// A2DP packets for transmission - see |tA2DP_ENCODER_INTERFACE|.
+// |p_codec_info| contains the codec information.
+// Returns the A2DP LHDC encoder interface if the |p_codec_info| is valid and
+// supported, otherwise NULL.
+const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterfaceLhdcV5(
+    const uint8_t* p_codec_info);
+
+// Adjusts the A2DP LHDC codec, based on local support and Bluetooth
+// specification.
+// |p_codec_info| contains the codec information to adjust.
+// Returns true if |p_codec_info| is valid and supported, otherwise false.
+bool A2DP_VendorAdjustCodecLhdcV5(uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC Source codec index for a given |p_codec_info|.
+// Returns the corresponding |btav_a2dp_codec_index_t| on success,
+// otherwise |BTAV_A2DP_CODEC_INDEX_MAX|.
+btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndexLhdcV5(
+    const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC Source codec name.
+const char* A2DP_VendorCodecIndexStrLhdcV5(void);
+
+// Initializes A2DP LHDC Source codec information into |tAVDT_CFG|
+// configuration entry pointed by |p_cfg|.
+bool A2DP_VendorInitCodecConfigLhdcV5(AvdtpSepConfig* p_cfg);
+
+bool A2DP_VendorGetSrcCapVectorLhdcV5(uint8_t* capVector);
+
+
+
+// Checks whether the codec capabilities contain a valid A2DP LHDC V3 Sink codec.
+// NOTE: only codecs that are implemented are considered valid.
+// Returns true if |p_codec_info| contains information about a valid SBC codec,
+// otherwise false.
+bool A2DP_IsVendorSinkCodecValidLhdcV5(const uint8_t* p_codec_info);
+
+// Checks whether the codec capabilities contain a valid peer A2DP SBC Source
+// codec.
+// NOTE: only codecs that are implemented are considered valid.
+// Returns true if |p_codec_info| contains information about a valid SBC codec,
+// otherwise false.
+bool A2DP_IsVendorPeerSourceCodecValidLhdcV5(const uint8_t* p_codec_info);
+
+// Checks whether A2DP SBC Sink codec is supported.
+// |p_codec_info| contains information about the codec capabilities.
+// Returns true if the A2DP SBC Sink codec is supported, otherwise false.
+bool A2DP_IsVendorSinkCodecSupportedLhdcV5(const uint8_t* p_codec_info);
+
+// Checks whether an A2DP SBC Source codec for a peer Source device is
+// supported.
+// |p_codec_info| contains information about the codec capabilities of the
+// peer device.
+// Returns true if the A2DP SBC Source codec for a peer Source device is
+// supported, otherwise false.
+bool A2DP_IsPeerSourceCodecSupportedLhdcV5(const uint8_t* p_codec_info);
+
+// Gets the A2DP SBC codec name for a given |p_codec_info|.
+const char* A2DP_VendorCodecNameLhdcV5Sink(const uint8_t* p_codec_info);
+
+// Gets the channel type for the A2DP SBC Sink codec:
+// 1 for mono, or 3 for dual/stereo/joint.
+// |p_codec_info| is a pointer to the SBC codec_info to decode.
+// Returns the channel type on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetSinkTrackChannelTypeLhdcV5(const uint8_t* p_codec_info);
+
+// Gets the A2DP SBC decoder interface that can be used to decode received A2DP
+// packets - see |tA2DP_DECODER_INTERFACE|.
+// |p_codec_info| contains the codec information.
+// Returns the A2DP SBC decoder interface if the |p_codec_info| is valid and
+// supported, otherwise NULL.
+const tA2DP_DECODER_INTERFACE* A2DP_VendorGetDecoderInterfaceLhdcV5(
+    const uint8_t* p_codec_info);
+
+// Gets the A2DP SBC Sink codec index for a given |p_codec_info|.
+// Returns the corresponding |btav_a2dp_codec_index_t| on success,
+// otherwise |BTAV_A2DP_CODEC_INDEX_MAX|.
+btav_a2dp_codec_index_t A2DP_VendorSinkCodecIndexLhdcV5(const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC V3 Sink codec name.
+const char* A2DP_VendorCodecIndexStrLhdcV5Sink(void);
+
+// Initializes A2DP SBC Sink codec information into |AvdtpSepConfig|
+// configuration entry pointed by |p_cfg|.
+bool A2DP_VendorInitCodecConfigLhdcV5Sink(AvdtpSepConfig* p_cfg);
+
+// Gets the track bitrate value for the A2DP LHDCV5 codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the track bit rate on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetBitRateLhdcV5(const uint8_t* p_codec_info);
+
+#endif  // A2DP_VENDOR_LHDCV5_H
diff --git a/system/bt/stack/include/a2dp_vendor_lhdcv5_constants.h b/system/bt/stack/include/a2dp_vendor_lhdcv5_constants.h
new file mode 100755
index 00000000..b405d922
--- /dev/null
+++ b/system/bt/stack/include/a2dp_vendor_lhdcv5_constants.h
@@ -0,0 +1,255 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// A2DP constants for LHDC codec
+//
+
+#ifndef A2DP_VENDOR_LHDCV5_CONSTANTS_H
+#define A2DP_VENDOR_LHDCV5_CONSTANTS_H
+
+////////////////////////////////////////////////////////////////////
+// LHDCV5 codec info format:
+// SubVersion: A2DP_LHDCV5_VER1
+// Total Length: A2DP_LHDCV5_CODEC_LEN + 1(losc)
+//  ----------------------------------------------------------------
+//  H0   |    H1     |    H2     |  P0-P3   | P4-P5   | P6[5:0]  |
+//  losc | mediaType | codecType | vendorId | codecId | SampRate |
+//  ----------------------------------------------------------------
+//  P7[2:0]   | P7[5:4]    | P7[7:6]       | P8[3:0] | P8[4]       |
+//  bit depth | MaxBitRate | MinBitRate    | Version | FrameLen5ms |
+//  ----------------------------------------------------------------
+//  P9[0] | P9[1]  | P9[2]   | P9[6] | P9[7]       | P10[0]      |
+//  HasAR | HasJAS | HasMeta | HasLL | HasLossless | FeatureOnAR |
+//  ----------------------------------------------------------------
+
+// P0-P3 Vendor ID: (0x0000053a)
+// P4-P5 Vendor Specific Codec ID: (0x4C35)
+// P6[5:0] Sampling Frequency
+#define A2DP_LHDCV5_SAMPLING_FREQ_MASK    (0x35)
+#define A2DP_LHDCV5_SAMPLING_FREQ_44100   (0x20)
+#define A2DP_LHDCV5_SAMPLING_FREQ_48000   (0x10)
+#define A2DP_LHDCV5_SAMPLING_FREQ_96000   (0x04)
+#define A2DP_LHDCV5_SAMPLING_FREQ_192000  (0x01)
+#define A2DP_LHDCV5_SAMPLING_FREQ_NS      (0x00)
+
+// P7[2:0] Bit depth
+#define A2DP_LHDCV5_BIT_FMT_MASK  (0x07)
+#define A2DP_LHDCV5_BIT_FMT_16    (0x04)
+#define A2DP_LHDCV5_BIT_FMT_24    (0x02)
+#define A2DP_LHDCV5_BIT_FMT_32    (0x01)
+#define A2DP_LHDCV5_BIT_FMT_NS    (0x00)
+
+// P7[5:4] Max Bit Rate Type
+#define A2DP_LHDCV5_MAX_BIT_RATE_MASK   (0x30)
+#define A2DP_LHDCV5_MAX_BIT_RATE_900K   (0x30)
+#define A2DP_LHDCV5_MAX_BIT_RATE_500K   (0x20)
+#define A2DP_LHDCV5_MAX_BIT_RATE_400K   (0x10)
+#define A2DP_LHDCV5_MAX_BIT_RATE_1000K  (0x00)
+
+// P7[7:6] Min Bit Rate Type
+#define A2DP_LHDCV5_MIN_BIT_RATE_MASK   (0xC0)
+#define A2DP_LHDCV5_MIN_BIT_RATE_400K   (0xC0)
+#define A2DP_LHDCV5_MIN_BIT_RATE_256K   (0x80)
+#define A2DP_LHDCV5_MIN_BIT_RATE_128K   (0x40)
+#define A2DP_LHDCV5_MIN_BIT_RATE_64K    (0x00)
+
+// P8[3:0] Codec SubVersion (bitmap)
+#define A2DP_LHDCV5_VERSION_MASK    (0x0F)
+#define A2DP_LHDCV5_VER_1           (0x01)
+#define A2DP_LHDCV5_VER_NS          (0x00)
+
+// P8[5:4] Frame Length Type
+#define A2DP_LHDCV5_FRAME_LEN_MASK  (0x10)
+#define A2DP_LHDCV5_FRAME_LEN_5MS   (0x10)
+#define A2DP_LHDCV5_FRAME_LEN_NS    (0x00)
+
+// P9[0] HasAR
+// P9[1] HasJAS
+// P9[2] HasMeta
+// P9[6] HasLowLatency
+// P9[7] HasLossless
+#define A2DP_LHDCV5_FEATURE_MASK      (0xC7)
+#define A2DP_LHDCV5_FEATURE_LLESS     (0x80)
+#define A2DP_LHDCV5_FEATURE_LL        (0x40)
+#define A2DP_LHDCV5_FEATURE_META      (0x04)
+#define A2DP_LHDCV5_FEATURE_JAS       (0x02)
+#define A2DP_LHDCV5_FEATURE_AR        (0x01)
+
+// P10[0] AR ON/OFF
+#define A2DP_LHDCV5_AR_ON        (0x01)
+////////////////////////////////////////////////////////////////////
+
+////////////////////////////////////////////////////////////////////
+//  attributes which not in codec info format
+//    channel mode
+//    channel separation mode
+////////////////////////////////////////////////////////////////////
+// channel mode:
+#define A2DP_LHDCV5_CHANNEL_MODE_MASK   (0x07)
+#define A2DP_LHDCV5_CHANNEL_MODE_MONO   (0x04)
+#define A2DP_LHDCV5_CHANNEL_MODE_DUAL   (0x02)
+#define A2DP_LHDCV5_CHANNEL_MODE_STEREO (0x01)
+#define A2DP_LHDCV5_CHANNEL_MODE_NS     (0x00)
+
+// LHDC Quality Mode Index
+#define A2DP_LHDCV5_QUALITY_MASK   (0x0F)
+#define A2DP_LHDCV5_QUALITY_ABR    (0x09)  // Adaptive Bit Rate
+#define A2DP_LHDCV5_QUALITY_HIGH1  (0x08)  // 1000kbps
+#define A2DP_LHDCV5_QUALITY_HIGH   (0x07)  // 900kbps
+#define A2DP_LHDCV5_QUALITY_MID    (0x06)  // 500kbps
+#define A2DP_LHDCV5_QUALITY_LOW    (0x05)  // 400kbps
+#define A2DP_LHDCV5_QUALITY_LOW4   (0x04)  // 320kbps
+#define A2DP_LHDCV5_QUALITY_LOW3   (0x03)  // 256kbps
+#define A2DP_LHDCV5_QUALITY_LOW2   (0x02)  // 192kbps
+#define A2DP_LHDCV5_QUALITY_LOW1   (0x01)  // 128kbps
+#define A2DP_LHDCV5_QUALITY_LOW0   (0x00)  // 64kbps
+////////////////////////////////////////////////////////////////////
+
+/************************************************
+ * LHDC Feature Capabilities on A2DP specifics:
+   * feature id:                          (1 byte)
+   * target specific index:               (2 bits)
+   * target bit index on a specific:      (decimal: 0~63)
+************************************************/
+// feature code:
+#define LHDCV5_FEATURE_CODE_MASK     (0xFF)
+#define LHDCV5_FEATURE_CODE_NA       (0x00)
+#define LHDCV5_FEATURE_CODE_JAS      (0x01)
+#define LHDCV5_FEATURE_CODE_AR       (0x02)
+#define LHDCV5_FEATURE_CODE_META     (0x03)
+#define LHDCV5_FEATURE_CODE_LL       (0x08)
+#define LHDCV5_FEATURE_CODE_LLESS    (0x09)
+
+// target specific index:
+#define LHDCV5_FEATURE_ON_A2DP_SPECIFIC_1    (0x00)     //2-bit:00
+#define LHDCV5_FEATURE_ON_A2DP_SPECIFIC_2    (0x40)     //2-bit:01
+#define LHDCV5_FEATURE_ON_A2DP_SPECIFIC_3    (0x80)     //2-bit:10
+#define LHDCV5_FEATURE_ON_A2DP_SPECIFIC_4    (0xC0)     //2-bit:11
+
+// target bit index on the specific:
+//  specific@1
+#define LHDCV5_FEATURE_QM_SPEC_BIT_POS        (0x00)
+//  specific@2
+#define LHDCV5_FEATURE_LL_SPEC_BIT_POS        (0x00)
+//  specific@3
+#define LHDCV5_FEATURE_JAS_SPEC_BIT_POS       (0x00)
+#define LHDCV5_FEATURE_AR_SPEC_BIT_POS        (0x01)
+#define LHDCV5_FEATURE_META_SPEC_BIT_POS      (0x02)
+#define LHDCV5_FEATURE_LLESS_SPEC_BIT_POS     (0x07)
+// Notice: the highest bit position is limited by A2DP_LHDC_FEATURE_MAGIC_NUM(0x4C000000)
+//  ie., available range in a specific: int64[24:0]
+#define LHDCV5_FEATURE_MAX_SPEC_BIT_POS       (0x19)
+
+#define LHDC_SETUP_A2DP_SPEC(cfg, spec, has, value)  do{   \
+  if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_1 ) \
+    (has) ? (cfg->codec_specific_1 |= value) : (cfg->codec_specific_1 &= ~value);   \
+  if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_2 ) \
+    (has) ? (cfg->codec_specific_2 |= value) : (cfg->codec_specific_2 &= ~value);   \
+  if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_3 ) \
+    (has) ? (cfg->codec_specific_3 |= value) : (cfg->codec_specific_3 &= ~value);   \
+  if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_4 ) \
+    (has) ? (cfg->codec_specific_4 |= value) : (cfg->codec_specific_4 &= ~value);   \
+} while(0)
+
+#define LHDCV5_CHECK_IN_A2DP_SPEC(cfg, spec, value)  ({ \
+  bool marco_ret = false; \
+  do{   \
+    if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_1 ) \
+      marco_ret = (cfg->codec_specific_1 & value);   \
+    if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_2 ) \
+      marco_ret = (cfg->codec_specific_2 & value);   \
+    if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_3 ) \
+      marco_ret = (cfg->codec_specific_3 & value);   \
+    if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_4 ) \
+      marco_ret = (cfg->codec_specific_4 & value);   \
+    } while(0);  \
+  marco_ret;   \
+})
+
+//
+// Savitech - LHDC Extended API Start
+//
+/* LHDC Extend API Category */
+// A2DP Type API: handled in bt stack
+#define LHDCV5_EXTEND_API_CODE_A2DP_TYPE            (0x0A)
+// Lib Type API: handled by codec lib
+#define LHDCV5_EXTEND_API_CODE_LIB_TYPE             (0x0C)
+
+#define LHDCV5_EXTEND_API_A2DP_SPEC_CODE_HEAD       (4)   /* position of API command code in buffer field */
+#define LHDCV5_EXTEND_API_A2DP_SPEC_ID_HEAD         (8)   /* position of codec config id in buffer field */
+
+//
+// A2DP Type API: Get info from A2DP codec config's specifics
+//
+#define LHDCV5_EXTEND_API_A2DP_SPEC_CODE      (0x0A010001)
+#define LHDCV5_EXTEND_API_A2DP_SPEC_VER2      (0x02000000)
+
+/* id for A2DP codec config
+ * 0x01: codec_config_
+ * 0x02: codec_capability_
+ * 0x03: codec_local_capability_
+ * 0x04: codec_selectable_capability_
+ * 0x05: codec_user_config_
+ * 0x06: codec_audio_config_
+ */
+#define LHDCV5_EXTEND_API_A2DP_SPEC_CFG                (0x01)
+#define LHDCV5_EXTEND_API_A2DP_SPEC_CAP                (0x02)
+#define LHDCV5_EXTEND_API_A2DP_SPEC_LOCAL_CAP          (0x03)
+#define LHDCV5_EXTEND_API_A2DP_SPEC_SELECT_CAP         (0x04)
+#define LHDCV5_EXTEND_API_A2DP_SPEC_USER_CFG           (0x05)
+#define LHDCV5_EXTEND_API_A2DP_SPEC_AUDIO_CFG          (0x06)
+/* ************************************************************************
+ * Fields in buffer for LHDCV5_EXTEND_API_VER_GET_SPECIFIC_V2
+ * total 64 bytes:
+   * API Version:                   (4 bytes)
+   * API Code:                      (4 bytes)
+   * A2DP Codec Config Id:          (1 bytes)
+   * Reserved:                      (7 bytes)
+   * A2dp Specific1:                (8 bytes)
+   * A2dp Specific2:                (8 bytes)
+   * A2dp Specific3:                (8 bytes)
+   * A2dp Specific4:                (8 bytes)
+   * Info fields:                   (5*2 bytes)
+     * [0~1]: AR
+     * [2~3]: JAS
+     * [4~5]: META
+     * [6~7]: Low Latency
+     * [8~9]: Loss Less
+   * Pad:                           (6 bytes)
+ * ************************************************************************/
+#define LHDCV5_EXTEND_API_A2DP_SPEC_VER_SIZE        4       /* API version */
+#define LHDCV5_EXTEND_API_A2DP_SPEC_CODE_SIZE       4       /* API index code */
+#define LHDCV5_EXTEND_API_A2DP_SPEC_CFGID_SIZE      1       /* A2DP codec config code */
+#define LHDCV5_EXTEND_API_A2DP_SPEC_RSVD_V2         7       /* Reserved bytes */
+#define LHDCV5_EXTEND_API_A2DP_SPEC_1_SIZE          8       /* Specific 1 */
+#define LHDCV5_EXTEND_API_A2DP_SPEC_2_SIZE          8       /* Specific 2 */
+#define LHDCV5_EXTEND_API_A2DP_SPEC_3_SIZE          8       /* Specific 3 */
+#define LHDCV5_EXTEND_API_A2DP_SPEC_4_SIZE          8       /* Specific 4 */
+#define LHDCV5_EXTEND_API_A2DP_SPEC_INFO_SIZE_V2    (5<<1)  /* Info fields */
+// total size of buffer fields (64)
+#define LHDCV5_EXTEND_API_A2DP_SPEC_TOTAL_SIZE_V2   (64)
+
+#define LHDCV5_EXTEND_API_A2DP_SPEC1_HEAD_V2        (16)
+#define LHDCV5_EXTEND_API_A2DP_SPEC2_HEAD_V2        (24)
+#define LHDCV5_EXTEND_API_A2DP_SPEC3_HEAD_V2        (32)
+#define LHDCV5_EXTEND_API_A2DP_SPEC4_HEAD_V2        (40)
+#define LHDCV5_EXTEND_API_A2DP_SPEC_INFO_HEAD_V2    (48)
+
+//
+// Savitech - LHDC Extended API End
+//
+#endif  // A2DP_VENDOR_LHDCV5_CONSTANTS_H
diff --git a/system/bt/stack/include/a2dp_vendor_lhdcv5_decoder.h b/system/bt/stack/include/a2dp_vendor_lhdcv5_decoder.h
new file mode 100755
index 00000000..ba5be982
--- /dev/null
+++ b/system/bt/stack/include/a2dp_vendor_lhdcv5_decoder.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// Interface to the A2DP LHDC V5 Decoder
+//
+
+#ifndef A2DP_VENDOR_LHDCV5_DECODER_H
+#define A2DP_VENDOR_LHDCV5_DECODER_H
+
+#include "a2dp_codec_api.h"
+#include "a2dp_vendor_lhdc_constants.h"
+#include "a2dp_vendor_lhdcv5_constants.h"
+
+
+// Save CODEC information
+// Return true on success, otherwise false.
+bool a2dp_lhdcv5_decoder_save_codec_info (const uint8_t* p_codec_info);
+
+// Loads the A2DP LHDC V5 decoder.
+// Return true on success, otherwise false.
+bool A2DP_VendorLoadDecoderLhdcV5(void);
+
+// Unloads the A2DP LHDC V5 decoder.
+void A2DP_VendorUnloadDecoderLhdcV5(void);
+
+// Initialize the A2DP LHDC V5 decoder.
+bool a2dp_vendor_lhdcv5_decoder_init(decoded_data_callback_t decode_callback);
+
+// Cleanup the A2DP LHDC V5 decoder.
+void a2dp_vendor_lhdcv5_decoder_cleanup(void);
+
+// Decode LHDC V5 packet to PCM
+bool a2dp_vendor_lhdcv5_decoder_decode_packet(BT_HDR* p_buf);
+
+// Start the A2DP LHDC V5 decoder.
+void a2dp_vendor_lhdcv5_decoder_start(void);
+
+// Suspend the A2DP LHDC V5 decoder.
+void a2dp_vendor_lhdcv5_decoder_suspend(void);
+
+// A2DP LHDC V5 decoder configuration.
+void a2dp_vendor_lhdcv5_decoder_configure(const uint8_t* p_codec_info);
+
+#endif  // A2DP_VENDOR_LHDCV5_DECODER_H
diff --git a/system/bt/stack/include/a2dp_vendor_lhdcv5_encoder.h b/system/bt/stack/include/a2dp_vendor_lhdcv5_encoder.h
new file mode 100755
index 00000000..84b53d27
--- /dev/null
+++ b/system/bt/stack/include/a2dp_vendor_lhdcv5_encoder.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// Interface to the A2DP LHDC Encoder
+//
+
+#ifndef A2DP_VENDOR_LHDCV5_ENCODER_H
+#define A2DP_VENDOR_LHDCV5_ENCODER_H
+
+#include "a2dp_codec_api.h"
+
+// Loads the A2DP LHDC encoder.
+// Return true on success, otherwise false.
+bool A2DP_VendorLoadEncoderLhdcV5(void);
+
+// Unloads the A2DP LHDC encoder.
+bool A2DP_VendorUnloadEncoderLhdcV5(void);
+
+// Initialize the A2DP LHDC encoder.
+// |p_peer_params| contains the A2DP peer information
+// The current A2DP codec config is in |a2dp_codec_config|.
+// |read_callback| is the callback for reading the input audio data.
+// |enqueue_callback| is the callback for enqueueing the encoded audio data.
+void a2dp_vendor_lhdcv5_encoder_init(
+    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+    A2dpCodecConfig* a2dp_codec_config,
+    a2dp_source_read_callback_t read_callback,
+    a2dp_source_enqueue_callback_t enqueue_callback);
+
+// Cleanup the A2DP LHDC encoder.
+void a2dp_vendor_lhdcv5_encoder_cleanup(void);
+
+// Reset the feeding for the A2DP LHDC encoder.
+void a2dp_vendor_lhdcv5_feeding_reset(void);
+
+// Flush the feeding for the A2DP LHDC encoder.
+void a2dp_vendor_lhdcv5_feeding_flush(void);
+
+// Get the A2DP LHDC encoder interval (in milliseconds).
+uint64_t a2dp_vendor_lhdcv5_get_encoder_interval_ms(void);
+
+// Prepare and send A2DP LHDC encoded frames.
+// |timestamp_us| is the current timestamp (in microseconds).
+void a2dp_vendor_lhdcv5_send_frames(uint64_t timestamp_us);
+
+// Set transmit queue length for the A2DP LHDC ABR(Adaptive Bit Rate) mechanism.
+void a2dp_vendor_lhdcv5_set_transmit_queue_length(size_t transmit_queue_length);
+
+#endif  // A2DP_VENDOR_LHDCV5_ENCODER_H
